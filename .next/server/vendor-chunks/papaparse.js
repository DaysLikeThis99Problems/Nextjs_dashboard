/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/papaparse";
exports.ids = ["vendor-chunks/papaparse"];
exports.modules = {

/***/ "(ssr)/./node_modules/papaparse/papaparse.js":
/*!*********************************************!*\
  !*** ./node_modules/papaparse/papaparse.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* @license\nPapa Parse\nv5.5.3\nhttps://github.com/mholt/PapaParse\nLicense: MIT\n*/ (function(root, factory) {\n    /* globals define */ if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n// in strict mode we cannot access arguments.callee, so we need a named reference to\n// stringify the factory method for the blob worker\n// eslint-disable-next-line func-name\n})(this, function moduleFactory() {\n    \"use strict\";\n    var global = function() {\n        // alternative method, similar to `Function('return this')()`\n        // but without using `eval` (which is disabled when\n        // using Content Security Policy).\n        if (typeof self !== \"undefined\") {\n            return self;\n        }\n        if (false) {}\n        if (typeof global !== \"undefined\") {\n            return global;\n        }\n        // When running tests none of the above have been defined\n        return {};\n    }();\n    function getWorkerBlob() {\n        var URL = global.URL || global.webkitURL || null;\n        var code = moduleFactory.toString();\n        return Papa.BLOB_URL || (Papa.BLOB_URL = URL.createObjectURL(new Blob([\n            \"var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; \",\n            \"(\",\n            code,\n            \")();\"\n        ], {\n            type: \"text/javascript\"\n        })));\n    }\n    var IS_WORKER = !global.document && !!global.postMessage, IS_PAPA_WORKER = global.IS_PAPA_WORKER || false;\n    var workers = {}, workerIdCounter = 0;\n    var Papa = {};\n    Papa.parse = CsvToJson;\n    Papa.unparse = JsonToCsv;\n    Papa.RECORD_SEP = String.fromCharCode(30);\n    Papa.UNIT_SEP = String.fromCharCode(31);\n    Papa.BYTE_ORDER_MARK = \"\\uFEFF\";\n    Papa.BAD_DELIMITERS = [\n        \"\\r\",\n        \"\\n\",\n        '\"',\n        Papa.BYTE_ORDER_MARK\n    ];\n    Papa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;\n    Papa.NODE_STREAM_INPUT = 1;\n    // Configurable chunk sizes for local and remote files, respectively\n    Papa.LocalChunkSize = 1024 * 1024 * 10; // 10 MB\n    Papa.RemoteChunkSize = 1024 * 1024 * 5; // 5 MB\n    Papa.DefaultDelimiter = \",\"; // Used if not specified and detection fails\n    // Exposed for testing and development only\n    Papa.Parser = Parser;\n    Papa.ParserHandle = ParserHandle;\n    Papa.NetworkStreamer = NetworkStreamer;\n    Papa.FileStreamer = FileStreamer;\n    Papa.StringStreamer = StringStreamer;\n    Papa.ReadableStreamStreamer = ReadableStreamStreamer;\n    if (typeof PAPA_BROWSER_CONTEXT === \"undefined\") {\n        Papa.DuplexStreamStreamer = DuplexStreamStreamer;\n    }\n    if (global.jQuery) {\n        var $ = global.jQuery;\n        $.fn.parse = function(options) {\n            var config = options.config || {};\n            var queue = [];\n            this.each(function(idx) {\n                var supported = $(this).prop(\"tagName\").toUpperCase() === \"INPUT\" && $(this).attr(\"type\").toLowerCase() === \"file\" && global.FileReader;\n                if (!supported || !this.files || this.files.length === 0) return true; // continue to next input element\n                for(var i = 0; i < this.files.length; i++){\n                    queue.push({\n                        file: this.files[i],\n                        inputElem: this,\n                        instanceConfig: $.extend({}, config)\n                    });\n                }\n            });\n            parseNextFile(); // begin parsing\n            return this; // maintains chainability\n            function parseNextFile() {\n                if (queue.length === 0) {\n                    if (isFunction(options.complete)) options.complete();\n                    return;\n                }\n                var f = queue[0];\n                if (isFunction(options.before)) {\n                    var returned = options.before(f.file, f.inputElem);\n                    if (typeof returned === \"object\") {\n                        if (returned.action === \"abort\") {\n                            error(\"AbortError\", f.file, f.inputElem, returned.reason);\n                            return; // Aborts all queued files immediately\n                        } else if (returned.action === \"skip\") {\n                            fileComplete(); // parse the next file in the queue, if any\n                            return;\n                        } else if (typeof returned.config === \"object\") f.instanceConfig = $.extend(f.instanceConfig, returned.config);\n                    } else if (returned === \"skip\") {\n                        fileComplete(); // parse the next file in the queue, if any\n                        return;\n                    }\n                }\n                // Wrap up the user's complete callback, if any, so that ours also gets executed\n                var userCompleteFunc = f.instanceConfig.complete;\n                f.instanceConfig.complete = function(results) {\n                    if (isFunction(userCompleteFunc)) userCompleteFunc(results, f.file, f.inputElem);\n                    fileComplete();\n                };\n                Papa.parse(f.file, f.instanceConfig);\n            }\n            function error(name, file, elem, reason) {\n                if (isFunction(options.error)) options.error({\n                    name: name\n                }, file, elem, reason);\n            }\n            function fileComplete() {\n                queue.splice(0, 1);\n                parseNextFile();\n            }\n        };\n    }\n    if (IS_PAPA_WORKER) {\n        global.onmessage = workerThreadReceivedMessage;\n    }\n    function CsvToJson(_input, _config) {\n        _config = _config || {};\n        var dynamicTyping = _config.dynamicTyping || false;\n        if (isFunction(dynamicTyping)) {\n            _config.dynamicTypingFunction = dynamicTyping;\n            // Will be filled on first row call\n            dynamicTyping = {};\n        }\n        _config.dynamicTyping = dynamicTyping;\n        _config.transform = isFunction(_config.transform) ? _config.transform : false;\n        if (_config.worker && Papa.WORKERS_SUPPORTED) {\n            var w = newWorker();\n            w.userStep = _config.step;\n            w.userChunk = _config.chunk;\n            w.userComplete = _config.complete;\n            w.userError = _config.error;\n            _config.step = isFunction(_config.step);\n            _config.chunk = isFunction(_config.chunk);\n            _config.complete = isFunction(_config.complete);\n            _config.error = isFunction(_config.error);\n            delete _config.worker; // prevent infinite loop\n            w.postMessage({\n                input: _input,\n                config: _config,\n                workerId: w.id\n            });\n            return;\n        }\n        var streamer = null;\n        if (_input === Papa.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === \"undefined\") {\n            // create a node Duplex stream for use\n            // with .pipe\n            streamer = new DuplexStreamStreamer(_config);\n            return streamer.getStream();\n        } else if (typeof _input === \"string\") {\n            _input = stripBom(_input);\n            if (_config.download) streamer = new NetworkStreamer(_config);\n            else streamer = new StringStreamer(_config);\n        } else if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on)) {\n            streamer = new ReadableStreamStreamer(_config);\n        } else if (global.File && _input instanceof File || _input instanceof Object) streamer = new FileStreamer(_config);\n        return streamer.stream(_input);\n        // Strip character from UTF-8 BOM encoded files that cause issue parsing the file\n        function stripBom(string) {\n            if (string.charCodeAt(0) === 0xfeff) {\n                return string.slice(1);\n            }\n            return string;\n        }\n    }\n    function JsonToCsv(_input, _config) {\n        // Default configuration\n        /** whether to surround every datum with quotes */ var _quotes = false;\n        /** whether to write headers */ var _writeHeader = true;\n        /** delimiting character(s) */ var _delimiter = \",\";\n        /** newline character(s) */ var _newline = \"\\r\\n\";\n        /** quote character */ var _quoteChar = '\"';\n        /** escaped quote character, either \"\" or <config.escapeChar>\" */ var _escapedQuote = _quoteChar + _quoteChar;\n        /** whether to skip empty lines */ var _skipEmptyLines = false;\n        /** the columns (keys) we expect when we unparse objects */ var _columns = null;\n        /** whether to prevent outputting cells that can be parsed as formulae by spreadsheet software (Excel and LibreOffice) */ var _escapeFormulae = false;\n        unpackConfig();\n        var quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), \"g\");\n        if (typeof _input === \"string\") _input = JSON.parse(_input);\n        if (Array.isArray(_input)) {\n            if (!_input.length || Array.isArray(_input[0])) return serialize(null, _input, _skipEmptyLines);\n            else if (typeof _input[0] === \"object\") return serialize(_columns || Object.keys(_input[0]), _input, _skipEmptyLines);\n        } else if (typeof _input === \"object\") {\n            if (typeof _input.data === \"string\") _input.data = JSON.parse(_input.data);\n            if (Array.isArray(_input.data)) {\n                if (!_input.fields) _input.fields = _input.meta && _input.meta.fields || _columns;\n                if (!_input.fields) _input.fields = Array.isArray(_input.data[0]) ? _input.fields : typeof _input.data[0] === \"object\" ? Object.keys(_input.data[0]) : [];\n                if (!Array.isArray(_input.data[0]) && typeof _input.data[0] !== \"object\") _input.data = [\n                    _input.data\n                ]; // handles input like [1,2,3] or ['asdf']\n            }\n            return serialize(_input.fields || [], _input.data || [], _skipEmptyLines);\n        }\n        // Default (any valid paths should return before this)\n        throw new Error(\"Unable to serialize unrecognized input\");\n        function unpackConfig() {\n            if (typeof _config !== \"object\") return;\n            if (typeof _config.delimiter === \"string\" && !Papa.BAD_DELIMITERS.filter(function(value) {\n                return _config.delimiter.indexOf(value) !== -1;\n            }).length) {\n                _delimiter = _config.delimiter;\n            }\n            if (typeof _config.quotes === \"boolean\" || typeof _config.quotes === \"function\" || Array.isArray(_config.quotes)) _quotes = _config.quotes;\n            if (typeof _config.skipEmptyLines === \"boolean\" || typeof _config.skipEmptyLines === \"string\") _skipEmptyLines = _config.skipEmptyLines;\n            if (typeof _config.newline === \"string\") _newline = _config.newline;\n            if (typeof _config.quoteChar === \"string\") _quoteChar = _config.quoteChar;\n            if (typeof _config.header === \"boolean\") _writeHeader = _config.header;\n            if (Array.isArray(_config.columns)) {\n                if (_config.columns.length === 0) throw new Error(\"Option columns is empty\");\n                _columns = _config.columns;\n            }\n            if (_config.escapeChar !== undefined) {\n                _escapedQuote = _config.escapeChar + _quoteChar;\n            }\n            if (_config.escapeFormulae instanceof RegExp) {\n                _escapeFormulae = _config.escapeFormulae;\n            } else if (typeof _config.escapeFormulae === \"boolean\" && _config.escapeFormulae) {\n                _escapeFormulae = /^[=+\\-@\\t\\r].*$/;\n            }\n        }\n        /** The double for loop that iterates the data and writes out a CSV string including header row */ function serialize(fields, data, skipEmptyLines) {\n            var csv = \"\";\n            if (typeof fields === \"string\") fields = JSON.parse(fields);\n            if (typeof data === \"string\") data = JSON.parse(data);\n            var hasHeader = Array.isArray(fields) && fields.length > 0;\n            var dataKeyedByField = !Array.isArray(data[0]);\n            // If there a header row, write it first\n            if (hasHeader && _writeHeader) {\n                for(var i = 0; i < fields.length; i++){\n                    if (i > 0) csv += _delimiter;\n                    csv += safe(fields[i], i);\n                }\n                if (data.length > 0) csv += _newline;\n            }\n            // Then write out the data\n            for(var row = 0; row < data.length; row++){\n                var maxCol = hasHeader ? fields.length : data[row].length;\n                var emptyLine = false;\n                var nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;\n                if (skipEmptyLines && !hasHeader) {\n                    emptyLine = skipEmptyLines === \"greedy\" ? data[row].join(\"\").trim() === \"\" : data[row].length === 1 && data[row][0].length === 0;\n                }\n                if (skipEmptyLines === \"greedy\" && hasHeader) {\n                    var line = [];\n                    for(var c = 0; c < maxCol; c++){\n                        var cx = dataKeyedByField ? fields[c] : c;\n                        line.push(data[row][cx]);\n                    }\n                    emptyLine = line.join(\"\").trim() === \"\";\n                }\n                if (!emptyLine) {\n                    for(var col = 0; col < maxCol; col++){\n                        if (col > 0 && !nullLine) csv += _delimiter;\n                        var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n                        csv += safe(data[row][colIdx], col);\n                    }\n                    if (row < data.length - 1 && (!skipEmptyLines || maxCol > 0 && !nullLine)) {\n                        csv += _newline;\n                    }\n                }\n            }\n            return csv;\n        }\n        /** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */ function safe(str, col) {\n            if (typeof str === \"undefined\" || str === null) return \"\";\n            if (str.constructor === Date) return JSON.stringify(str).slice(1, 25);\n            var needsQuotes = false;\n            if (_escapeFormulae && typeof str === \"string\" && _escapeFormulae.test(str)) {\n                str = \"'\" + str;\n                needsQuotes = true;\n            }\n            var escapedQuoteStr = str.toString().replace(quoteCharRegex, _escapedQuote);\n            needsQuotes = needsQuotes || _quotes === true || typeof _quotes === \"function\" && _quotes(str, col) || Array.isArray(_quotes) && _quotes[col] || hasAny(escapedQuoteStr, Papa.BAD_DELIMITERS) || escapedQuoteStr.indexOf(_delimiter) > -1 || escapedQuoteStr.charAt(0) === \" \" || escapedQuoteStr.charAt(escapedQuoteStr.length - 1) === \" \";\n            return needsQuotes ? _quoteChar + escapedQuoteStr + _quoteChar : escapedQuoteStr;\n        }\n        function hasAny(str, substrings) {\n            for(var i = 0; i < substrings.length; i++)if (str.indexOf(substrings[i]) > -1) return true;\n            return false;\n        }\n    }\n    /** ChunkStreamer is the base prototype for various streamer implementations. */ function ChunkStreamer(config) {\n        this._handle = null;\n        this._finished = false;\n        this._completed = false;\n        this._halted = false;\n        this._input = null;\n        this._baseIndex = 0;\n        this._partialLine = \"\";\n        this._rowCount = 0;\n        this._start = 0;\n        this._nextChunk = null;\n        this.isFirstChunk = true;\n        this._completeResults = {\n            data: [],\n            errors: [],\n            meta: {}\n        };\n        replaceConfig.call(this, config);\n        this.parseChunk = function(chunk, isFakeChunk) {\n            // First chunk pre-processing\n            const skipFirstNLines = parseInt(this._config.skipFirstNLines) || 0;\n            if (this.isFirstChunk && skipFirstNLines > 0) {\n                let _newline = this._config.newline;\n                if (!_newline) {\n                    const quoteChar = this._config.quoteChar || '\"';\n                    _newline = this._handle.guessLineEndings(chunk, quoteChar);\n                }\n                const splitChunk = chunk.split(_newline);\n                chunk = [\n                    ...splitChunk.slice(skipFirstNLines)\n                ].join(_newline);\n            }\n            if (this.isFirstChunk && isFunction(this._config.beforeFirstChunk)) {\n                var modifiedChunk = this._config.beforeFirstChunk(chunk);\n                if (modifiedChunk !== undefined) chunk = modifiedChunk;\n            }\n            this.isFirstChunk = false;\n            this._halted = false;\n            // Rejoin the line we likely just split in two by chunking the file\n            var aggregate = this._partialLine + chunk;\n            this._partialLine = \"\";\n            var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);\n            if (this._handle.paused() || this._handle.aborted()) {\n                this._halted = true;\n                return;\n            }\n            var lastIndex = results.meta.cursor;\n            if (!this._finished) {\n                this._partialLine = aggregate.substring(lastIndex - this._baseIndex);\n                this._baseIndex = lastIndex;\n            }\n            if (results && results.data) this._rowCount += results.data.length;\n            var finishedIncludingPreview = this._finished || this._config.preview && this._rowCount >= this._config.preview;\n            if (IS_PAPA_WORKER) {\n                global.postMessage({\n                    results: results,\n                    workerId: Papa.WORKER_ID,\n                    finished: finishedIncludingPreview\n                });\n            } else if (isFunction(this._config.chunk) && !isFakeChunk) {\n                this._config.chunk(results, this._handle);\n                if (this._handle.paused() || this._handle.aborted()) {\n                    this._halted = true;\n                    return;\n                }\n                results = undefined;\n                this._completeResults = undefined;\n            }\n            if (!this._config.step && !this._config.chunk) {\n                this._completeResults.data = this._completeResults.data.concat(results.data);\n                this._completeResults.errors = this._completeResults.errors.concat(results.errors);\n                this._completeResults.meta = results.meta;\n            }\n            if (!this._completed && finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted)) {\n                this._config.complete(this._completeResults, this._input);\n                this._completed = true;\n            }\n            if (!finishedIncludingPreview && (!results || !results.meta.paused)) this._nextChunk();\n            return results;\n        };\n        this._sendError = function(error) {\n            if (isFunction(this._config.error)) this._config.error(error);\n            else if (IS_PAPA_WORKER && this._config.error) {\n                global.postMessage({\n                    workerId: Papa.WORKER_ID,\n                    error: error,\n                    finished: false\n                });\n            }\n        };\n        function replaceConfig(config) {\n            // Deep-copy the config so we can edit it\n            var configCopy = copy(config);\n            configCopy.chunkSize = parseInt(configCopy.chunkSize); // parseInt VERY important so we don't concatenate strings!\n            if (!config.step && !config.chunk) configCopy.chunkSize = null; // disable Range header if not streaming; bad values break IIS - see issue #196\n            this._handle = new ParserHandle(configCopy);\n            this._handle.streamer = this;\n            this._config = configCopy; // persist the copy to the caller\n        }\n    }\n    function NetworkStreamer(config) {\n        config = config || {};\n        if (!config.chunkSize) config.chunkSize = Papa.RemoteChunkSize;\n        ChunkStreamer.call(this, config);\n        var xhr;\n        if (IS_WORKER) {\n            this._nextChunk = function() {\n                this._readChunk();\n                this._chunkLoaded();\n            };\n        } else {\n            this._nextChunk = function() {\n                this._readChunk();\n            };\n        }\n        this.stream = function(url) {\n            this._input = url;\n            this._nextChunk(); // Starts streaming\n        };\n        this._readChunk = function() {\n            if (this._finished) {\n                this._chunkLoaded();\n                return;\n            }\n            xhr = new XMLHttpRequest();\n            if (this._config.withCredentials) {\n                xhr.withCredentials = this._config.withCredentials;\n            }\n            if (!IS_WORKER) {\n                xhr.onload = bindFunction(this._chunkLoaded, this);\n                xhr.onerror = bindFunction(this._chunkError, this);\n            }\n            xhr.open(this._config.downloadRequestBody ? \"POST\" : \"GET\", this._input, !IS_WORKER);\n            // Headers can only be set when once the request state is OPENED\n            if (this._config.downloadRequestHeaders) {\n                var headers = this._config.downloadRequestHeaders;\n                for(var headerName in headers){\n                    xhr.setRequestHeader(headerName, headers[headerName]);\n                }\n            }\n            if (this._config.chunkSize) {\n                var end = this._start + this._config.chunkSize - 1; // minus one because byte range is inclusive\n                xhr.setRequestHeader(\"Range\", \"bytes=\" + this._start + \"-\" + end);\n            }\n            try {\n                xhr.send(this._config.downloadRequestBody);\n            } catch (err) {\n                this._chunkError(err.message);\n            }\n            if (IS_WORKER && xhr.status === 0) this._chunkError();\n        };\n        this._chunkLoaded = function() {\n            if (xhr.readyState !== 4) return;\n            if (xhr.status < 200 || xhr.status >= 400) {\n                this._chunkError();\n                return;\n            }\n            // Use chunckSize as it may be a diference on reponse lentgh due to characters with more than 1 byte\n            this._start += this._config.chunkSize ? this._config.chunkSize : xhr.responseText.length;\n            this._finished = !this._config.chunkSize || this._start >= getFileSize(xhr);\n            this.parseChunk(xhr.responseText);\n        };\n        this._chunkError = function(errorMessage) {\n            var errorText = xhr.statusText || errorMessage;\n            this._sendError(new Error(errorText));\n        };\n        function getFileSize(xhr) {\n            var contentRange = xhr.getResponseHeader(\"Content-Range\");\n            if (contentRange === null) {\n                return -1;\n            }\n            return parseInt(contentRange.substring(contentRange.lastIndexOf(\"/\") + 1));\n        }\n    }\n    NetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);\n    NetworkStreamer.prototype.constructor = NetworkStreamer;\n    function FileStreamer(config) {\n        config = config || {};\n        if (!config.chunkSize) config.chunkSize = Papa.LocalChunkSize;\n        ChunkStreamer.call(this, config);\n        var reader, slice;\n        // FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862\n        // But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76\n        var usingAsyncReader = typeof FileReader !== \"undefined\"; // Safari doesn't consider it a function - see issue #105\n        this.stream = function(file) {\n            this._input = file;\n            slice = file.slice || file.webkitSlice || file.mozSlice;\n            if (usingAsyncReader) {\n                reader = new FileReader(); // Preferred method of reading files, even in workers\n                reader.onload = bindFunction(this._chunkLoaded, this);\n                reader.onerror = bindFunction(this._chunkError, this);\n            } else reader = new FileReaderSync(); // Hack for running in a web worker in Firefox\n            this._nextChunk(); // Starts streaming\n        };\n        this._nextChunk = function() {\n            if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview)) this._readChunk();\n        };\n        this._readChunk = function() {\n            var input = this._input;\n            if (this._config.chunkSize) {\n                var end = Math.min(this._start + this._config.chunkSize, this._input.size);\n                input = slice.call(input, this._start, end);\n            }\n            var txt = reader.readAsText(input, this._config.encoding);\n            if (!usingAsyncReader) this._chunkLoaded({\n                target: {\n                    result: txt\n                }\n            }); // mimic the async signature\n        };\n        this._chunkLoaded = function(event) {\n            // Very important to increment start each time before handling results\n            this._start += this._config.chunkSize;\n            this._finished = !this._config.chunkSize || this._start >= this._input.size;\n            this.parseChunk(event.target.result);\n        };\n        this._chunkError = function() {\n            this._sendError(reader.error);\n        };\n    }\n    FileStreamer.prototype = Object.create(ChunkStreamer.prototype);\n    FileStreamer.prototype.constructor = FileStreamer;\n    function StringStreamer(config) {\n        config = config || {};\n        ChunkStreamer.call(this, config);\n        var remaining;\n        this.stream = function(s) {\n            remaining = s;\n            return this._nextChunk();\n        };\n        this._nextChunk = function() {\n            if (this._finished) return;\n            var size = this._config.chunkSize;\n            var chunk;\n            if (size) {\n                chunk = remaining.substring(0, size);\n                remaining = remaining.substring(size);\n            } else {\n                chunk = remaining;\n                remaining = \"\";\n            }\n            this._finished = !remaining;\n            return this.parseChunk(chunk);\n        };\n    }\n    StringStreamer.prototype = Object.create(StringStreamer.prototype);\n    StringStreamer.prototype.constructor = StringStreamer;\n    function ReadableStreamStreamer(config) {\n        config = config || {};\n        ChunkStreamer.call(this, config);\n        var queue = [];\n        var parseOnData = true;\n        var streamHasEnded = false;\n        this.pause = function() {\n            ChunkStreamer.prototype.pause.apply(this, arguments);\n            this._input.pause();\n        };\n        this.resume = function() {\n            ChunkStreamer.prototype.resume.apply(this, arguments);\n            this._input.resume();\n        };\n        this.stream = function(stream) {\n            this._input = stream;\n            this._input.on(\"data\", this._streamData);\n            this._input.on(\"end\", this._streamEnd);\n            this._input.on(\"error\", this._streamError);\n        };\n        this._checkIsFinished = function() {\n            if (streamHasEnded && queue.length === 1) {\n                this._finished = true;\n            }\n        };\n        this._nextChunk = function() {\n            this._checkIsFinished();\n            if (queue.length) {\n                this.parseChunk(queue.shift());\n            } else {\n                parseOnData = true;\n            }\n        };\n        this._streamData = bindFunction(function(chunk) {\n            try {\n                queue.push(typeof chunk === \"string\" ? chunk : chunk.toString(this._config.encoding));\n                if (parseOnData) {\n                    parseOnData = false;\n                    this._checkIsFinished();\n                    this.parseChunk(queue.shift());\n                }\n            } catch (error) {\n                this._streamError(error);\n            }\n        }, this);\n        this._streamError = bindFunction(function(error) {\n            this._streamCleanUp();\n            this._sendError(error);\n        }, this);\n        this._streamEnd = bindFunction(function() {\n            this._streamCleanUp();\n            streamHasEnded = true;\n            this._streamData(\"\");\n        }, this);\n        this._streamCleanUp = bindFunction(function() {\n            this._input.removeListener(\"data\", this._streamData);\n            this._input.removeListener(\"end\", this._streamEnd);\n            this._input.removeListener(\"error\", this._streamError);\n        }, this);\n    }\n    ReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n    ReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;\n    function DuplexStreamStreamer(_config) {\n        var Duplex = (__webpack_require__(/*! stream */ \"stream\").Duplex);\n        var config = copy(_config);\n        var parseOnWrite = true;\n        var writeStreamHasFinished = false;\n        var parseCallbackQueue = [];\n        var stream = null;\n        this._onCsvData = function(results) {\n            var data = results.data;\n            if (!stream.push(data) && !this._handle.paused()) {\n                // the writeable consumer buffer has filled up\n                // so we need to pause until more items\n                // can be processed\n                this._handle.pause();\n            }\n        };\n        this._onCsvComplete = function() {\n            // node will finish the read stream when\n            // null is pushed\n            stream.push(null);\n        };\n        config.step = bindFunction(this._onCsvData, this);\n        config.complete = bindFunction(this._onCsvComplete, this);\n        ChunkStreamer.call(this, config);\n        this._nextChunk = function() {\n            if (writeStreamHasFinished && parseCallbackQueue.length === 1) {\n                this._finished = true;\n            }\n            if (parseCallbackQueue.length) {\n                parseCallbackQueue.shift()();\n            } else {\n                parseOnWrite = true;\n            }\n        };\n        this._addToParseQueue = function(chunk, callback) {\n            // add to queue so that we can indicate\n            // completion via callback\n            // node will automatically pause the incoming stream\n            // when too many items have been added without their\n            // callback being invoked\n            parseCallbackQueue.push(bindFunction(function() {\n                this.parseChunk(typeof chunk === \"string\" ? chunk : chunk.toString(config.encoding));\n                if (isFunction(callback)) {\n                    return callback();\n                }\n            }, this));\n            if (parseOnWrite) {\n                parseOnWrite = false;\n                this._nextChunk();\n            }\n        };\n        this._onRead = function() {\n            if (this._handle.paused()) {\n                // the writeable consumer can handle more data\n                // so resume the chunk parsing\n                this._handle.resume();\n            }\n        };\n        this._onWrite = function(chunk, encoding, callback) {\n            this._addToParseQueue(chunk, callback);\n        };\n        this._onWriteComplete = function() {\n            writeStreamHasFinished = true;\n            // have to write empty string\n            // so parser knows its done\n            this._addToParseQueue(\"\");\n        };\n        this.getStream = function() {\n            return stream;\n        };\n        stream = new Duplex({\n            readableObjectMode: true,\n            decodeStrings: false,\n            read: bindFunction(this._onRead, this),\n            write: bindFunction(this._onWrite, this)\n        });\n        stream.once(\"finish\", bindFunction(this._onWriteComplete, this));\n    }\n    if (typeof PAPA_BROWSER_CONTEXT === \"undefined\") {\n        DuplexStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n        DuplexStreamStreamer.prototype.constructor = DuplexStreamStreamer;\n    }\n    // Use one ParserHandle per entire CSV file or string\n    function ParserHandle(_config) {\n        // One goal is to minimize the use of regular expressions...\n        var MAX_FLOAT = Math.pow(2, 53);\n        var MIN_FLOAT = -MAX_FLOAT;\n        var FLOAT = /^\\s*-?(\\d+\\.?|\\.\\d+|\\d+\\.\\d+)([eE][-+]?\\d+)?\\s*$/;\n        var ISO_DATE = /^((\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z)))$/;\n        var self1 = this;\n        var _stepCounter = 0; // Number of times step was called (number of rows parsed)\n        var _rowCounter = 0; // Number of rows that have been parsed so far\n        var _input; // The input being parsed\n        var _parser; // The core parser being used\n        var _paused = false; // Whether we are paused or not\n        var _aborted = false; // Whether the parser has aborted or not\n        var _delimiterError; // Temporary state between delimiter detection and processing results\n        var _fields = []; // Fields are from the header row of the input, if there is one\n        var _results = {\n            data: [],\n            errors: [],\n            meta: {}\n        };\n        if (isFunction(_config.step)) {\n            var userStep = _config.step;\n            _config.step = function(results) {\n                _results = results;\n                if (needsHeaderRow()) processResults();\n                else {\n                    processResults();\n                    // It's possbile that this line was empty and there's no row here after all\n                    if (_results.data.length === 0) return;\n                    _stepCounter += results.data.length;\n                    if (_config.preview && _stepCounter > _config.preview) _parser.abort();\n                    else {\n                        _results.data = _results.data[0];\n                        userStep(_results, self1);\n                    }\n                }\n            };\n        }\n        /**\n\t\t * Parses input. Most users won't need, and shouldn't mess with, the baseIndex\n\t\t * and ignoreLastRow parameters. They are used by streamers (wrapper functions)\n\t\t * when an input comes in multiple chunks, like from a file.\n\t\t */ this.parse = function(input, baseIndex, ignoreLastRow) {\n            var quoteChar = _config.quoteChar || '\"';\n            if (!_config.newline) _config.newline = this.guessLineEndings(input, quoteChar);\n            _delimiterError = false;\n            if (!_config.delimiter) {\n                var delimGuess = guessDelimiter(input, _config.newline, _config.skipEmptyLines, _config.comments, _config.delimitersToGuess);\n                if (delimGuess.successful) _config.delimiter = delimGuess.bestDelimiter;\n                else {\n                    _delimiterError = true; // add error after parsing (otherwise it would be overwritten)\n                    _config.delimiter = Papa.DefaultDelimiter;\n                }\n                _results.meta.delimiter = _config.delimiter;\n            } else if (isFunction(_config.delimiter)) {\n                _config.delimiter = _config.delimiter(input);\n                _results.meta.delimiter = _config.delimiter;\n            }\n            var parserConfig = copy(_config);\n            if (_config.preview && _config.header) parserConfig.preview++; // to compensate for header row\n            _input = input;\n            _parser = new Parser(parserConfig);\n            _results = _parser.parse(_input, baseIndex, ignoreLastRow);\n            processResults();\n            return _paused ? {\n                meta: {\n                    paused: true\n                }\n            } : _results || {\n                meta: {\n                    paused: false\n                }\n            };\n        };\n        this.paused = function() {\n            return _paused;\n        };\n        this.pause = function() {\n            _paused = true;\n            _parser.abort();\n            // If it is streaming via \"chunking\", the reader will start appending correctly already so no need to substring,\n            // otherwise we can get duplicate content within a row\n            _input = isFunction(_config.chunk) ? \"\" : _input.substring(_parser.getCharIndex());\n        };\n        this.resume = function() {\n            if (self1.streamer._halted) {\n                _paused = false;\n                self1.streamer.parseChunk(_input, true);\n            } else {\n                // Bugfix: #636 In case the processing hasn't halted yet\n                // wait for it to halt in order to resume\n                setTimeout(self1.resume, 3);\n            }\n        };\n        this.aborted = function() {\n            return _aborted;\n        };\n        this.abort = function() {\n            _aborted = true;\n            _parser.abort();\n            _results.meta.aborted = true;\n            if (isFunction(_config.complete)) _config.complete(_results);\n            _input = \"\";\n        };\n        this.guessLineEndings = function(input, quoteChar) {\n            input = input.substring(0, 1024 * 1024); // max length 1 MB\n            // Replace all the text inside quotes\n            var re = new RegExp(escapeRegExp(quoteChar) + \"([^]*?)\" + escapeRegExp(quoteChar), \"gm\");\n            input = input.replace(re, \"\");\n            var r = input.split(\"\\r\");\n            var n = input.split(\"\\n\");\n            var nAppearsFirst = n.length > 1 && n[0].length < r[0].length;\n            if (r.length === 1 || nAppearsFirst) return \"\\n\";\n            var numWithN = 0;\n            for(var i = 0; i < r.length; i++){\n                if (r[i][0] === \"\\n\") numWithN++;\n            }\n            return numWithN >= r.length / 2 ? \"\\r\\n\" : \"\\r\";\n        };\n        function testEmptyLine(s) {\n            return _config.skipEmptyLines === \"greedy\" ? s.join(\"\").trim() === \"\" : s.length === 1 && s[0].length === 0;\n        }\n        function testFloat(s) {\n            if (FLOAT.test(s)) {\n                var floatValue = parseFloat(s);\n                if (floatValue > MIN_FLOAT && floatValue < MAX_FLOAT) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function processResults() {\n            if (_results && _delimiterError) {\n                addError(\"Delimiter\", \"UndetectableDelimiter\", \"Unable to auto-detect delimiting character; defaulted to '\" + Papa.DefaultDelimiter + \"'\");\n                _delimiterError = false;\n            }\n            if (_config.skipEmptyLines) {\n                _results.data = _results.data.filter(function(d) {\n                    return !testEmptyLine(d);\n                });\n            }\n            if (needsHeaderRow()) fillHeaderFields();\n            return applyHeaderAndDynamicTypingAndTransformation();\n        }\n        function needsHeaderRow() {\n            return _config.header && _fields.length === 0;\n        }\n        function fillHeaderFields() {\n            if (!_results) return;\n            function addHeader(header, i) {\n                if (isFunction(_config.transformHeader)) header = _config.transformHeader(header, i);\n                _fields.push(header);\n            }\n            if (Array.isArray(_results.data[0])) {\n                for(var i = 0; needsHeaderRow() && i < _results.data.length; i++)_results.data[i].forEach(addHeader);\n                _results.data.splice(0, 1);\n            } else _results.data.forEach(addHeader);\n        }\n        function shouldApplyDynamicTyping(field) {\n            // Cache function values to avoid calling it for each row\n            if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {\n                _config.dynamicTyping[field] = _config.dynamicTypingFunction(field);\n            }\n            return (_config.dynamicTyping[field] || _config.dynamicTyping) === true;\n        }\n        function parseDynamic(field, value) {\n            if (shouldApplyDynamicTyping(field)) {\n                if (value === \"true\" || value === \"TRUE\") return true;\n                else if (value === \"false\" || value === \"FALSE\") return false;\n                else if (testFloat(value)) return parseFloat(value);\n                else if (ISO_DATE.test(value)) return new Date(value);\n                else return value === \"\" ? null : value;\n            }\n            return value;\n        }\n        function applyHeaderAndDynamicTypingAndTransformation() {\n            if (!_results || !_config.header && !_config.dynamicTyping && !_config.transform) return _results;\n            function processRow(rowSource, i) {\n                var row = _config.header ? {} : [];\n                var j;\n                for(j = 0; j < rowSource.length; j++){\n                    var field = j;\n                    var value = rowSource[j];\n                    if (_config.header) field = j >= _fields.length ? \"__parsed_extra\" : _fields[j];\n                    if (_config.transform) value = _config.transform(value, field);\n                    value = parseDynamic(field, value);\n                    if (field === \"__parsed_extra\") {\n                        row[field] = row[field] || [];\n                        row[field].push(value);\n                    } else row[field] = value;\n                }\n                if (_config.header) {\n                    if (j > _fields.length) addError(\"FieldMismatch\", \"TooManyFields\", \"Too many fields: expected \" + _fields.length + \" fields but parsed \" + j, _rowCounter + i);\n                    else if (j < _fields.length) addError(\"FieldMismatch\", \"TooFewFields\", \"Too few fields: expected \" + _fields.length + \" fields but parsed \" + j, _rowCounter + i);\n                }\n                return row;\n            }\n            var incrementBy = 1;\n            if (!_results.data.length || Array.isArray(_results.data[0])) {\n                _results.data = _results.data.map(processRow);\n                incrementBy = _results.data.length;\n            } else _results.data = processRow(_results.data, 0);\n            if (_config.header && _results.meta) _results.meta.fields = _fields;\n            _rowCounter += incrementBy;\n            return _results;\n        }\n        function guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {\n            var bestDelim, bestDelta, fieldCountPrevRow, maxFieldCount;\n            delimitersToGuess = delimitersToGuess || [\n                \",\",\n                \"\t\",\n                \"|\",\n                \";\",\n                Papa.RECORD_SEP,\n                Papa.UNIT_SEP\n            ];\n            for(var i = 0; i < delimitersToGuess.length; i++){\n                var delim = delimitersToGuess[i];\n                var delta = 0, avgFieldCount = 0, emptyLinesCount = 0;\n                fieldCountPrevRow = undefined;\n                var preview = new Parser({\n                    comments: comments,\n                    delimiter: delim,\n                    newline: newline,\n                    preview: 10\n                }).parse(input);\n                for(var j = 0; j < preview.data.length; j++){\n                    if (skipEmptyLines && testEmptyLine(preview.data[j])) {\n                        emptyLinesCount++;\n                        continue;\n                    }\n                    var fieldCount = preview.data[j].length;\n                    avgFieldCount += fieldCount;\n                    if (typeof fieldCountPrevRow === \"undefined\") {\n                        fieldCountPrevRow = fieldCount;\n                        continue;\n                    } else if (fieldCount > 0) {\n                        delta += Math.abs(fieldCount - fieldCountPrevRow);\n                        fieldCountPrevRow = fieldCount;\n                    }\n                }\n                if (preview.data.length > 0) avgFieldCount /= preview.data.length - emptyLinesCount;\n                if ((typeof bestDelta === \"undefined\" || delta <= bestDelta) && (typeof maxFieldCount === \"undefined\" || avgFieldCount > maxFieldCount) && avgFieldCount > 1.99) {\n                    bestDelta = delta;\n                    bestDelim = delim;\n                    maxFieldCount = avgFieldCount;\n                }\n            }\n            _config.delimiter = bestDelim;\n            return {\n                successful: !!bestDelim,\n                bestDelimiter: bestDelim\n            };\n        }\n        function addError(type, code, msg, row) {\n            var error = {\n                type: type,\n                code: code,\n                message: msg\n            };\n            if (row !== undefined) {\n                error.row = row;\n            }\n            _results.errors.push(error);\n        }\n    }\n    /** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */ function escapeRegExp(string) {\n        return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n    }\n    /** The core parser implements speedy and correct CSV parsing */ function Parser(config) {\n        // Unpack the config object\n        config = config || {};\n        var delim = config.delimiter;\n        var newline = config.newline;\n        var comments = config.comments;\n        var step = config.step;\n        var preview = config.preview;\n        var fastMode = config.fastMode;\n        var quoteChar;\n        var renamedHeaders = null;\n        var headerParsed = false;\n        if (config.quoteChar === undefined || config.quoteChar === null) {\n            quoteChar = '\"';\n        } else {\n            quoteChar = config.quoteChar;\n        }\n        var escapeChar = quoteChar;\n        if (config.escapeChar !== undefined) {\n            escapeChar = config.escapeChar;\n        }\n        // Delimiter must be valid\n        if (typeof delim !== \"string\" || Papa.BAD_DELIMITERS.indexOf(delim) > -1) delim = \",\";\n        // Comment character must be valid\n        if (comments === delim) throw new Error(\"Comment character same as delimiter\");\n        else if (comments === true) comments = \"#\";\n        else if (typeof comments !== \"string\" || Papa.BAD_DELIMITERS.indexOf(comments) > -1) comments = false;\n        // Newline must be valid: \\r, \\n, or \\r\\n\n        if (newline !== \"\\n\" && newline !== \"\\r\" && newline !== \"\\r\\n\") newline = \"\\n\";\n        // We're gonna need these at the Parser scope\n        var cursor = 0;\n        var aborted = false;\n        this.parse = function(input, baseIndex, ignoreLastRow) {\n            // For some reason, in Chrome, this speeds things up (!?)\n            if (typeof input !== \"string\") throw new Error(\"Input must be a string\");\n            // We don't need to compute some of these every time parse() is called,\n            // but having them in a more local scope seems to perform better\n            var inputLen = input.length, delimLen = delim.length, newlineLen = newline.length, commentsLen = comments.length;\n            var stepIsFunction = isFunction(step);\n            // Establish starting state\n            cursor = 0;\n            var data = [], errors = [], row = [], lastCursor = 0;\n            if (!input) return returnable();\n            if (fastMode || fastMode !== false && input.indexOf(quoteChar) === -1) {\n                var rows = input.split(newline);\n                for(var i = 0; i < rows.length; i++){\n                    row = rows[i];\n                    cursor += row.length;\n                    if (i !== rows.length - 1) cursor += newline.length;\n                    else if (ignoreLastRow) return returnable();\n                    if (comments && row.substring(0, commentsLen) === comments) continue;\n                    if (stepIsFunction) {\n                        data = [];\n                        pushRow(row.split(delim));\n                        doStep();\n                        if (aborted) return returnable();\n                    } else pushRow(row.split(delim));\n                    if (preview && i >= preview) {\n                        data = data.slice(0, preview);\n                        return returnable(true);\n                    }\n                }\n                return returnable();\n            }\n            var nextDelim = input.indexOf(delim, cursor);\n            var nextNewline = input.indexOf(newline, cursor);\n            var quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), \"g\");\n            var quoteSearch = input.indexOf(quoteChar, cursor);\n            // Parser loop\n            for(;;){\n                // Field has opening quote\n                if (input[cursor] === quoteChar) {\n                    // Start our search for the closing quote where the cursor is\n                    quoteSearch = cursor;\n                    // Skip the opening quote\n                    cursor++;\n                    for(;;){\n                        // Find closing quote\n                        quoteSearch = input.indexOf(quoteChar, quoteSearch + 1);\n                        //No other quotes are found - no other delimiters\n                        if (quoteSearch === -1) {\n                            if (!ignoreLastRow) {\n                                // No closing quote... what a pity\n                                errors.push({\n                                    type: \"Quotes\",\n                                    code: \"MissingQuotes\",\n                                    message: \"Quoted field unterminated\",\n                                    row: data.length,\n                                    index: cursor\n                                });\n                            }\n                            return finish();\n                        }\n                        // Closing quote at EOF\n                        if (quoteSearch === inputLen - 1) {\n                            var value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);\n                            return finish(value);\n                        }\n                        // If this quote is escaped, it's part of the data; skip it\n                        // If the quote character is the escape character, then check if the next character is the escape character\n                        if (quoteChar === escapeChar && input[quoteSearch + 1] === escapeChar) {\n                            quoteSearch++;\n                            continue;\n                        }\n                        // If the quote character is not the escape character, then check if the previous character was the escape character\n                        if (quoteChar !== escapeChar && quoteSearch !== 0 && input[quoteSearch - 1] === escapeChar) {\n                            continue;\n                        }\n                        if (nextDelim !== -1 && nextDelim < quoteSearch + 1) {\n                            nextDelim = input.indexOf(delim, quoteSearch + 1);\n                        }\n                        if (nextNewline !== -1 && nextNewline < quoteSearch + 1) {\n                            nextNewline = input.indexOf(newline, quoteSearch + 1);\n                        }\n                        // Check up to nextDelim or nextNewline, whichever is closest\n                        var checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);\n                        var spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);\n                        // Closing quote followed by delimiter or 'unnecessary spaces + delimiter'\n                        if (input.substr(quoteSearch + 1 + spacesBetweenQuoteAndDelimiter, delimLen) === delim) {\n                            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n                            cursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;\n                            // If char after following delimiter is not quoteChar, we find next quote char position\n                            if (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen] !== quoteChar) {\n                                quoteSearch = input.indexOf(quoteChar, cursor);\n                            }\n                            nextDelim = input.indexOf(delim, cursor);\n                            nextNewline = input.indexOf(newline, cursor);\n                            break;\n                        }\n                        var spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);\n                        // Closing quote followed by newline or 'unnecessary spaces + newLine'\n                        if (input.substring(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen) === newline) {\n                            row.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n                            saveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);\n                            nextDelim = input.indexOf(delim, cursor); // because we may have skipped the nextDelim in the quoted field\n                            quoteSearch = input.indexOf(quoteChar, cursor); // we search for first quote in next line\n                            if (stepIsFunction) {\n                                doStep();\n                                if (aborted) return returnable();\n                            }\n                            if (preview && data.length >= preview) return returnable(true);\n                            break;\n                        }\n                        // Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string\n                        errors.push({\n                            type: \"Quotes\",\n                            code: \"InvalidQuotes\",\n                            message: \"Trailing quote on quoted field is malformed\",\n                            row: data.length,\n                            index: cursor\n                        });\n                        quoteSearch++;\n                        continue;\n                    }\n                    continue;\n                }\n                // Comment found at start of new line\n                if (comments && row.length === 0 && input.substring(cursor, cursor + commentsLen) === comments) {\n                    if (nextNewline === -1) return returnable();\n                    cursor = nextNewline + newlineLen;\n                    nextNewline = input.indexOf(newline, cursor);\n                    nextDelim = input.indexOf(delim, cursor);\n                    continue;\n                }\n                // Next delimiter comes before next newline, so we've reached end of field\n                if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {\n                    row.push(input.substring(cursor, nextDelim));\n                    cursor = nextDelim + delimLen;\n                    // we look for next delimiter char\n                    nextDelim = input.indexOf(delim, cursor);\n                    continue;\n                }\n                // End of row\n                if (nextNewline !== -1) {\n                    row.push(input.substring(cursor, nextNewline));\n                    saveRow(nextNewline + newlineLen);\n                    if (stepIsFunction) {\n                        doStep();\n                        if (aborted) return returnable();\n                    }\n                    if (preview && data.length >= preview) return returnable(true);\n                    continue;\n                }\n                break;\n            }\n            return finish();\n            function pushRow(row) {\n                data.push(row);\n                lastCursor = cursor;\n            }\n            /**\n             * checks if there are extra spaces after closing quote and given index without any text\n             * if Yes, returns the number of spaces\n             */ function extraSpaces(index) {\n                var spaceLength = 0;\n                if (index !== -1) {\n                    var textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);\n                    if (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === \"\") {\n                        spaceLength = textBetweenClosingQuoteAndIndex.length;\n                    }\n                }\n                return spaceLength;\n            }\n            /**\n\t\t\t * Appends the remaining input from cursor to the end into\n\t\t\t * row, saves the row, calls step, and returns the results.\n\t\t\t */ function finish(value) {\n                if (ignoreLastRow) return returnable();\n                if (typeof value === \"undefined\") value = input.substring(cursor);\n                row.push(value);\n                cursor = inputLen; // important in case parsing is paused\n                pushRow(row);\n                if (stepIsFunction) doStep();\n                return returnable();\n            }\n            /**\n\t\t\t * Appends the current row to the results. It sets the cursor\n\t\t\t * to newCursor and finds the nextNewline. The caller should\n\t\t\t * take care to execute user's step function and check for\n\t\t\t * preview and end parsing if necessary.\n\t\t\t */ function saveRow(newCursor) {\n                cursor = newCursor;\n                pushRow(row);\n                row = [];\n                nextNewline = input.indexOf(newline, cursor);\n            }\n            /** Returns an object with the results, errors, and meta. */ function returnable(stopped) {\n                if (config.header && !baseIndex && data.length && !headerParsed) {\n                    const result = data[0];\n                    const headerCount = Object.create(null); // To track the count of each base header\n                    const usedHeaders = new Set(result); // To track used headers and avoid duplicates\n                    let duplicateHeaders = false;\n                    for(let i = 0; i < result.length; i++){\n                        let header = result[i];\n                        if (isFunction(config.transformHeader)) header = config.transformHeader(header, i);\n                        if (!headerCount[header]) {\n                            headerCount[header] = 1;\n                            result[i] = header;\n                        } else {\n                            let newHeader;\n                            let suffixCount = headerCount[header];\n                            // Find a unique new header\n                            do {\n                                newHeader = `${header}_${suffixCount}`;\n                                suffixCount++;\n                            }while (usedHeaders.has(newHeader));\n                            usedHeaders.add(newHeader); // Mark this new Header as used\n                            result[i] = newHeader;\n                            headerCount[header]++;\n                            duplicateHeaders = true;\n                            if (renamedHeaders === null) {\n                                renamedHeaders = {};\n                            }\n                            renamedHeaders[newHeader] = header;\n                        }\n                        usedHeaders.add(header); // Ensure the original header is marked as used\n                    }\n                    if (duplicateHeaders) {\n                        console.warn(\"Duplicate headers found and renamed.\");\n                    }\n                    headerParsed = true;\n                }\n                return {\n                    data: data,\n                    errors: errors,\n                    meta: {\n                        delimiter: delim,\n                        linebreak: newline,\n                        aborted: aborted,\n                        truncated: !!stopped,\n                        cursor: lastCursor + (baseIndex || 0),\n                        renamedHeaders: renamedHeaders\n                    }\n                };\n            }\n            /** Executes the user's step function and resets data & errors. */ function doStep() {\n                step(returnable());\n                data = [];\n                errors = [];\n            }\n        };\n        /** Sets the abort flag */ this.abort = function() {\n            aborted = true;\n        };\n        /** Gets the cursor position */ this.getCharIndex = function() {\n            return cursor;\n        };\n    }\n    function newWorker() {\n        if (!Papa.WORKERS_SUPPORTED) return false;\n        var workerUrl = getWorkerBlob();\n        var w = new global.Worker(workerUrl);\n        w.onmessage = mainThreadReceivedMessage;\n        w.id = workerIdCounter++;\n        workers[w.id] = w;\n        return w;\n    }\n    /** Callback when main thread receives a message */ function mainThreadReceivedMessage(e) {\n        var msg = e.data;\n        var worker = workers[msg.workerId];\n        var aborted = false;\n        if (msg.error) worker.userError(msg.error, msg.file);\n        else if (msg.results && msg.results.data) {\n            var abort = function() {\n                aborted = true;\n                completeWorker(msg.workerId, {\n                    data: [],\n                    errors: [],\n                    meta: {\n                        aborted: true\n                    }\n                });\n            };\n            var handle = {\n                abort: abort,\n                pause: notImplemented,\n                resume: notImplemented\n            };\n            if (isFunction(worker.userStep)) {\n                for(var i = 0; i < msg.results.data.length; i++){\n                    worker.userStep({\n                        data: msg.results.data[i],\n                        errors: msg.results.errors,\n                        meta: msg.results.meta\n                    }, handle);\n                    if (aborted) break;\n                }\n                delete msg.results; // free memory ASAP\n            } else if (isFunction(worker.userChunk)) {\n                worker.userChunk(msg.results, handle, msg.file);\n                delete msg.results;\n            }\n        }\n        if (msg.finished && !aborted) completeWorker(msg.workerId, msg.results);\n    }\n    function completeWorker(workerId, results) {\n        var worker = workers[workerId];\n        if (isFunction(worker.userComplete)) worker.userComplete(results);\n        worker.terminate();\n        delete workers[workerId];\n    }\n    function notImplemented() {\n        throw new Error(\"Not implemented.\");\n    }\n    /** Callback when worker thread receives a message */ function workerThreadReceivedMessage(e) {\n        var msg = e.data;\n        if (typeof Papa.WORKER_ID === \"undefined\" && msg) Papa.WORKER_ID = msg.workerId;\n        if (typeof msg.input === \"string\") {\n            global.postMessage({\n                workerId: Papa.WORKER_ID,\n                results: Papa.parse(msg.input, msg.config),\n                finished: true\n            });\n        } else if (global.File && msg.input instanceof File || msg.input instanceof Object) {\n            var results = Papa.parse(msg.input, msg.config);\n            if (results) global.postMessage({\n                workerId: Papa.WORKER_ID,\n                results: results,\n                finished: true\n            });\n        }\n    }\n    /** Makes a deep copy of an array or object (mostly) */ function copy(obj) {\n        if (typeof obj !== \"object\" || obj === null) return obj;\n        var cpy = Array.isArray(obj) ? [] : {};\n        for(var key in obj)cpy[key] = copy(obj[key]);\n        return cpy;\n    }\n    function bindFunction(f, self1) {\n        return function() {\n            f.apply(self1, arguments);\n        };\n    }\n    function isFunction(func) {\n        return typeof func === \"function\";\n    }\n    return Papa;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGFwYXBhcnNlL3BhcGFwYXJzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7QUFLQSxHQUVDLFVBQVNBLElBQUksRUFBRUMsT0FBTztJQUV0QixrQkFBa0IsR0FDbEIsSUFBSSxJQUEwQyxFQUM5QztRQUNDLHdDQUF3QztRQUN4Q0MsaUNBQU8sRUFBRSxvQ0FBRUQsT0FBT0E7QUFBQTtBQUFBO0FBQUEsa0dBQUNBO0lBQ3BCLE9BQ0ssRUFXSjtBQUNELG9GQUFvRjtBQUNwRixtREFBbUQ7QUFDbkQscUNBQXFDO0FBQ3RDLEdBQUUsSUFBSSxFQUFFLFNBQVNNO0lBRWhCO0lBRUEsSUFBSUMsU0FBUztRQUNaLDZEQUE2RDtRQUM3RCxtREFBbUQ7UUFDbkQsa0NBQWtDO1FBRWxDLElBQUksT0FBT0MsU0FBUyxhQUFhO1lBQUUsT0FBT0E7UUFBTTtRQUNoRCxJQUFJLEtBQWtCLEVBQWEsRUFBa0I7UUFDckQsSUFBSSxPQUFPRCxXQUFXLGFBQWE7WUFBRSxPQUFPQTtRQUFRO1FBRXBELHlEQUF5RDtRQUN6RCxPQUFPLENBQUM7SUFDVDtJQUdBLFNBQVNHO1FBQ1IsSUFBSUMsTUFBTUosT0FBT0ksR0FBRyxJQUFJSixPQUFPSyxTQUFTLElBQUk7UUFDNUMsSUFBSUMsT0FBT1AsY0FBY1EsUUFBUTtRQUNqQyxPQUFPVCxLQUFLVSxRQUFRLElBQUtWLENBQUFBLEtBQUtVLFFBQVEsR0FBR0osSUFBSUssZUFBZSxDQUFDLElBQUlDLEtBQUs7WUFBQztZQUEwTztZQUFLSjtZQUFNO1NBQU8sRUFBRTtZQUFDSyxNQUFNO1FBQWlCLEdBQUU7SUFDaFc7SUFFQSxJQUFJQyxZQUFZLENBQUNaLE9BQU9hLFFBQVEsSUFBSSxDQUFDLENBQUNiLE9BQU9jLFdBQVcsRUFDdkRDLGlCQUFpQmYsT0FBT2UsY0FBYyxJQUFJO0lBRTNDLElBQUlDLFVBQVUsQ0FBQyxHQUFHQyxrQkFBa0I7SUFFcEMsSUFBSW5CLE9BQU8sQ0FBQztJQUVaQSxLQUFLb0Is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TUMsT0FBTyxDQUFDK1EsT0FBTyxFQUFFLEdBQUcsQ0FBQztRQUNyQyxJQUFLLElBQUlFLE9BQU9GLElBQ2ZDLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHOUwsS0FBSzRMLEdBQUcsQ0FBQ0UsSUFBSTtRQUN6QixPQUFPRDtJQUNSO0lBRUEsU0FBU3BMLGFBQWF2SixDQUFDLEVBQUVsRSxLQUFJO1FBRTVCLE9BQU87WUFBYWtFLEVBQUVtTSxLQUFLLENBQUNyUSxPQUFNc1E7UUFBWTtJQUMvQztJQUNBLFNBQVN0TSxXQUFXK1UsSUFBSTtRQUV2QixPQUFPLE9BQU9BLFNBQVM7SUFDeEI7SUFFQSxPQUFPbFo7QUFDUiIsInNvdXJjZXMiOlsid2VicGFjazovL2RpZ2l0YWx5ei1kYXRhLWFsY2hlbWlzdC8uL25vZGVfbW9kdWxlcy9wYXBhcGFyc2UvcGFwYXBhcnNlLmpzPzliZjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogQGxpY2Vuc2VcblBhcGEgUGFyc2VcbnY1LjUuM1xuaHR0cHM6Ly9naXRodWIuY29tL21ob2x0L1BhcGFQYXJzZVxuTGljZW5zZTogTUlUXG4qL1xuXG4oZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSlcbntcblx0LyogZ2xvYmFscyBkZWZpbmUgKi9cblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0e1xuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJylcblx0e1xuXHRcdC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuXHRcdC8vIG9ubHkgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuXHRcdC8vIGxpa2UgTm9kZS5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0fVxuXHRlbHNlXG5cdHtcblx0XHQvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuXHRcdHJvb3QuUGFwYSA9IGZhY3RvcnkoKTtcblx0fVxuXHQvLyBpbiBzdHJpY3QgbW9kZSB3ZSBjYW5ub3QgYWNjZXNzIGFyZ3VtZW50cy5jYWxsZWUsIHNvIHdlIG5lZWQgYSBuYW1lZCByZWZlcmVuY2UgdG9cblx0Ly8gc3RyaW5naWZ5IHRoZSBmYWN0b3J5IG1ldGhvZCBmb3IgdGhlIGJsb2Igd29ya2VyXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVcbn0odGhpcywgZnVuY3Rpb24gbW9kdWxlRmFjdG9yeSgpXG57XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgZ2xvYmFsID0gKGZ1bmN0aW9uKCkge1xuXHRcdC8vIGFsdGVybmF0aXZlIG1ldGhvZCwgc2ltaWxhciB0byBgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKWBcblx0XHQvLyBidXQgd2l0aG91dCB1c2luZyBgZXZhbGAgKHdoaWNoIGlzIGRpc2FibGVkIHdoZW5cblx0XHQvLyB1c2luZyBDb250ZW50IFNlY3VyaXR5IFBvbGljeSkuXG5cblx0XHRpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBzZWxmOyB9XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiB3aW5kb3c7IH1cblx0XHRpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGdsb2JhbDsgfVxuXG5cdFx0Ly8gV2hlbiBydW5uaW5nIHRlc3RzIG5vbmUgb2YgdGhlIGFib3ZlIGhhdmUgYmVlbiBkZWZpbmVkXG5cdFx0cmV0dXJuIHt9O1xuXHR9KSgpO1xuXG5cblx0ZnVuY3Rpb24gZ2V0V29ya2VyQmxvYigpIHtcblx0XHR2YXIgVVJMID0gZ2xvYmFsLlVSTCB8fCBnbG9iYWwud2Via2l0VVJMIHx8IG51bGw7XG5cdFx0dmFyIGNvZGUgPSBtb2R1bGVGYWN0b3J5LnRvU3RyaW5nKCk7XG5cdFx0cmV0dXJuIFBhcGEuQkxPQl9VUkwgfHwgKFBhcGEuQkxPQl9VUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtcInZhciBnbG9iYWwgPSAoZnVuY3Rpb24oKSB7IGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHNlbGY7IH0gaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiB3aW5kb3c7IH0gaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBnbG9iYWw7IH0gcmV0dXJuIHt9OyB9KSgpOyBnbG9iYWwuSVNfUEFQQV9XT1JLRVI9dHJ1ZTsgXCIsICcoJywgY29kZSwgJykoKTsnXSwge3R5cGU6ICd0ZXh0L2phdmFzY3JpcHQnfSkpKTtcblx0fVxuXG5cdHZhciBJU19XT1JLRVIgPSAhZ2xvYmFsLmRvY3VtZW50ICYmICEhZ2xvYmFsLnBvc3RNZXNzYWdlLFxuXHRcdElTX1BBUEFfV09SS0VSID0gZ2xvYmFsLklTX1BBUEFfV09SS0VSIHx8IGZhbHNlO1xuXG5cdHZhciB3b3JrZXJzID0ge30sIHdvcmtlcklkQ291bnRlciA9IDA7XG5cblx0dmFyIFBhcGEgPSB7fTtcblxuXHRQYXBhLnBhcnNlID0gQ3N2VG9Kc29uO1xuXHRQYXBhLnVucGFyc2UgPSBKc29uVG9Dc3Y7XG5cblx0UGFwYS5SRUNPUkRfU0VQID0gU3RyaW5nLmZyb21DaGFyQ29kZSgzMCk7XG5cdFBhcGEuVU5JVF9TRVAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMxKTtcblx0UGFwYS5CWVRFX09SREVSX01BUksgPSAnXFx1ZmVmZic7XG5cdFBhcGEuQkFEX0RFTElNSVRFUlMgPSBbJ1xccicsICdcXG4nLCAnXCInLCBQYXBhLkJZVEVfT1JERVJfTUFSS107XG5cdFBhcGEuV09SS0VSU19TVVBQT1JURUQgPSAhSVNfV09SS0VSICYmICEhZ2xvYmFsLldvcmtlcjtcblx0UGFwYS5OT0RFX1NUUkVBTV9JTlBVVCA9IDE7XG5cblx0Ly8gQ29uZmlndXJhYmxlIGNodW5rIHNpemVzIGZvciBsb2NhbCBhbmQgcmVtb3RlIGZpbGVzLCByZXNwZWN0aXZlbHlcblx0UGFwYS5Mb2NhbENodW5rU2l6ZSA9IDEwMjQgKiAxMDI0ICogMTA7XHQvLyAxMCBNQlxuXHRQYXBhLlJlbW90ZUNodW5rU2l6ZSA9IDEwMjQgKiAxMDI0ICogNTtcdC8vIDUgTUJcblx0UGFwYS5EZWZhdWx0RGVsaW1pdGVyID0gJywnO1x0XHRcdC8vIFVzZWQgaWYgbm90IHNwZWNpZmllZCBhbmQgZGV0ZWN0aW9uIGZhaWxzXG5cblx0Ly8gRXhwb3NlZCBmb3IgdGVzdGluZyBhbmQgZGV2ZWxvcG1lbnQgb25seVxuXHRQYXBhLlBhcnNlciA9IFBhcnNlcjtcblx0UGFwYS5QYXJzZXJIYW5kbGUgPSBQYXJzZXJIYW5kbGU7XG5cdFBhcGEuTmV0d29ya1N0cmVhbWVyID0gTmV0d29ya1N0cmVhbWVyO1xuXHRQYXBhLkZpbGVTdHJlYW1lciA9IEZpbGVTdHJlYW1lcjtcblx0UGFwYS5TdHJpbmdTdHJlYW1lciA9IFN0cmluZ1N0cmVhbWVyO1xuXHRQYXBhLlJlYWRhYmxlU3RyZWFtU3RyZWFtZXIgPSBSZWFkYWJsZVN0cmVhbVN0cmVhbWVyO1xuXHRpZiAodHlwZW9mIFBBUEFfQlJPV1NFUl9DT05URVhUID09PSAndW5kZWZpbmVkJykge1xuXHRcdFBhcGEuRHVwbGV4U3RyZWFtU3RyZWFtZXIgPSBEdXBsZXhTdHJlYW1TdHJlYW1lcjtcblx0fVxuXG5cdGlmIChnbG9iYWwualF1ZXJ5KVxuXHR7XG5cdFx0dmFyICQgPSBnbG9iYWwualF1ZXJ5O1xuXHRcdCQuZm4ucGFyc2UgPSBmdW5jdGlvbihvcHRpb25zKVxuXHRcdHtcblx0XHRcdHZhciBjb25maWcgPSBvcHRpb25zLmNvbmZpZyB8fCB7fTtcblx0XHRcdHZhciBxdWV1ZSA9IFtdO1xuXG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oaWR4KVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgc3VwcG9ydGVkID0gJCh0aGlzKS5wcm9wKCd0YWdOYW1lJykudG9VcHBlckNhc2UoKSA9PT0gJ0lOUFVUJ1xuXHRcdFx0XHRcdFx0XHRcdCYmICQodGhpcykuYXR0cigndHlwZScpLnRvTG93ZXJDYXNlKCkgPT09ICdmaWxlJ1xuXHRcdFx0XHRcdFx0XHRcdCYmIGdsb2JhbC5GaWxlUmVhZGVyO1xuXG5cdFx0XHRcdGlmICghc3VwcG9ydGVkIHx8ICF0aGlzLmZpbGVzIHx8IHRoaXMuZmlsZXMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1x0Ly8gY29udGludWUgdG8gbmV4dCBpbnB1dCBlbGVtZW50XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbGVzLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cXVldWUucHVzaCh7XG5cdFx0XHRcdFx0XHRmaWxlOiB0aGlzLmZpbGVzW2ldLFxuXHRcdFx0XHRcdFx0aW5wdXRFbGVtOiB0aGlzLFxuXHRcdFx0XHRcdFx0aW5zdGFuY2VDb25maWc6ICQuZXh0ZW5kKHt9LCBjb25maWcpXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRwYXJzZU5leHRGaWxlKCk7XHQvLyBiZWdpbiBwYXJzaW5nXG5cdFx0XHRyZXR1cm4gdGhpcztcdFx0Ly8gbWFpbnRhaW5zIGNoYWluYWJpbGl0eVxuXG5cblx0XHRcdGZ1bmN0aW9uIHBhcnNlTmV4dEZpbGUoKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAocXVldWUubGVuZ3RoID09PSAwKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGlzRnVuY3Rpb24ob3B0aW9ucy5jb21wbGV0ZSkpXG5cdFx0XHRcdFx0XHRvcHRpb25zLmNvbXBsZXRlKCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGYgPSBxdWV1ZVswXTtcblxuXHRcdFx0XHRpZiAoaXNGdW5jdGlvbihvcHRpb25zLmJlZm9yZSkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBvcHRpb25zLmJlZm9yZShmLmZpbGUsIGYuaW5wdXRFbGVtKTtcblxuXHRcdFx0XHRcdGlmICh0eXBlb2YgcmV0dXJuZWQgPT09ICdvYmplY3QnKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmIChyZXR1cm5lZC5hY3Rpb24gPT09ICdhYm9ydCcpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGVycm9yKCdBYm9ydEVycm9yJywgZi5maWxlLCBmLmlucHV0RWxlbSwgcmV0dXJuZWQucmVhc29uKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1x0Ly8gQWJvcnRzIGFsbCBxdWV1ZWQgZmlsZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKHJldHVybmVkLmFjdGlvbiA9PT0gJ3NraXAnKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRmaWxlQ29tcGxldGUoKTtcdC8vIHBhcnNlIHRoZSBuZXh0IGZpbGUgaW4gdGhlIHF1ZXVlLCBpZiBhbnlcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIHJldHVybmVkLmNvbmZpZyA9PT0gJ29iamVjdCcpXG5cdFx0XHRcdFx0XHRcdGYuaW5zdGFuY2VDb25maWcgPSAkLmV4dGVuZChmLmluc3RhbmNlQ29uZmlnLCByZXR1cm5lZC5jb25maWcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmIChyZXR1cm5lZCA9PT0gJ3NraXAnKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGZpbGVDb21wbGV0ZSgpO1x0Ly8gcGFyc2UgdGhlIG5leHQgZmlsZSBpbiB0aGUgcXVldWUsIGlmIGFueVxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdyYXAgdXAgdGhlIHVzZXIncyBjb21wbGV0ZSBjYWxsYmFjaywgaWYgYW55LCBzbyB0aGF0IG91cnMgYWxzbyBnZXRzIGV4ZWN1dGVkXG5cdFx0XHRcdHZhciB1c2VyQ29tcGxldGVGdW5jID0gZi5pbnN0YW5jZUNvbmZpZy5jb21wbGV0ZTtcblx0XHRcdFx0Zi5pbnN0YW5jZUNvbmZpZy5jb21wbGV0ZSA9IGZ1bmN0aW9uKHJlc3VsdHMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoaXNGdW5jdGlvbih1c2VyQ29tcGxldGVGdW5jKSlcblx0XHRcdFx0XHRcdHVzZXJDb21wbGV0ZUZ1bmMocmVzdWx0cywgZi5maWxlLCBmLmlucHV0RWxlbSk7XG5cdFx0XHRcdFx0ZmlsZUNvbXBsZXRlKCk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0UGFwYS5wYXJzZShmLmZpbGUsIGYuaW5zdGFuY2VDb25maWcpO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBlcnJvcihuYW1lLCBmaWxlLCBlbGVtLCByZWFzb24pXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMuZXJyb3IpKVxuXHRcdFx0XHRcdG9wdGlvbnMuZXJyb3Ioe25hbWU6IG5hbWV9LCBmaWxlLCBlbGVtLCByZWFzb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBmaWxlQ29tcGxldGUoKVxuXHRcdFx0e1xuXHRcdFx0XHRxdWV1ZS5zcGxpY2UoMCwgMSk7XG5cdFx0XHRcdHBhcnNlTmV4dEZpbGUoKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblxuXHRpZiAoSVNfUEFQQV9XT1JLRVIpXG5cdHtcblx0XHRnbG9iYWwub25tZXNzYWdlID0gd29ya2VyVGhyZWFkUmVjZWl2ZWRNZXNzYWdlO1xuXHR9XG5cblxuXG5cblx0ZnVuY3Rpb24gQ3N2VG9Kc29uKF9pbnB1dCwgX2NvbmZpZylcblx0e1xuXHRcdF9jb25maWcgPSBfY29uZmlnIHx8IHt9O1xuXHRcdHZhciBkeW5hbWljVHlwaW5nID0gX2NvbmZpZy5keW5hbWljVHlwaW5nIHx8IGZhbHNlO1xuXHRcdGlmIChpc0Z1bmN0aW9uKGR5bmFtaWNUeXBpbmcpKSB7XG5cdFx0XHRfY29uZmlnLmR5bmFtaWNUeXBpbmdGdW5jdGlvbiA9IGR5bmFtaWNUeXBpbmc7XG5cdFx0XHQvLyBXaWxsIGJlIGZpbGxlZCBvbiBmaXJzdCByb3cgY2FsbFxuXHRcdFx0ZHluYW1pY1R5cGluZyA9IHt9O1xuXHRcdH1cblx0XHRfY29uZmlnLmR5bmFtaWNUeXBpbmcgPSBkeW5hbWljVHlwaW5nO1xuXG5cdFx0X2NvbmZpZy50cmFuc2Zvcm0gPSBpc0Z1bmN0aW9uKF9jb25maWcudHJhbnNmb3JtKSA/IF9jb25maWcudHJhbnNmb3JtIDogZmFsc2U7XG5cblx0XHRpZiAoX2NvbmZpZy53b3JrZXIgJiYgUGFwYS5XT1JLRVJTX1NVUFBPUlRFRClcblx0XHR7XG5cdFx0XHR2YXIgdyA9IG5ld1dvcmtlcigpO1xuXG5cdFx0XHR3LnVzZXJTdGVwID0gX2NvbmZpZy5zdGVwO1xuXHRcdFx0dy51c2VyQ2h1bmsgPSBfY29uZmlnLmNodW5rO1xuXHRcdFx0dy51c2VyQ29tcGxldGUgPSBfY29uZmlnLmNvbXBsZXRlO1xuXHRcdFx0dy51c2VyRXJyb3IgPSBfY29uZmlnLmVycm9yO1xuXG5cdFx0XHRfY29uZmlnLnN0ZXAgPSBpc0Z1bmN0aW9uKF9jb25maWcuc3RlcCk7XG5cdFx0XHRfY29uZmlnLmNodW5rID0gaXNGdW5jdGlvbihfY29uZmlnLmNodW5rKTtcblx0XHRcdF9jb25maWcuY29tcGxldGUgPSBpc0Z1bmN0aW9uKF9jb25maWcuY29tcGxldGUpO1xuXHRcdFx0X2NvbmZpZy5lcnJvciA9IGlzRnVuY3Rpb24oX2NvbmZpZy5lcnJvcik7XG5cdFx0XHRkZWxldGUgX2NvbmZpZy53b3JrZXI7XHQvLyBwcmV2ZW50IGluZmluaXRlIGxvb3BcblxuXHRcdFx0dy5wb3N0TWVzc2FnZSh7XG5cdFx0XHRcdGlucHV0OiBfaW5wdXQsXG5cdFx0XHRcdGNvbmZpZzogX2NvbmZpZyxcblx0XHRcdFx0d29ya2VySWQ6IHcuaWRcblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHN0cmVhbWVyID0gbnVsbDtcblx0XHRpZiAoX2lucHV0ID09PSBQYXBhLk5PREVfU1RSRUFNX0lOUFVUICYmIHR5cGVvZiBQQVBBX0JST1dTRVJfQ09OVEVYVCA9PT0gJ3VuZGVmaW5lZCcpXG5cdFx0e1xuXHRcdFx0Ly8gY3JlYXRlIGEgbm9kZSBEdXBsZXggc3RyZWFtIGZvciB1c2Vcblx0XHRcdC8vIHdpdGggLnBpcGVcblx0XHRcdHN0cmVhbWVyID0gbmV3IER1cGxleFN0cmVhbVN0cmVhbWVyKF9jb25maWcpO1xuXHRcdFx0cmV0dXJuIHN0cmVhbWVyLmdldFN0cmVhbSgpO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlb2YgX2lucHV0ID09PSAnc3RyaW5nJylcblx0XHR7XG5cdFx0XHRfaW5wdXQgPSBzdHJpcEJvbShfaW5wdXQpO1xuXHRcdFx0aWYgKF9jb25maWcuZG93bmxvYWQpXG5cdFx0XHRcdHN0cmVhbWVyID0gbmV3IE5ldHdvcmtTdHJlYW1lcihfY29uZmlnKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0c3RyZWFtZXIgPSBuZXcgU3RyaW5nU3RyZWFtZXIoX2NvbmZpZyk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKF9pbnB1dC5yZWFkYWJsZSA9PT0gdHJ1ZSAmJiBpc0Z1bmN0aW9uKF9pbnB1dC5yZWFkKSAmJiBpc0Z1bmN0aW9uKF9pbnB1dC5vbikpXG5cdFx0e1xuXHRcdFx0c3RyZWFtZXIgPSBuZXcgUmVhZGFibGVTdHJlYW1TdHJlYW1lcihfY29uZmlnKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGdsb2JhbC5GaWxlICYmIF9pbnB1dCBpbnN0YW5jZW9mIEZpbGUpIHx8IF9pbnB1dCBpbnN0YW5jZW9mIE9iamVjdClcdC8vIC4uLlNhZmFyaS4gKHNlZSBpc3N1ZSAjMTA2KVxuXHRcdFx0c3RyZWFtZXIgPSBuZXcgRmlsZVN0cmVhbWVyKF9jb25maWcpO1xuXG5cdFx0cmV0dXJuIHN0cmVhbWVyLnN0cmVhbShfaW5wdXQpO1xuXG5cdFx0Ly8gU3RyaXAgY2hhcmFjdGVyIGZyb20gVVRGLTggQk9NIGVuY29kZWQgZmlsZXMgdGhhdCBjYXVzZSBpc3N1ZSBwYXJzaW5nIHRoZSBmaWxlXG5cdFx0ZnVuY3Rpb24gc3RyaXBCb20oc3RyaW5nKSB7XG5cdFx0XHRpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDB4ZmVmZikge1xuXHRcdFx0XHRyZXR1cm4gc3RyaW5nLnNsaWNlKDEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0cmluZztcblx0XHR9XG5cdH1cblxuXG5cblxuXG5cblx0ZnVuY3Rpb24gSnNvblRvQ3N2KF9pbnB1dCwgX2NvbmZpZylcblx0e1xuXHRcdC8vIERlZmF1bHQgY29uZmlndXJhdGlvblxuXG5cdFx0LyoqIHdoZXRoZXIgdG8gc3Vycm91bmQgZXZlcnkgZGF0dW0gd2l0aCBxdW90ZXMgKi9cblx0XHR2YXIgX3F1b3RlcyA9IGZhbHNlO1xuXG5cdFx0LyoqIHdoZXRoZXIgdG8gd3JpdGUgaGVhZGVycyAqL1xuXHRcdHZhciBfd3JpdGVIZWFkZXIgPSB0cnVlO1xuXG5cdFx0LyoqIGRlbGltaXRpbmcgY2hhcmFjdGVyKHMpICovXG5cdFx0dmFyIF9kZWxpbWl0ZXIgPSAnLCc7XG5cblx0XHQvKiogbmV3bGluZSBjaGFyYWN0ZXIocykgKi9cblx0XHR2YXIgX25ld2xpbmUgPSAnXFxyXFxuJztcblxuXHRcdC8qKiBxdW90ZSBjaGFyYWN0ZXIgKi9cblx0XHR2YXIgX3F1b3RlQ2hhciA9ICdcIic7XG5cblx0XHQvKiogZXNjYXBlZCBxdW90ZSBjaGFyYWN0ZXIsIGVpdGhlciBcIlwiIG9yIDxjb25maWcuZXNjYXBlQ2hhcj5cIiAqL1xuXHRcdHZhciBfZXNjYXBlZFF1b3RlID0gX3F1b3RlQ2hhciArIF9xdW90ZUNoYXI7XG5cblx0XHQvKiogd2hldGhlciB0byBza2lwIGVtcHR5IGxpbmVzICovXG5cdFx0dmFyIF9za2lwRW1wdHlMaW5lcyA9IGZhbHNlO1xuXG5cdFx0LyoqIHRoZSBjb2x1bW5zIChrZXlzKSB3ZSBleHBlY3Qgd2hlbiB3ZSB1bnBhcnNlIG9iamVjdHMgKi9cblx0XHR2YXIgX2NvbHVtbnMgPSBudWxsO1xuXG5cdFx0LyoqIHdoZXRoZXIgdG8gcHJldmVudCBvdXRwdXR0aW5nIGNlbGxzIHRoYXQgY2FuIGJlIHBhcnNlZCBhcyBmb3JtdWxhZSBieSBzcHJlYWRzaGVldCBzb2Z0d2FyZSAoRXhjZWwgYW5kIExpYnJlT2ZmaWNlKSAqL1xuXHRcdHZhciBfZXNjYXBlRm9ybXVsYWUgPSBmYWxzZTtcblxuXHRcdHVucGFja0NvbmZpZygpO1xuXG5cdFx0dmFyIHF1b3RlQ2hhclJlZ2V4ID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAoX3F1b3RlQ2hhciksICdnJyk7XG5cblx0XHRpZiAodHlwZW9mIF9pbnB1dCA9PT0gJ3N0cmluZycpXG5cdFx0XHRfaW5wdXQgPSBKU09OLnBhcnNlKF9pbnB1dCk7XG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheShfaW5wdXQpKVxuXHRcdHtcblx0XHRcdGlmICghX2lucHV0Lmxlbmd0aCB8fCBBcnJheS5pc0FycmF5KF9pbnB1dFswXSkpXG5cdFx0XHRcdHJldHVybiBzZXJpYWxpemUobnVsbCwgX2lucHV0LCBfc2tpcEVtcHR5TGluZXMpO1xuXHRcdFx0ZWxzZSBpZiAodHlwZW9mIF9pbnB1dFswXSA9PT0gJ29iamVjdCcpXG5cdFx0XHRcdHJldHVybiBzZXJpYWxpemUoX2NvbHVtbnMgfHwgT2JqZWN0LmtleXMoX2lucHV0WzBdKSwgX2lucHV0LCBfc2tpcEVtcHR5TGluZXMpO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlb2YgX2lucHV0ID09PSAnb2JqZWN0Jylcblx0XHR7XG5cdFx0XHRpZiAodHlwZW9mIF9pbnB1dC5kYXRhID09PSAnc3RyaW5nJylcblx0XHRcdFx0X2lucHV0LmRhdGEgPSBKU09OLnBhcnNlKF9pbnB1dC5kYXRhKTtcblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoX2lucHV0LmRhdGEpKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIV9pbnB1dC5maWVsZHMpXG5cdFx0XHRcdFx0X2lucHV0LmZpZWxkcyA9IF9pbnB1dC5tZXRhICYmIF9pbnB1dC5tZXRhLmZpZWxkcyB8fCBfY29sdW1ucztcblxuXHRcdFx0XHRpZiAoIV9pbnB1dC5maWVsZHMpXG5cdFx0XHRcdFx0X2lucHV0LmZpZWxkcyA9ICBBcnJheS5pc0FycmF5KF9pbnB1dC5kYXRhWzBdKVxuXHRcdFx0XHRcdFx0PyBfaW5wdXQuZmllbGRzXG5cdFx0XHRcdFx0XHQ6IHR5cGVvZiBfaW5wdXQuZGF0YVswXSA9PT0gJ29iamVjdCdcblx0XHRcdFx0XHRcdFx0PyBPYmplY3Qua2V5cyhfaW5wdXQuZGF0YVswXSlcblx0XHRcdFx0XHRcdFx0OiBbXTtcblxuXHRcdFx0XHRpZiAoIShBcnJheS5pc0FycmF5KF9pbnB1dC5kYXRhWzBdKSkgJiYgdHlwZW9mIF9pbnB1dC5kYXRhWzBdICE9PSAnb2JqZWN0Jylcblx0XHRcdFx0XHRfaW5wdXQuZGF0YSA9IFtfaW5wdXQuZGF0YV07XHQvLyBoYW5kbGVzIGlucHV0IGxpa2UgWzEsMiwzXSBvciBbJ2FzZGYnXVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2VyaWFsaXplKF9pbnB1dC5maWVsZHMgfHwgW10sIF9pbnB1dC5kYXRhIHx8IFtdLCBfc2tpcEVtcHR5TGluZXMpO1xuXHRcdH1cblxuXHRcdC8vIERlZmF1bHQgKGFueSB2YWxpZCBwYXRocyBzaG91bGQgcmV0dXJuIGJlZm9yZSB0aGlzKVxuXHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHNlcmlhbGl6ZSB1bnJlY29nbml6ZWQgaW5wdXQnKTtcblxuXG5cdFx0ZnVuY3Rpb24gdW5wYWNrQ29uZmlnKClcblx0XHR7XG5cdFx0XHRpZiAodHlwZW9mIF9jb25maWcgIT09ICdvYmplY3QnKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdGlmICh0eXBlb2YgX2NvbmZpZy5kZWxpbWl0ZXIgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgJiYgIVBhcGEuQkFEX0RFTElNSVRFUlMuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBfY29uZmlnLmRlbGltaXRlci5pbmRleE9mKHZhbHVlKSAhPT0gLTE7IH0pLmxlbmd0aClcblx0XHRcdHtcblx0XHRcdFx0X2RlbGltaXRlciA9IF9jb25maWcuZGVsaW1pdGVyO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZW9mIF9jb25maWcucXVvdGVzID09PSAnYm9vbGVhbidcblx0XHRcdFx0fHwgdHlwZW9mIF9jb25maWcucXVvdGVzID09PSAnZnVuY3Rpb24nXG5cdFx0XHRcdHx8IEFycmF5LmlzQXJyYXkoX2NvbmZpZy5xdW90ZXMpKVxuXHRcdFx0XHRfcXVvdGVzID0gX2NvbmZpZy5xdW90ZXM7XG5cblx0XHRcdGlmICh0eXBlb2YgX2NvbmZpZy5za2lwRW1wdHlMaW5lcyA9PT0gJ2Jvb2xlYW4nXG5cdFx0XHRcdHx8IHR5cGVvZiBfY29uZmlnLnNraXBFbXB0eUxpbmVzID09PSAnc3RyaW5nJylcblx0XHRcdFx0X3NraXBFbXB0eUxpbmVzID0gX2NvbmZpZy5za2lwRW1wdHlMaW5lcztcblxuXHRcdFx0aWYgKHR5cGVvZiBfY29uZmlnLm5ld2xpbmUgPT09ICdzdHJpbmcnKVxuXHRcdFx0XHRfbmV3bGluZSA9IF9jb25maWcubmV3bGluZTtcblxuXHRcdFx0aWYgKHR5cGVvZiBfY29uZmlnLnF1b3RlQ2hhciA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdF9xdW90ZUNoYXIgPSBfY29uZmlnLnF1b3RlQ2hhcjtcblxuXHRcdFx0aWYgKHR5cGVvZiBfY29uZmlnLmhlYWRlciA9PT0gJ2Jvb2xlYW4nKVxuXHRcdFx0XHRfd3JpdGVIZWFkZXIgPSBfY29uZmlnLmhlYWRlcjtcblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoX2NvbmZpZy5jb2x1bW5zKSkge1xuXG5cdFx0XHRcdGlmIChfY29uZmlnLmNvbHVtbnMubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbiBjb2x1bW5zIGlzIGVtcHR5Jyk7XG5cblx0XHRcdFx0X2NvbHVtbnMgPSBfY29uZmlnLmNvbHVtbnM7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChfY29uZmlnLmVzY2FwZUNoYXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRfZXNjYXBlZFF1b3RlID0gX2NvbmZpZy5lc2NhcGVDaGFyICsgX3F1b3RlQ2hhcjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKF9jb25maWcuZXNjYXBlRm9ybXVsYWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcblx0XHRcdFx0X2VzY2FwZUZvcm11bGFlID0gX2NvbmZpZy5lc2NhcGVGb3JtdWxhZTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIF9jb25maWcuZXNjYXBlRm9ybXVsYWUgPT09ICdib29sZWFuJyAmJiBfY29uZmlnLmVzY2FwZUZvcm11bGFlKSB7XG5cdFx0XHRcdF9lc2NhcGVGb3JtdWxhZSA9ICAvXls9K1xcLUBcXHRcXHJdLiokLztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKiogVGhlIGRvdWJsZSBmb3IgbG9vcCB0aGF0IGl0ZXJhdGVzIHRoZSBkYXRhIGFuZCB3cml0ZXMgb3V0IGEgQ1NWIHN0cmluZyBpbmNsdWRpbmcgaGVhZGVyIHJvdyAqL1xuXHRcdGZ1bmN0aW9uIHNlcmlhbGl6ZShmaWVsZHMsIGRhdGEsIHNraXBFbXB0eUxpbmVzKVxuXHRcdHtcblx0XHRcdHZhciBjc3YgPSAnJztcblxuXHRcdFx0aWYgKHR5cGVvZiBmaWVsZHMgPT09ICdzdHJpbmcnKVxuXHRcdFx0XHRmaWVsZHMgPSBKU09OLnBhcnNlKGZpZWxkcyk7XG5cdFx0XHRpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuXHRcdFx0XHRkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcblxuXHRcdFx0dmFyIGhhc0hlYWRlciA9IEFycmF5LmlzQXJyYXkoZmllbGRzKSAmJiBmaWVsZHMubGVuZ3RoID4gMDtcblx0XHRcdHZhciBkYXRhS2V5ZWRCeUZpZWxkID0gIShBcnJheS5pc0FycmF5KGRhdGFbMF0pKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUgYSBoZWFkZXIgcm93LCB3cml0ZSBpdCBmaXJzdFxuXHRcdFx0aWYgKGhhc0hlYWRlciAmJiBfd3JpdGVIZWFkZXIpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGkgPiAwKVxuXHRcdFx0XHRcdFx0Y3N2ICs9IF9kZWxpbWl0ZXI7XG5cdFx0XHRcdFx0Y3N2ICs9IHNhZmUoZmllbGRzW2ldLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZGF0YS5sZW5ndGggPiAwKVxuXHRcdFx0XHRcdGNzdiArPSBfbmV3bGluZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlbiB3cml0ZSBvdXQgdGhlIGRhdGFcblx0XHRcdGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IGRhdGEubGVuZ3RoOyByb3crKylcblx0XHRcdHtcblx0XHRcdFx0dmFyIG1heENvbCA9IGhhc0hlYWRlciA/IGZpZWxkcy5sZW5ndGggOiBkYXRhW3Jvd10ubGVuZ3RoO1xuXG5cdFx0XHRcdHZhciBlbXB0eUxpbmUgPSBmYWxzZTtcblx0XHRcdFx0dmFyIG51bGxMaW5lID0gaGFzSGVhZGVyID8gT2JqZWN0LmtleXMoZGF0YVtyb3ddKS5sZW5ndGggPT09IDAgOiBkYXRhW3Jvd10ubGVuZ3RoID09PSAwO1xuXHRcdFx0XHRpZiAoc2tpcEVtcHR5TGluZXMgJiYgIWhhc0hlYWRlcilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGVtcHR5TGluZSA9IHNraXBFbXB0eUxpbmVzID09PSAnZ3JlZWR5JyA/IGRhdGFbcm93XS5qb2luKCcnKS50cmltKCkgPT09ICcnIDogZGF0YVtyb3ddLmxlbmd0aCA9PT0gMSAmJiBkYXRhW3Jvd11bMF0ubGVuZ3RoID09PSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChza2lwRW1wdHlMaW5lcyA9PT0gJ2dyZWVkeScgJiYgaGFzSGVhZGVyKSB7XG5cdFx0XHRcdFx0dmFyIGxpbmUgPSBbXTtcblx0XHRcdFx0XHRmb3IgKHZhciBjID0gMDsgYyA8IG1heENvbDsgYysrKSB7XG5cdFx0XHRcdFx0XHR2YXIgY3ggPSBkYXRhS2V5ZWRCeUZpZWxkID8gZmllbGRzW2NdIDogYztcblx0XHRcdFx0XHRcdGxpbmUucHVzaChkYXRhW3Jvd11bY3hdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZW1wdHlMaW5lID0gbGluZS5qb2luKCcnKS50cmltKCkgPT09ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghZW1wdHlMaW5lKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm9yICh2YXIgY29sID0gMDsgY29sIDwgbWF4Q29sOyBjb2wrKylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAoY29sID4gMCAmJiAhbnVsbExpbmUpXG5cdFx0XHRcdFx0XHRcdGNzdiArPSBfZGVsaW1pdGVyO1xuXHRcdFx0XHRcdFx0dmFyIGNvbElkeCA9IGhhc0hlYWRlciAmJiBkYXRhS2V5ZWRCeUZpZWxkID8gZmllbGRzW2NvbF0gOiBjb2w7XG5cdFx0XHRcdFx0XHRjc3YgKz0gc2FmZShkYXRhW3Jvd11bY29sSWR4XSwgY29sKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHJvdyA8IGRhdGEubGVuZ3RoIC0gMSAmJiAoIXNraXBFbXB0eUxpbmVzIHx8IChtYXhDb2wgPiAwICYmICFudWxsTGluZSkpKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNzdiArPSBfbmV3bGluZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjc3Y7XG5cdFx0fVxuXG5cdFx0LyoqIEVuY2xvc2VzIGEgdmFsdWUgYXJvdW5kIHF1b3RlcyBpZiBuZWVkZWQgKG1ha2VzIGEgdmFsdWUgc2FmZSBmb3IgQ1NWIGluc2VydGlvbikgKi9cblx0XHRmdW5jdGlvbiBzYWZlKHN0ciwgY29sKVxuXHRcdHtcblx0XHRcdGlmICh0eXBlb2Ygc3RyID09PSAndW5kZWZpbmVkJyB8fCBzdHIgPT09IG51bGwpXG5cdFx0XHRcdHJldHVybiAnJztcblxuXHRcdFx0aWYgKHN0ci5jb25zdHJ1Y3RvciA9PT0gRGF0ZSlcblx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0cikuc2xpY2UoMSwgMjUpO1xuXG5cdFx0XHR2YXIgbmVlZHNRdW90ZXMgPSBmYWxzZTtcblxuXHRcdFx0aWYgKF9lc2NhcGVGb3JtdWxhZSAmJiB0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiICYmIF9lc2NhcGVGb3JtdWxhZS50ZXN0KHN0cikpIHtcblx0XHRcdFx0c3RyID0gXCInXCIgKyBzdHI7XG5cdFx0XHRcdG5lZWRzUXVvdGVzID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGVzY2FwZWRRdW90ZVN0ciA9IHN0ci50b1N0cmluZygpLnJlcGxhY2UocXVvdGVDaGFyUmVnZXgsIF9lc2NhcGVkUXVvdGUpO1xuXG5cdFx0XHRuZWVkc1F1b3RlcyA9IG5lZWRzUXVvdGVzXG5cdFx0XHRcdFx0XHRcdHx8IF9xdW90ZXMgPT09IHRydWVcblx0XHRcdFx0XHRcdFx0fHwgKHR5cGVvZiBfcXVvdGVzID09PSAnZnVuY3Rpb24nICYmIF9xdW90ZXMoc3RyLCBjb2wpKVxuXHRcdFx0XHRcdFx0XHR8fCAoQXJyYXkuaXNBcnJheShfcXVvdGVzKSAmJiBfcXVvdGVzW2NvbF0pXG5cdFx0XHRcdFx0XHRcdHx8IGhhc0FueShlc2NhcGVkUXVvdGVTdHIsIFBhcGEuQkFEX0RFTElNSVRFUlMpXG5cdFx0XHRcdFx0XHRcdHx8IGVzY2FwZWRRdW90ZVN0ci5pbmRleE9mKF9kZWxpbWl0ZXIpID4gLTFcblx0XHRcdFx0XHRcdFx0fHwgZXNjYXBlZFF1b3RlU3RyLmNoYXJBdCgwKSA9PT0gJyAnXG5cdFx0XHRcdFx0XHRcdHx8IGVzY2FwZWRRdW90ZVN0ci5jaGFyQXQoZXNjYXBlZFF1b3RlU3RyLmxlbmd0aCAtIDEpID09PSAnICc7XG5cblx0XHRcdHJldHVybiBuZWVkc1F1b3RlcyA/IF9xdW90ZUNoYXIgKyBlc2NhcGVkUXVvdGVTdHIgKyBfcXVvdGVDaGFyIDogZXNjYXBlZFF1b3RlU3RyO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhc0FueShzdHIsIHN1YnN0cmluZ3MpXG5cdFx0e1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzdHJpbmdzLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRpZiAoc3RyLmluZGV4T2Yoc3Vic3RyaW5nc1tpXSkgPiAtMSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblxuXG5cdC8qKiBDaHVua1N0cmVhbWVyIGlzIHRoZSBiYXNlIHByb3RvdHlwZSBmb3IgdmFyaW91cyBzdHJlYW1lciBpbXBsZW1lbnRhdGlvbnMuICovXG5cdGZ1bmN0aW9uIENodW5rU3RyZWFtZXIoY29uZmlnKVxuXHR7XG5cdFx0dGhpcy5faGFuZGxlID0gbnVsbDtcblx0XHR0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2NvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2hhbHRlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX2lucHV0ID0gbnVsbDtcblx0XHR0aGlzLl9iYXNlSW5kZXggPSAwO1xuXHRcdHRoaXMuX3BhcnRpYWxMaW5lID0gJyc7XG5cdFx0dGhpcy5fcm93Q291bnQgPSAwO1xuXHRcdHRoaXMuX3N0YXJ0ID0gMDtcblx0XHR0aGlzLl9uZXh0Q2h1bmsgPSBudWxsO1xuXHRcdHRoaXMuaXNGaXJzdENodW5rID0gdHJ1ZTtcblx0XHR0aGlzLl9jb21wbGV0ZVJlc3VsdHMgPSB7XG5cdFx0XHRkYXRhOiBbXSxcblx0XHRcdGVycm9yczogW10sXG5cdFx0XHRtZXRhOiB7fVxuXHRcdH07XG5cdFx0cmVwbGFjZUNvbmZpZy5jYWxsKHRoaXMsIGNvbmZpZyk7XG5cblx0XHR0aGlzLnBhcnNlQ2h1bmsgPSBmdW5jdGlvbihjaHVuaywgaXNGYWtlQ2h1bmspXG5cdFx0e1xuXHRcdFx0Ly8gRmlyc3QgY2h1bmsgcHJlLXByb2Nlc3Npbmdcblx0XHRcdGNvbnN0IHNraXBGaXJzdE5MaW5lcyA9IHBhcnNlSW50KHRoaXMuX2NvbmZpZy5za2lwRmlyc3ROTGluZXMpIHx8IDA7XG5cdFx0XHRpZiAodGhpcy5pc0ZpcnN0Q2h1bmsgJiYgc2tpcEZpcnN0TkxpbmVzID4gMCkge1xuXHRcdFx0XHRsZXQgX25ld2xpbmUgPSB0aGlzLl9jb25maWcubmV3bGluZTtcblx0XHRcdFx0aWYgKCFfbmV3bGluZSkge1xuXHRcdFx0XHRcdGNvbnN0IHF1b3RlQ2hhciA9IHRoaXMuX2NvbmZpZy5xdW90ZUNoYXIgfHwgJ1wiJztcblx0XHRcdFx0XHRfbmV3bGluZSA9IHRoaXMuX2hhbmRsZS5ndWVzc0xpbmVFbmRpbmdzKGNodW5rLCBxdW90ZUNoYXIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IHNwbGl0Q2h1bmsgPSBjaHVuay5zcGxpdChfbmV3bGluZSk7XG5cdFx0XHRcdGNodW5rID0gWy4uLnNwbGl0Q2h1bmsuc2xpY2Uoc2tpcEZpcnN0TkxpbmVzKV0uam9pbihfbmV3bGluZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5pc0ZpcnN0Q2h1bmsgJiYgaXNGdW5jdGlvbih0aGlzLl9jb25maWcuYmVmb3JlRmlyc3RDaHVuaykpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBtb2RpZmllZENodW5rID0gdGhpcy5fY29uZmlnLmJlZm9yZUZpcnN0Q2h1bmsoY2h1bmspO1xuXHRcdFx0XHRpZiAobW9kaWZpZWRDaHVuayAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdGNodW5rID0gbW9kaWZpZWRDaHVuaztcblx0XHRcdH1cblx0XHRcdHRoaXMuaXNGaXJzdENodW5rID0gZmFsc2U7XG5cdFx0XHR0aGlzLl9oYWx0ZWQgPSBmYWxzZTtcblxuXHRcdFx0Ly8gUmVqb2luIHRoZSBsaW5lIHdlIGxpa2VseSBqdXN0IHNwbGl0IGluIHR3byBieSBjaHVua2luZyB0aGUgZmlsZVxuXHRcdFx0dmFyIGFnZ3JlZ2F0ZSA9IHRoaXMuX3BhcnRpYWxMaW5lICsgY2h1bms7XG5cdFx0XHR0aGlzLl9wYXJ0aWFsTGluZSA9ICcnO1xuXHRcdFx0dmFyIHJlc3VsdHMgPSB0aGlzLl9oYW5kbGUucGFyc2UoYWdncmVnYXRlLCB0aGlzLl9iYXNlSW5kZXgsICF0aGlzLl9maW5pc2hlZCk7XG5cblx0XHRcdGlmICh0aGlzLl9oYW5kbGUucGF1c2VkKCkgfHwgdGhpcy5faGFuZGxlLmFib3J0ZWQoKSkge1xuXHRcdFx0XHR0aGlzLl9oYWx0ZWQgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBsYXN0SW5kZXggPSByZXN1bHRzLm1ldGEuY3Vyc29yO1xuXG5cdFx0XHRpZiAoIXRoaXMuX2ZpbmlzaGVkKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl9wYXJ0aWFsTGluZSA9IGFnZ3JlZ2F0ZS5zdWJzdHJpbmcobGFzdEluZGV4IC0gdGhpcy5fYmFzZUluZGV4KTtcblx0XHRcdFx0dGhpcy5fYmFzZUluZGV4ID0gbGFzdEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmVzdWx0cyAmJiByZXN1bHRzLmRhdGEpXG5cdFx0XHRcdHRoaXMuX3Jvd0NvdW50ICs9IHJlc3VsdHMuZGF0YS5sZW5ndGg7XG5cblx0XHRcdHZhciBmaW5pc2hlZEluY2x1ZGluZ1ByZXZpZXcgPSB0aGlzLl9maW5pc2hlZCB8fCAodGhpcy5fY29uZmlnLnByZXZpZXcgJiYgdGhpcy5fcm93Q291bnQgPj0gdGhpcy5fY29uZmlnLnByZXZpZXcpO1xuXG5cdFx0XHRpZiAoSVNfUEFQQV9XT1JLRVIpXG5cdFx0XHR7XG5cdFx0XHRcdGdsb2JhbC5wb3N0TWVzc2FnZSh7XG5cdFx0XHRcdFx0cmVzdWx0czogcmVzdWx0cyxcblx0XHRcdFx0XHR3b3JrZXJJZDogUGFwYS5XT1JLRVJfSUQsXG5cdFx0XHRcdFx0ZmluaXNoZWQ6IGZpbmlzaGVkSW5jbHVkaW5nUHJldmlld1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fY29uZmlnLmNodW5rKSAmJiAhaXNGYWtlQ2h1bmspXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX2NvbmZpZy5jaHVuayhyZXN1bHRzLCB0aGlzLl9oYW5kbGUpO1xuXHRcdFx0XHRpZiAodGhpcy5faGFuZGxlLnBhdXNlZCgpIHx8IHRoaXMuX2hhbmRsZS5hYm9ydGVkKCkpIHtcblx0XHRcdFx0XHR0aGlzLl9oYWx0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXN1bHRzID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR0aGlzLl9jb21wbGV0ZVJlc3VsdHMgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5fY29uZmlnLnN0ZXAgJiYgIXRoaXMuX2NvbmZpZy5jaHVuaykge1xuXHRcdFx0XHR0aGlzLl9jb21wbGV0ZVJlc3VsdHMuZGF0YSA9IHRoaXMuX2NvbXBsZXRlUmVzdWx0cy5kYXRhLmNvbmNhdChyZXN1bHRzLmRhdGEpO1xuXHRcdFx0XHR0aGlzLl9jb21wbGV0ZVJlc3VsdHMuZXJyb3JzID0gdGhpcy5fY29tcGxldGVSZXN1bHRzLmVycm9ycy5jb25jYXQocmVzdWx0cy5lcnJvcnMpO1xuXHRcdFx0XHR0aGlzLl9jb21wbGV0ZVJlc3VsdHMubWV0YSA9IHJlc3VsdHMubWV0YTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF0aGlzLl9jb21wbGV0ZWQgJiYgZmluaXNoZWRJbmNsdWRpbmdQcmV2aWV3ICYmIGlzRnVuY3Rpb24odGhpcy5fY29uZmlnLmNvbXBsZXRlKSAmJiAoIXJlc3VsdHMgfHwgIXJlc3VsdHMubWV0YS5hYm9ydGVkKSkge1xuXHRcdFx0XHR0aGlzLl9jb25maWcuY29tcGxldGUodGhpcy5fY29tcGxldGVSZXN1bHRzLCB0aGlzLl9pbnB1dCk7XG5cdFx0XHRcdHRoaXMuX2NvbXBsZXRlZCA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghZmluaXNoZWRJbmNsdWRpbmdQcmV2aWV3ICYmICghcmVzdWx0cyB8fCAhcmVzdWx0cy5tZXRhLnBhdXNlZCkpXG5cdFx0XHRcdHRoaXMuX25leHRDaHVuaygpO1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdFx0dGhpcy5fc2VuZEVycm9yID0gZnVuY3Rpb24oZXJyb3IpXG5cdFx0e1xuXHRcdFx0aWYgKGlzRnVuY3Rpb24odGhpcy5fY29uZmlnLmVycm9yKSlcblx0XHRcdFx0dGhpcy5fY29uZmlnLmVycm9yKGVycm9yKTtcblx0XHRcdGVsc2UgaWYgKElTX1BBUEFfV09SS0VSICYmIHRoaXMuX2NvbmZpZy5lcnJvcilcblx0XHRcdHtcblx0XHRcdFx0Z2xvYmFsLnBvc3RNZXNzYWdlKHtcblx0XHRcdFx0XHR3b3JrZXJJZDogUGFwYS5XT1JLRVJfSUQsXG5cdFx0XHRcdFx0ZXJyb3I6IGVycm9yLFxuXHRcdFx0XHRcdGZpbmlzaGVkOiBmYWxzZVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVwbGFjZUNvbmZpZyhjb25maWcpXG5cdFx0e1xuXHRcdFx0Ly8gRGVlcC1jb3B5IHRoZSBjb25maWcgc28gd2UgY2FuIGVkaXQgaXRcblx0XHRcdHZhciBjb25maWdDb3B5ID0gY29weShjb25maWcpO1xuXHRcdFx0Y29uZmlnQ29weS5jaHVua1NpemUgPSBwYXJzZUludChjb25maWdDb3B5LmNodW5rU2l6ZSk7XHQvLyBwYXJzZUludCBWRVJZIGltcG9ydGFudCBzbyB3ZSBkb24ndCBjb25jYXRlbmF0ZSBzdHJpbmdzIVxuXHRcdFx0aWYgKCFjb25maWcuc3RlcCAmJiAhY29uZmlnLmNodW5rKVxuXHRcdFx0XHRjb25maWdDb3B5LmNodW5rU2l6ZSA9IG51bGw7ICAvLyBkaXNhYmxlIFJhbmdlIGhlYWRlciBpZiBub3Qgc3RyZWFtaW5nOyBiYWQgdmFsdWVzIGJyZWFrIElJUyAtIHNlZSBpc3N1ZSAjMTk2XG5cdFx0XHR0aGlzLl9oYW5kbGUgPSBuZXcgUGFyc2VySGFuZGxlKGNvbmZpZ0NvcHkpO1xuXHRcdFx0dGhpcy5faGFuZGxlLnN0cmVhbWVyID0gdGhpcztcblx0XHRcdHRoaXMuX2NvbmZpZyA9IGNvbmZpZ0NvcHk7XHQvLyBwZXJzaXN0IHRoZSBjb3B5IHRvIHRoZSBjYWxsZXJcblx0XHR9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIE5ldHdvcmtTdHJlYW1lcihjb25maWcpXG5cdHtcblx0XHRjb25maWcgPSBjb25maWcgfHwge307XG5cdFx0aWYgKCFjb25maWcuY2h1bmtTaXplKVxuXHRcdFx0Y29uZmlnLmNodW5rU2l6ZSA9IFBhcGEuUmVtb3RlQ2h1bmtTaXplO1xuXHRcdENodW5rU3RyZWFtZXIuY2FsbCh0aGlzLCBjb25maWcpO1xuXG5cdFx0dmFyIHhocjtcblxuXHRcdGlmIChJU19XT1JLRVIpXG5cdFx0e1xuXHRcdFx0dGhpcy5fbmV4dENodW5rID0gZnVuY3Rpb24oKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl9yZWFkQ2h1bmsoKTtcblx0XHRcdFx0dGhpcy5fY2h1bmtMb2FkZWQoKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHR0aGlzLl9uZXh0Q2h1bmsgPSBmdW5jdGlvbigpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX3JlYWRDaHVuaygpO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHR0aGlzLnN0cmVhbSA9IGZ1bmN0aW9uKHVybClcblx0XHR7XG5cdFx0XHR0aGlzLl9pbnB1dCA9IHVybDtcblx0XHRcdHRoaXMuX25leHRDaHVuaygpO1x0Ly8gU3RhcnRzIHN0cmVhbWluZ1xuXHRcdH07XG5cblx0XHR0aGlzLl9yZWFkQ2h1bmsgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuX2ZpbmlzaGVkKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl9jaHVua0xvYWRlZCgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG5cdFx0XHRpZiAodGhpcy5fY29uZmlnLndpdGhDcmVkZW50aWFscylcblx0XHRcdHtcblx0XHRcdFx0eGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMuX2NvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghSVNfV09SS0VSKVxuXHRcdFx0e1xuXHRcdFx0XHR4aHIub25sb2FkID0gYmluZEZ1bmN0aW9uKHRoaXMuX2NodW5rTG9hZGVkLCB0aGlzKTtcblx0XHRcdFx0eGhyLm9uZXJyb3IgPSBiaW5kRnVuY3Rpb24odGhpcy5fY2h1bmtFcnJvciwgdGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdHhoci5vcGVuKHRoaXMuX2NvbmZpZy5kb3dubG9hZFJlcXVlc3RCb2R5ID8gJ1BPU1QnIDogJ0dFVCcsIHRoaXMuX2lucHV0LCAhSVNfV09SS0VSKTtcblx0XHRcdC8vIEhlYWRlcnMgY2FuIG9ubHkgYmUgc2V0IHdoZW4gb25jZSB0aGUgcmVxdWVzdCBzdGF0ZSBpcyBPUEVORURcblx0XHRcdGlmICh0aGlzLl9jb25maWcuZG93bmxvYWRSZXF1ZXN0SGVhZGVycylcblx0XHRcdHtcblx0XHRcdFx0dmFyIGhlYWRlcnMgPSB0aGlzLl9jb25maWcuZG93bmxvYWRSZXF1ZXN0SGVhZGVycztcblxuXHRcdFx0XHRmb3IgKHZhciBoZWFkZXJOYW1lIGluIGhlYWRlcnMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJOYW1lLCBoZWFkZXJzW2hlYWRlck5hbWVdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fY29uZmlnLmNodW5rU2l6ZSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIGVuZCA9IHRoaXMuX3N0YXJ0ICsgdGhpcy5fY29uZmlnLmNodW5rU2l6ZSAtIDE7XHQvLyBtaW51cyBvbmUgYmVjYXVzZSBieXRlIHJhbmdlIGlzIGluY2x1c2l2ZVxuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCAnYnl0ZXM9JyArIHRoaXMuX3N0YXJ0ICsgJy0nICsgZW5kKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0eGhyLnNlbmQodGhpcy5fY29uZmlnLmRvd25sb2FkUmVxdWVzdEJvZHkpO1xuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGVycikge1xuXHRcdFx0XHR0aGlzLl9jaHVua0Vycm9yKGVyci5tZXNzYWdlKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKElTX1dPUktFUiAmJiB4aHIuc3RhdHVzID09PSAwKVxuXHRcdFx0XHR0aGlzLl9jaHVua0Vycm9yKCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuX2NodW5rTG9hZGVkID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gNClcblx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRpZiAoeGhyLnN0YXR1cyA8IDIwMCB8fCB4aHIuc3RhdHVzID49IDQwMClcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5fY2h1bmtFcnJvcigpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVzZSBjaHVuY2tTaXplIGFzIGl0IG1heSBiZSBhIGRpZmVyZW5jZSBvbiByZXBvbnNlIGxlbnRnaCBkdWUgdG8gY2hhcmFjdGVycyB3aXRoIG1vcmUgdGhhbiAxIGJ5dGVcblx0XHRcdHRoaXMuX3N0YXJ0ICs9IHRoaXMuX2NvbmZpZy5jaHVua1NpemUgPyB0aGlzLl9jb25maWcuY2h1bmtTaXplIDogeGhyLnJlc3BvbnNlVGV4dC5sZW5ndGg7XG5cdFx0XHR0aGlzLl9maW5pc2hlZCA9ICF0aGlzLl9jb25maWcuY2h1bmtTaXplIHx8IHRoaXMuX3N0YXJ0ID49IGdldEZpbGVTaXplKHhocik7XG5cdFx0XHR0aGlzLnBhcnNlQ2h1bmsoeGhyLnJlc3BvbnNlVGV4dCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuX2NodW5rRXJyb3IgPSBmdW5jdGlvbihlcnJvck1lc3NhZ2UpXG5cdFx0e1xuXHRcdFx0dmFyIGVycm9yVGV4dCA9IHhoci5zdGF0dXNUZXh0IHx8IGVycm9yTWVzc2FnZTtcblx0XHRcdHRoaXMuX3NlbmRFcnJvcihuZXcgRXJyb3IoZXJyb3JUZXh0KSk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldEZpbGVTaXplKHhocilcblx0XHR7XG5cdFx0XHR2YXIgY29udGVudFJhbmdlID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVJhbmdlJyk7XG5cdFx0XHRpZiAoY29udGVudFJhbmdlID09PSBudWxsKSB7IC8vIG5vIGNvbnRlbnQgcmFuZ2UsIHRoZW4gZmluaXNoIVxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFyc2VJbnQoY29udGVudFJhbmdlLnN1YnN0cmluZyhjb250ZW50UmFuZ2UubGFzdEluZGV4T2YoJy8nKSArIDEpKTtcblx0XHR9XG5cdH1cblx0TmV0d29ya1N0cmVhbWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2h1bmtTdHJlYW1lci5wcm90b3R5cGUpO1xuXHROZXR3b3JrU3RyZWFtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTmV0d29ya1N0cmVhbWVyO1xuXG5cblx0ZnVuY3Rpb24gRmlsZVN0cmVhbWVyKGNvbmZpZylcblx0e1xuXHRcdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblx0XHRpZiAoIWNvbmZpZy5jaHVua1NpemUpXG5cdFx0XHRjb25maWcuY2h1bmtTaXplID0gUGFwYS5Mb2NhbENodW5rU2l6ZTtcblx0XHRDaHVua1N0cmVhbWVyLmNhbGwodGhpcywgY29uZmlnKTtcblxuXHRcdHZhciByZWFkZXIsIHNsaWNlO1xuXG5cdFx0Ly8gRmlsZVJlYWRlciBpcyBiZXR0ZXIgdGhhbiBGaWxlUmVhZGVyU3luYyAoZXZlbiBpbiB3b3JrZXIpIC0gc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xLzI0NzA4NjQ5LzEwNDg4NjJcblx0XHQvLyBCdXQgRmlyZWZveCBpcyBhIHBpbGwsIHRvbyAtIHNlZSBpc3N1ZSAjNzY6IGh0dHBzOi8vZ2l0aHViLmNvbS9taG9sdC9QYXBhUGFyc2UvaXNzdWVzLzc2XG5cdFx0dmFyIHVzaW5nQXN5bmNSZWFkZXIgPSB0eXBlb2YgRmlsZVJlYWRlciAhPT0gJ3VuZGVmaW5lZCc7XHQvLyBTYWZhcmkgZG9lc24ndCBjb25zaWRlciBpdCBhIGZ1bmN0aW9uIC0gc2VlIGlzc3VlICMxMDVcblxuXHRcdHRoaXMuc3RyZWFtID0gZnVuY3Rpb24oZmlsZSlcblx0XHR7XG5cdFx0XHR0aGlzLl9pbnB1dCA9IGZpbGU7XG5cdFx0XHRzbGljZSA9IGZpbGUuc2xpY2UgfHwgZmlsZS53ZWJraXRTbGljZSB8fCBmaWxlLm1velNsaWNlO1xuXG5cdFx0XHRpZiAodXNpbmdBc3luY1JlYWRlcilcblx0XHRcdHtcblx0XHRcdFx0cmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcdFx0Ly8gUHJlZmVycmVkIG1ldGhvZCBvZiByZWFkaW5nIGZpbGVzLCBldmVuIGluIHdvcmtlcnNcblx0XHRcdFx0cmVhZGVyLm9ubG9hZCA9IGJpbmRGdW5jdGlvbih0aGlzLl9jaHVua0xvYWRlZCwgdGhpcyk7XG5cdFx0XHRcdHJlYWRlci5vbmVycm9yID0gYmluZEZ1bmN0aW9uKHRoaXMuX2NodW5rRXJyb3IsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZWFkZXIgPSBuZXcgRmlsZVJlYWRlclN5bmMoKTtcdC8vIEhhY2sgZm9yIHJ1bm5pbmcgaW4gYSB3ZWIgd29ya2VyIGluIEZpcmVmb3hcblxuXHRcdFx0dGhpcy5fbmV4dENodW5rKCk7XHQvLyBTdGFydHMgc3RyZWFtaW5nXG5cdFx0fTtcblxuXHRcdHRoaXMuX25leHRDaHVuayA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRpZiAoIXRoaXMuX2ZpbmlzaGVkICYmICghdGhpcy5fY29uZmlnLnByZXZpZXcgfHwgdGhpcy5fcm93Q291bnQgPCB0aGlzLl9jb25maWcucHJldmlldykpXG5cdFx0XHRcdHRoaXMuX3JlYWRDaHVuaygpO1xuXHRcdH07XG5cblx0XHR0aGlzLl9yZWFkQ2h1bmsgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0dmFyIGlucHV0ID0gdGhpcy5faW5wdXQ7XG5cdFx0XHRpZiAodGhpcy5fY29uZmlnLmNodW5rU2l6ZSlcblx0XHRcdHtcblx0XHRcdFx0dmFyIGVuZCA9IE1hdGgubWluKHRoaXMuX3N0YXJ0ICsgdGhpcy5fY29uZmlnLmNodW5rU2l6ZSwgdGhpcy5faW5wdXQuc2l6ZSk7XG5cdFx0XHRcdGlucHV0ID0gc2xpY2UuY2FsbChpbnB1dCwgdGhpcy5fc3RhcnQsIGVuZCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdHh0ID0gcmVhZGVyLnJlYWRBc1RleHQoaW5wdXQsIHRoaXMuX2NvbmZpZy5lbmNvZGluZyk7XG5cdFx0XHRpZiAoIXVzaW5nQXN5bmNSZWFkZXIpXG5cdFx0XHRcdHRoaXMuX2NodW5rTG9hZGVkKHsgdGFyZ2V0OiB7IHJlc3VsdDogdHh0IH0gfSk7XHQvLyBtaW1pYyB0aGUgYXN5bmMgc2lnbmF0dXJlXG5cdFx0fTtcblxuXHRcdHRoaXMuX2NodW5rTG9hZGVkID0gZnVuY3Rpb24oZXZlbnQpXG5cdFx0e1xuXHRcdFx0Ly8gVmVyeSBpbXBvcnRhbnQgdG8gaW5jcmVtZW50IHN0YXJ0IGVhY2ggdGltZSBiZWZvcmUgaGFuZGxpbmcgcmVzdWx0c1xuXHRcdFx0dGhpcy5fc3RhcnQgKz0gdGhpcy5fY29uZmlnLmNodW5rU2l6ZTtcblx0XHRcdHRoaXMuX2ZpbmlzaGVkID0gIXRoaXMuX2NvbmZpZy5jaHVua1NpemUgfHwgdGhpcy5fc3RhcnQgPj0gdGhpcy5faW5wdXQuc2l6ZTtcblx0XHRcdHRoaXMucGFyc2VDaHVuayhldmVudC50YXJnZXQucmVzdWx0KTtcblx0XHR9O1xuXG5cdFx0dGhpcy5fY2h1bmtFcnJvciA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHR0aGlzLl9zZW5kRXJyb3IocmVhZGVyLmVycm9yKTtcblx0XHR9O1xuXG5cdH1cblx0RmlsZVN0cmVhbWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2h1bmtTdHJlYW1lci5wcm90b3R5cGUpO1xuXHRGaWxlU3RyZWFtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmlsZVN0cmVhbWVyO1xuXG5cblx0ZnVuY3Rpb24gU3RyaW5nU3RyZWFtZXIoY29uZmlnKVxuXHR7XG5cdFx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xuXHRcdENodW5rU3RyZWFtZXIuY2FsbCh0aGlzLCBjb25maWcpO1xuXG5cdFx0dmFyIHJlbWFpbmluZztcblx0XHR0aGlzLnN0cmVhbSA9IGZ1bmN0aW9uKHMpXG5cdFx0e1xuXHRcdFx0cmVtYWluaW5nID0gcztcblx0XHRcdHJldHVybiB0aGlzLl9uZXh0Q2h1bmsoKTtcblx0XHR9O1xuXHRcdHRoaXMuX25leHRDaHVuayA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fZmluaXNoZWQpIHJldHVybjtcblx0XHRcdHZhciBzaXplID0gdGhpcy5fY29uZmlnLmNodW5rU2l6ZTtcblx0XHRcdHZhciBjaHVuaztcblx0XHRcdGlmKHNpemUpIHtcblx0XHRcdFx0Y2h1bmsgPSByZW1haW5pbmcuc3Vic3RyaW5nKDAsIHNpemUpO1xuXHRcdFx0XHRyZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyaW5nKHNpemUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2h1bmsgPSByZW1haW5pbmc7XG5cdFx0XHRcdHJlbWFpbmluZyA9ICcnO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fZmluaXNoZWQgPSAhcmVtYWluaW5nO1xuXHRcdFx0cmV0dXJuIHRoaXMucGFyc2VDaHVuayhjaHVuayk7XG5cdFx0fTtcblx0fVxuXHRTdHJpbmdTdHJlYW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN0cmluZ1N0cmVhbWVyLnByb3RvdHlwZSk7XG5cdFN0cmluZ1N0cmVhbWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0cmluZ1N0cmVhbWVyO1xuXG5cblx0ZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1TdHJlYW1lcihjb25maWcpXG5cdHtcblx0XHRjb25maWcgPSBjb25maWcgfHwge307XG5cblx0XHRDaHVua1N0cmVhbWVyLmNhbGwodGhpcywgY29uZmlnKTtcblxuXHRcdHZhciBxdWV1ZSA9IFtdO1xuXHRcdHZhciBwYXJzZU9uRGF0YSA9IHRydWU7XG5cdFx0dmFyIHN0cmVhbUhhc0VuZGVkID0gZmFsc2U7XG5cblx0XHR0aGlzLnBhdXNlID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdENodW5rU3RyZWFtZXIucHJvdG90eXBlLnBhdXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLl9pbnB1dC5wYXVzZSgpO1xuXHRcdH07XG5cblx0XHR0aGlzLnJlc3VtZSA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRDaHVua1N0cmVhbWVyLnByb3RvdHlwZS5yZXN1bWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuX2lucHV0LnJlc3VtZSgpO1xuXHRcdH07XG5cblx0XHR0aGlzLnN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSlcblx0XHR7XG5cdFx0XHR0aGlzLl9pbnB1dCA9IHN0cmVhbTtcblxuXHRcdFx0dGhpcy5faW5wdXQub24oJ2RhdGEnLCB0aGlzLl9zdHJlYW1EYXRhKTtcblx0XHRcdHRoaXMuX2lucHV0Lm9uKCdlbmQnLCB0aGlzLl9zdHJlYW1FbmQpO1xuXHRcdFx0dGhpcy5faW5wdXQub24oJ2Vycm9yJywgdGhpcy5fc3RyZWFtRXJyb3IpO1xuXHRcdH07XG5cblx0XHR0aGlzLl9jaGVja0lzRmluaXNoZWQgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0aWYgKHN0cmVhbUhhc0VuZGVkICYmIHF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHR0aGlzLl9maW5pc2hlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoaXMuX25leHRDaHVuayA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHR0aGlzLl9jaGVja0lzRmluaXNoZWQoKTtcblx0XHRcdGlmIChxdWV1ZS5sZW5ndGgpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMucGFyc2VDaHVuayhxdWV1ZS5zaGlmdCgpKTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0cGFyc2VPbkRhdGEgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR0aGlzLl9zdHJlYW1EYXRhID0gYmluZEZ1bmN0aW9uKGZ1bmN0aW9uKGNodW5rKVxuXHRcdHtcblx0XHRcdHRyeVxuXHRcdFx0e1xuXHRcdFx0XHRxdWV1ZS5wdXNoKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgPyBjaHVuayA6IGNodW5rLnRvU3RyaW5nKHRoaXMuX2NvbmZpZy5lbmNvZGluZykpO1xuXG5cdFx0XHRcdGlmIChwYXJzZU9uRGF0YSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHBhcnNlT25EYXRhID0gZmFsc2U7XG5cdFx0XHRcdFx0dGhpcy5fY2hlY2tJc0ZpbmlzaGVkKCk7XG5cdFx0XHRcdFx0dGhpcy5wYXJzZUNodW5rKHF1ZXVlLnNoaWZ0KCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoZXJyb3IpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX3N0cmVhbUVycm9yKGVycm9yKTtcblx0XHRcdH1cblx0XHR9LCB0aGlzKTtcblxuXHRcdHRoaXMuX3N0cmVhbUVycm9yID0gYmluZEZ1bmN0aW9uKGZ1bmN0aW9uKGVycm9yKVxuXHRcdHtcblx0XHRcdHRoaXMuX3N0cmVhbUNsZWFuVXAoKTtcblx0XHRcdHRoaXMuX3NlbmRFcnJvcihlcnJvcik7XG5cdFx0fSwgdGhpcyk7XG5cblx0XHR0aGlzLl9zdHJlYW1FbmQgPSBiaW5kRnVuY3Rpb24oZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHRoaXMuX3N0cmVhbUNsZWFuVXAoKTtcblx0XHRcdHN0cmVhbUhhc0VuZGVkID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3N0cmVhbURhdGEoJycpO1xuXHRcdH0sIHRoaXMpO1xuXG5cdFx0dGhpcy5fc3RyZWFtQ2xlYW5VcCA9IGJpbmRGdW5jdGlvbihmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0dGhpcy5faW5wdXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCB0aGlzLl9zdHJlYW1EYXRhKTtcblx0XHRcdHRoaXMuX2lucHV0LnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB0aGlzLl9zdHJlYW1FbmQpO1xuXHRcdFx0dGhpcy5faW5wdXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fc3RyZWFtRXJyb3IpO1xuXHRcdH0sIHRoaXMpO1xuXHR9XG5cdFJlYWRhYmxlU3RyZWFtU3RyZWFtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDaHVua1N0cmVhbWVyLnByb3RvdHlwZSk7XG5cdFJlYWRhYmxlU3RyZWFtU3RyZWFtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVhZGFibGVTdHJlYW1TdHJlYW1lcjtcblxuXG5cdGZ1bmN0aW9uIER1cGxleFN0cmVhbVN0cmVhbWVyKF9jb25maWcpIHtcblx0XHR2YXIgRHVwbGV4ID0gcmVxdWlyZSgnc3RyZWFtJykuRHVwbGV4O1xuXHRcdHZhciBjb25maWcgPSBjb3B5KF9jb25maWcpO1xuXHRcdHZhciBwYXJzZU9uV3JpdGUgPSB0cnVlO1xuXHRcdHZhciB3cml0ZVN0cmVhbUhhc0ZpbmlzaGVkID0gZmFsc2U7XG5cdFx0dmFyIHBhcnNlQ2FsbGJhY2tRdWV1ZSA9IFtdO1xuXHRcdHZhciBzdHJlYW0gPSBudWxsO1xuXG5cdFx0dGhpcy5fb25Dc3ZEYXRhID0gZnVuY3Rpb24ocmVzdWx0cylcblx0XHR7XG5cdFx0XHR2YXIgZGF0YSA9IHJlc3VsdHMuZGF0YTtcblx0XHRcdGlmICghc3RyZWFtLnB1c2goZGF0YSkgJiYgIXRoaXMuX2hhbmRsZS5wYXVzZWQoKSkge1xuXHRcdFx0XHQvLyB0aGUgd3JpdGVhYmxlIGNvbnN1bWVyIGJ1ZmZlciBoYXMgZmlsbGVkIHVwXG5cdFx0XHRcdC8vIHNvIHdlIG5lZWQgdG8gcGF1c2UgdW50aWwgbW9yZSBpdGVtc1xuXHRcdFx0XHQvLyBjYW4gYmUgcHJvY2Vzc2VkXG5cdFx0XHRcdHRoaXMuX2hhbmRsZS5wYXVzZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR0aGlzLl9vbkNzdkNvbXBsZXRlID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdC8vIG5vZGUgd2lsbCBmaW5pc2ggdGhlIHJlYWQgc3RyZWFtIHdoZW5cblx0XHRcdC8vIG51bGwgaXMgcHVzaGVkXG5cdFx0XHRzdHJlYW0ucHVzaChudWxsKTtcblx0XHR9O1xuXG5cdFx0Y29uZmlnLnN0ZXAgPSBiaW5kRnVuY3Rpb24odGhpcy5fb25Dc3ZEYXRhLCB0aGlzKTtcblx0XHRjb25maWcuY29tcGxldGUgPSBiaW5kRnVuY3Rpb24odGhpcy5fb25Dc3ZDb21wbGV0ZSwgdGhpcyk7XG5cdFx0Q2h1bmtTdHJlYW1lci5jYWxsKHRoaXMsIGNvbmZpZyk7XG5cblx0XHR0aGlzLl9uZXh0Q2h1bmsgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0aWYgKHdyaXRlU3RyZWFtSGFzRmluaXNoZWQgJiYgcGFyc2VDYWxsYmFja1F1ZXVlLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHR0aGlzLl9maW5pc2hlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAocGFyc2VDYWxsYmFja1F1ZXVlLmxlbmd0aCkge1xuXHRcdFx0XHRwYXJzZUNhbGxiYWNrUXVldWUuc2hpZnQoKSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGFyc2VPbldyaXRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy5fYWRkVG9QYXJzZVF1ZXVlID0gZnVuY3Rpb24oY2h1bmssIGNhbGxiYWNrKVxuXHRcdHtcblx0XHRcdC8vIGFkZCB0byBxdWV1ZSBzbyB0aGF0IHdlIGNhbiBpbmRpY2F0ZVxuXHRcdFx0Ly8gY29tcGxldGlvbiB2aWEgY2FsbGJhY2tcblx0XHRcdC8vIG5vZGUgd2lsbCBhdXRvbWF0aWNhbGx5IHBhdXNlIHRoZSBpbmNvbWluZyBzdHJlYW1cblx0XHRcdC8vIHdoZW4gdG9vIG1hbnkgaXRlbXMgaGF2ZSBiZWVuIGFkZGVkIHdpdGhvdXQgdGhlaXJcblx0XHRcdC8vIGNhbGxiYWNrIGJlaW5nIGludm9rZWRcblx0XHRcdHBhcnNlQ2FsbGJhY2tRdWV1ZS5wdXNoKGJpbmRGdW5jdGlvbihmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5wYXJzZUNodW5rKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgPyBjaHVuayA6IGNodW5rLnRvU3RyaW5nKGNvbmZpZy5lbmNvZGluZykpO1xuXHRcdFx0XHRpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcblx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0aWYgKHBhcnNlT25Xcml0ZSkge1xuXHRcdFx0XHRwYXJzZU9uV3JpdGUgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fbmV4dENodW5rKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoaXMuX29uUmVhZCA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRpZiAodGhpcy5faGFuZGxlLnBhdXNlZCgpKSB7XG5cdFx0XHRcdC8vIHRoZSB3cml0ZWFibGUgY29uc3VtZXIgY2FuIGhhbmRsZSBtb3JlIGRhdGFcblx0XHRcdFx0Ly8gc28gcmVzdW1lIHRoZSBjaHVuayBwYXJzaW5nXG5cdFx0XHRcdHRoaXMuX2hhbmRsZS5yZXN1bWUoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy5fb25Xcml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spXG5cdFx0e1xuXHRcdFx0dGhpcy5fYWRkVG9QYXJzZVF1ZXVlKGNodW5rLCBjYWxsYmFjayk7XG5cdFx0fTtcblxuXHRcdHRoaXMuX29uV3JpdGVDb21wbGV0ZSA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHR3cml0ZVN0cmVhbUhhc0ZpbmlzaGVkID0gdHJ1ZTtcblx0XHRcdC8vIGhhdmUgdG8gd3JpdGUgZW1wdHkgc3RyaW5nXG5cdFx0XHQvLyBzbyBwYXJzZXIga25vd3MgaXRzIGRvbmVcblx0XHRcdHRoaXMuX2FkZFRvUGFyc2VRdWV1ZSgnJyk7XG5cdFx0fTtcblxuXHRcdHRoaXMuZ2V0U3RyZWFtID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiBzdHJlYW07XG5cdFx0fTtcblx0XHRzdHJlYW0gPSBuZXcgRHVwbGV4KHtcblx0XHRcdHJlYWRhYmxlT2JqZWN0TW9kZTogdHJ1ZSxcblx0XHRcdGRlY29kZVN0cmluZ3M6IGZhbHNlLFxuXHRcdFx0cmVhZDogYmluZEZ1bmN0aW9uKHRoaXMuX29uUmVhZCwgdGhpcyksXG5cdFx0XHR3cml0ZTogYmluZEZ1bmN0aW9uKHRoaXMuX29uV3JpdGUsIHRoaXMpXG5cdFx0fSk7XG5cdFx0c3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGJpbmRGdW5jdGlvbih0aGlzLl9vbldyaXRlQ29tcGxldGUsIHRoaXMpKTtcblx0fVxuXHRpZiAodHlwZW9mIFBBUEFfQlJPV1NFUl9DT05URVhUID09PSAndW5kZWZpbmVkJykge1xuXHRcdER1cGxleFN0cmVhbVN0cmVhbWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2h1bmtTdHJlYW1lci5wcm90b3R5cGUpO1xuXHRcdER1cGxleFN0cmVhbVN0cmVhbWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IER1cGxleFN0cmVhbVN0cmVhbWVyO1xuXHR9XG5cblxuXHQvLyBVc2Ugb25lIFBhcnNlckhhbmRsZSBwZXIgZW50aXJlIENTViBmaWxlIG9yIHN0cmluZ1xuXHRmdW5jdGlvbiBQYXJzZXJIYW5kbGUoX2NvbmZpZylcblx0e1xuXHRcdC8vIE9uZSBnb2FsIGlzIHRvIG1pbmltaXplIHRoZSB1c2Ugb2YgcmVndWxhciBleHByZXNzaW9ucy4uLlxuXHRcdHZhciBNQVhfRkxPQVQgPSBNYXRoLnBvdygyLCA1Myk7XG5cdFx0dmFyIE1JTl9GTE9BVCA9IC1NQVhfRkxPQVQ7XG5cdFx0dmFyIEZMT0FUID0gL15cXHMqLT8oXFxkK1xcLj98XFwuXFxkK3xcXGQrXFwuXFxkKykoW2VFXVstK10/XFxkKyk/XFxzKiQvO1xuXHRcdHZhciBJU09fREFURSA9IC9eKChcXGR7NH0tWzAxXVxcZC1bMC0zXVxcZFRbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZFxcLlxcZCsoWystXVswLTJdXFxkOlswLTVdXFxkfFopKXwoXFxkezR9LVswMV1cXGQtWzAtM11cXGRUWzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGQoWystXVswLTJdXFxkOlswLTVdXFxkfFopKXwoXFxkezR9LVswMV1cXGQtWzAtM11cXGRUWzAtMl1cXGQ6WzAtNV1cXGQoWystXVswLTJdXFxkOlswLTVdXFxkfFopKSkkLztcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIF9zdGVwQ291bnRlciA9IDA7XHQvLyBOdW1iZXIgb2YgdGltZXMgc3RlcCB3YXMgY2FsbGVkIChudW1iZXIgb2Ygcm93cyBwYXJzZWQpXG5cdFx0dmFyIF9yb3dDb3VudGVyID0gMDtcdC8vIE51bWJlciBvZiByb3dzIHRoYXQgaGF2ZSBiZWVuIHBhcnNlZCBzbyBmYXJcblx0XHR2YXIgX2lucHV0O1x0XHRcdFx0Ly8gVGhlIGlucHV0IGJlaW5nIHBhcnNlZFxuXHRcdHZhciBfcGFyc2VyO1x0XHRcdC8vIFRoZSBjb3JlIHBhcnNlciBiZWluZyB1c2VkXG5cdFx0dmFyIF9wYXVzZWQgPSBmYWxzZTtcdC8vIFdoZXRoZXIgd2UgYXJlIHBhdXNlZCBvciBub3Rcblx0XHR2YXIgX2Fib3J0ZWQgPSBmYWxzZTtcdC8vIFdoZXRoZXIgdGhlIHBhcnNlciBoYXMgYWJvcnRlZCBvciBub3Rcblx0XHR2YXIgX2RlbGltaXRlckVycm9yO1x0Ly8gVGVtcG9yYXJ5IHN0YXRlIGJldHdlZW4gZGVsaW1pdGVyIGRldGVjdGlvbiBhbmQgcHJvY2Vzc2luZyByZXN1bHRzXG5cdFx0dmFyIF9maWVsZHMgPSBbXTtcdFx0Ly8gRmllbGRzIGFyZSBmcm9tIHRoZSBoZWFkZXIgcm93IG9mIHRoZSBpbnB1dCwgaWYgdGhlcmUgaXMgb25lXG5cdFx0dmFyIF9yZXN1bHRzID0ge1x0XHQvLyBUaGUgbGFzdCByZXN1bHRzIHJldHVybmVkIGZyb20gdGhlIHBhcnNlclxuXHRcdFx0ZGF0YTogW10sXG5cdFx0XHRlcnJvcnM6IFtdLFxuXHRcdFx0bWV0YToge31cblx0XHR9O1xuXG5cdFx0aWYgKGlzRnVuY3Rpb24oX2NvbmZpZy5zdGVwKSlcblx0XHR7XG5cdFx0XHR2YXIgdXNlclN0ZXAgPSBfY29uZmlnLnN0ZXA7XG5cdFx0XHRfY29uZmlnLnN0ZXAgPSBmdW5jdGlvbihyZXN1bHRzKVxuXHRcdFx0e1xuXHRcdFx0XHRfcmVzdWx0cyA9IHJlc3VsdHM7XG5cblx0XHRcdFx0aWYgKG5lZWRzSGVhZGVyUm93KCkpXG5cdFx0XHRcdFx0cHJvY2Vzc1Jlc3VsdHMoKTtcblx0XHRcdFx0ZWxzZVx0Ly8gb25seSBjYWxsIHVzZXIncyBzdGVwIGZ1bmN0aW9uIGFmdGVyIGhlYWRlciByb3dcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHByb2Nlc3NSZXN1bHRzKCk7XG5cblx0XHRcdFx0XHQvLyBJdCdzIHBvc3NiaWxlIHRoYXQgdGhpcyBsaW5lIHdhcyBlbXB0eSBhbmQgdGhlcmUncyBubyByb3cgaGVyZSBhZnRlciBhbGxcblx0XHRcdFx0XHRpZiAoX3Jlc3VsdHMuZGF0YS5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHRfc3RlcENvdW50ZXIgKz0gcmVzdWx0cy5kYXRhLmxlbmd0aDtcblx0XHRcdFx0XHRpZiAoX2NvbmZpZy5wcmV2aWV3ICYmIF9zdGVwQ291bnRlciA+IF9jb25maWcucHJldmlldylcblx0XHRcdFx0XHRcdF9wYXJzZXIuYWJvcnQoKTtcblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdF9yZXN1bHRzLmRhdGEgPSBfcmVzdWx0cy5kYXRhWzBdO1xuXHRcdFx0XHRcdFx0dXNlclN0ZXAoX3Jlc3VsdHMsIHNlbGYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBQYXJzZXMgaW5wdXQuIE1vc3QgdXNlcnMgd29uJ3QgbmVlZCwgYW5kIHNob3VsZG4ndCBtZXNzIHdpdGgsIHRoZSBiYXNlSW5kZXhcblx0XHQgKiBhbmQgaWdub3JlTGFzdFJvdyBwYXJhbWV0ZXJzLiBUaGV5IGFyZSB1c2VkIGJ5IHN0cmVhbWVycyAod3JhcHBlciBmdW5jdGlvbnMpXG5cdFx0ICogd2hlbiBhbiBpbnB1dCBjb21lcyBpbiBtdWx0aXBsZSBjaHVua3MsIGxpa2UgZnJvbSBhIGZpbGUuXG5cdFx0ICovXG5cdFx0dGhpcy5wYXJzZSA9IGZ1bmN0aW9uKGlucHV0LCBiYXNlSW5kZXgsIGlnbm9yZUxhc3RSb3cpXG5cdFx0e1xuXHRcdFx0dmFyIHF1b3RlQ2hhciA9IF9jb25maWcucXVvdGVDaGFyIHx8ICdcIic7XG5cdFx0XHRpZiAoIV9jb25maWcubmV3bGluZSlcblx0XHRcdFx0X2NvbmZpZy5uZXdsaW5lID0gdGhpcy5ndWVzc0xpbmVFbmRpbmdzKGlucHV0LCBxdW90ZUNoYXIpO1xuXG5cdFx0XHRfZGVsaW1pdGVyRXJyb3IgPSBmYWxzZTtcblx0XHRcdGlmICghX2NvbmZpZy5kZWxpbWl0ZXIpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBkZWxpbUd1ZXNzID0gZ3Vlc3NEZWxpbWl0ZXIoaW5wdXQsIF9jb25maWcubmV3bGluZSwgX2NvbmZpZy5za2lwRW1wdHlMaW5lcywgX2NvbmZpZy5jb21tZW50cywgX2NvbmZpZy5kZWxpbWl0ZXJzVG9HdWVzcyk7XG5cdFx0XHRcdGlmIChkZWxpbUd1ZXNzLnN1Y2Nlc3NmdWwpXG5cdFx0XHRcdFx0X2NvbmZpZy5kZWxpbWl0ZXIgPSBkZWxpbUd1ZXNzLmJlc3REZWxpbWl0ZXI7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdF9kZWxpbWl0ZXJFcnJvciA9IHRydWU7XHQvLyBhZGQgZXJyb3IgYWZ0ZXIgcGFyc2luZyAob3RoZXJ3aXNlIGl0IHdvdWxkIGJlIG92ZXJ3cml0dGVuKVxuXHRcdFx0XHRcdF9jb25maWcuZGVsaW1pdGVyID0gUGFwYS5EZWZhdWx0RGVsaW1pdGVyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9yZXN1bHRzLm1ldGEuZGVsaW1pdGVyID0gX2NvbmZpZy5kZWxpbWl0ZXI7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKGlzRnVuY3Rpb24oX2NvbmZpZy5kZWxpbWl0ZXIpKVxuXHRcdFx0e1xuXHRcdFx0XHRfY29uZmlnLmRlbGltaXRlciA9IF9jb25maWcuZGVsaW1pdGVyKGlucHV0KTtcblx0XHRcdFx0X3Jlc3VsdHMubWV0YS5kZWxpbWl0ZXIgPSBfY29uZmlnLmRlbGltaXRlcjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHBhcnNlckNvbmZpZyA9IGNvcHkoX2NvbmZpZyk7XG5cdFx0XHRpZiAoX2NvbmZpZy5wcmV2aWV3ICYmIF9jb25maWcuaGVhZGVyKVxuXHRcdFx0XHRwYXJzZXJDb25maWcucHJldmlldysrO1x0Ly8gdG8gY29tcGVuc2F0ZSBmb3IgaGVhZGVyIHJvd1xuXG5cdFx0XHRfaW5wdXQgPSBpbnB1dDtcblx0XHRcdF9wYXJzZXIgPSBuZXcgUGFyc2VyKHBhcnNlckNvbmZpZyk7XG5cdFx0XHRfcmVzdWx0cyA9IF9wYXJzZXIucGFyc2UoX2lucHV0LCBiYXNlSW5kZXgsIGlnbm9yZUxhc3RSb3cpO1xuXHRcdFx0cHJvY2Vzc1Jlc3VsdHMoKTtcblx0XHRcdHJldHVybiBfcGF1c2VkID8geyBtZXRhOiB7IHBhdXNlZDogdHJ1ZSB9IH0gOiAoX3Jlc3VsdHMgfHwgeyBtZXRhOiB7IHBhdXNlZDogZmFsc2UgfSB9KTtcblx0XHR9O1xuXG5cdFx0dGhpcy5wYXVzZWQgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIF9wYXVzZWQ7XG5cdFx0fTtcblxuXHRcdHRoaXMucGF1c2UgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0X3BhdXNlZCA9IHRydWU7XG5cdFx0XHRfcGFyc2VyLmFib3J0KCk7XG5cblx0XHRcdC8vIElmIGl0IGlzIHN0cmVhbWluZyB2aWEgXCJjaHVua2luZ1wiLCB0aGUgcmVhZGVyIHdpbGwgc3RhcnQgYXBwZW5kaW5nIGNvcnJlY3RseSBhbHJlYWR5IHNvIG5vIG5lZWQgdG8gc3Vic3RyaW5nLFxuXHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIGNhbiBnZXQgZHVwbGljYXRlIGNvbnRlbnQgd2l0aGluIGEgcm93XG5cdFx0XHRfaW5wdXQgPSBpc0Z1bmN0aW9uKF9jb25maWcuY2h1bmspID8gXCJcIiA6IF9pbnB1dC5zdWJzdHJpbmcoX3BhcnNlci5nZXRDaGFySW5kZXgoKSk7XG5cdFx0fTtcblxuXHRcdHRoaXMucmVzdW1lID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdGlmKHNlbGYuc3RyZWFtZXIuX2hhbHRlZCkge1xuXHRcdFx0XHRfcGF1c2VkID0gZmFsc2U7XG5cdFx0XHRcdHNlbGYuc3RyZWFtZXIucGFyc2VDaHVuayhfaW5wdXQsIHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gQnVnZml4OiAjNjM2IEluIGNhc2UgdGhlIHByb2Nlc3NpbmcgaGFzbid0IGhhbHRlZCB5ZXRcblx0XHRcdFx0Ly8gd2FpdCBmb3IgaXQgdG8gaGFsdCBpbiBvcmRlciB0byByZXN1bWVcblx0XHRcdFx0c2V0VGltZW91dChzZWxmLnJlc3VtZSwgMyk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHRoaXMuYWJvcnRlZCA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRyZXR1cm4gX2Fib3J0ZWQ7XG5cdFx0fTtcblxuXHRcdHRoaXMuYWJvcnQgPSBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0X2Fib3J0ZWQgPSB0cnVlO1xuXHRcdFx0X3BhcnNlci5hYm9ydCgpO1xuXHRcdFx0X3Jlc3VsdHMubWV0YS5hYm9ydGVkID0gdHJ1ZTtcblx0XHRcdGlmIChpc0Z1bmN0aW9uKF9jb25maWcuY29tcGxldGUpKVxuXHRcdFx0XHRfY29uZmlnLmNvbXBsZXRlKF9yZXN1bHRzKTtcblx0XHRcdF9pbnB1dCA9ICcnO1xuXHRcdH07XG5cblx0XHR0aGlzLmd1ZXNzTGluZUVuZGluZ3MgPSBmdW5jdGlvbihpbnB1dCwgcXVvdGVDaGFyKVxuXHRcdHtcblx0XHRcdGlucHV0ID0gaW5wdXQuc3Vic3RyaW5nKDAsIDEwMjQgKiAxMDI0KTtcdC8vIG1heCBsZW5ndGggMSBNQlxuXHRcdFx0Ly8gUmVwbGFjZSBhbGwgdGhlIHRleHQgaW5zaWRlIHF1b3Rlc1xuXHRcdFx0dmFyIHJlID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAocXVvdGVDaGFyKSArICcoW15dKj8pJyArIGVzY2FwZVJlZ0V4cChxdW90ZUNoYXIpLCAnZ20nKTtcblx0XHRcdGlucHV0ID0gaW5wdXQucmVwbGFjZShyZSwgJycpO1xuXG5cdFx0XHR2YXIgciA9IGlucHV0LnNwbGl0KCdcXHInKTtcblxuXHRcdFx0dmFyIG4gPSBpbnB1dC5zcGxpdCgnXFxuJyk7XG5cblx0XHRcdHZhciBuQXBwZWFyc0ZpcnN0ID0gKG4ubGVuZ3RoID4gMSAmJiBuWzBdLmxlbmd0aCA8IHJbMF0ubGVuZ3RoKTtcblxuXHRcdFx0aWYgKHIubGVuZ3RoID09PSAxIHx8IG5BcHBlYXJzRmlyc3QpXG5cdFx0XHRcdHJldHVybiAnXFxuJztcblxuXHRcdFx0dmFyIG51bVdpdGhOID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKylcblx0XHRcdHtcblx0XHRcdFx0aWYgKHJbaV1bMF0gPT09ICdcXG4nKVxuXHRcdFx0XHRcdG51bVdpdGhOKys7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudW1XaXRoTiA+PSByLmxlbmd0aCAvIDIgPyAnXFxyXFxuJyA6ICdcXHInO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB0ZXN0RW1wdHlMaW5lKHMpIHtcblx0XHRcdHJldHVybiBfY29uZmlnLnNraXBFbXB0eUxpbmVzID09PSAnZ3JlZWR5JyA/IHMuam9pbignJykudHJpbSgpID09PSAnJyA6IHMubGVuZ3RoID09PSAxICYmIHNbMF0ubGVuZ3RoID09PSAwO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRlc3RGbG9hdChzKSB7XG5cdFx0XHRpZiAoRkxPQVQudGVzdChzKSkge1xuXHRcdFx0XHR2YXIgZmxvYXRWYWx1ZSA9IHBhcnNlRmxvYXQocyk7XG5cdFx0XHRcdGlmIChmbG9hdFZhbHVlID4gTUlOX0ZMT0FUICYmIGZsb2F0VmFsdWUgPCBNQVhfRkxPQVQpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NSZXN1bHRzKClcblx0XHR7XG5cdFx0XHRpZiAoX3Jlc3VsdHMgJiYgX2RlbGltaXRlckVycm9yKVxuXHRcdFx0e1xuXHRcdFx0XHRhZGRFcnJvcignRGVsaW1pdGVyJywgJ1VuZGV0ZWN0YWJsZURlbGltaXRlcicsICdVbmFibGUgdG8gYXV0by1kZXRlY3QgZGVsaW1pdGluZyBjaGFyYWN0ZXI7IGRlZmF1bHRlZCB0byBcXCcnICsgUGFwYS5EZWZhdWx0RGVsaW1pdGVyICsgJ1xcJycpO1xuXHRcdFx0XHRfZGVsaW1pdGVyRXJyb3IgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKF9jb25maWcuc2tpcEVtcHR5TGluZXMpXG5cdFx0XHR7XG5cdFx0XHRcdF9yZXN1bHRzLmRhdGEgPSBfcmVzdWx0cy5kYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7XG5cdFx0XHRcdFx0cmV0dXJuICF0ZXN0RW1wdHlMaW5lKGQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG5lZWRzSGVhZGVyUm93KCkpXG5cdFx0XHRcdGZpbGxIZWFkZXJGaWVsZHMoKTtcblxuXHRcdFx0cmV0dXJuIGFwcGx5SGVhZGVyQW5kRHluYW1pY1R5cGluZ0FuZFRyYW5zZm9ybWF0aW9uKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbmVlZHNIZWFkZXJSb3coKVxuXHRcdHtcblx0XHRcdHJldHVybiBfY29uZmlnLmhlYWRlciAmJiBfZmllbGRzLmxlbmd0aCA9PT0gMDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmaWxsSGVhZGVyRmllbGRzKClcblx0XHR7XG5cdFx0XHRpZiAoIV9yZXN1bHRzKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdGZ1bmN0aW9uIGFkZEhlYWRlcihoZWFkZXIsIGkpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChpc0Z1bmN0aW9uKF9jb25maWcudHJhbnNmb3JtSGVhZGVyKSlcblx0XHRcdFx0XHRoZWFkZXIgPSBfY29uZmlnLnRyYW5zZm9ybUhlYWRlcihoZWFkZXIsIGkpO1xuXG5cdFx0XHRcdF9maWVsZHMucHVzaChoZWFkZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShfcmVzdWx0cy5kYXRhWzBdKSlcblx0XHRcdHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IG5lZWRzSGVhZGVyUm93KCkgJiYgaSA8IF9yZXN1bHRzLmRhdGEubGVuZ3RoOyBpKyspXG5cdFx0XHRcdFx0X3Jlc3VsdHMuZGF0YVtpXS5mb3JFYWNoKGFkZEhlYWRlcik7XG5cblx0XHRcdFx0X3Jlc3VsdHMuZGF0YS5zcGxpY2UoMCwgMSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiBfcmVzdWx0cy5kYXRhWzBdIGlzIG5vdCBhbiBhcnJheSwgd2UgYXJlIGluIGEgc3RlcCB3aGVyZSBfcmVzdWx0cy5kYXRhIGlzIHRoZSByb3cuXG5cdFx0XHRlbHNlXG5cdFx0XHRcdF9yZXN1bHRzLmRhdGEuZm9yRWFjaChhZGRIZWFkZXIpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHNob3VsZEFwcGx5RHluYW1pY1R5cGluZyhmaWVsZCkge1xuXHRcdFx0Ly8gQ2FjaGUgZnVuY3Rpb24gdmFsdWVzIHRvIGF2b2lkIGNhbGxpbmcgaXQgZm9yIGVhY2ggcm93XG5cdFx0XHRpZiAoX2NvbmZpZy5keW5hbWljVHlwaW5nRnVuY3Rpb24gJiYgX2NvbmZpZy5keW5hbWljVHlwaW5nW2ZpZWxkXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdF9jb25maWcuZHluYW1pY1R5cGluZ1tmaWVsZF0gPSBfY29uZmlnLmR5bmFtaWNUeXBpbmdGdW5jdGlvbihmaWVsZCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKF9jb25maWcuZHluYW1pY1R5cGluZ1tmaWVsZF0gfHwgX2NvbmZpZy5keW5hbWljVHlwaW5nKSA9PT0gdHJ1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUR5bmFtaWMoZmllbGQsIHZhbHVlKVxuXHRcdHtcblx0XHRcdGlmIChzaG91bGRBcHBseUR5bmFtaWNUeXBpbmcoZmllbGQpKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAodmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gJ1RSVUUnKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRlbHNlIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJyB8fCB2YWx1ZSA9PT0gJ0ZBTFNFJylcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGVsc2UgaWYgKHRlc3RGbG9hdCh2YWx1ZSkpXG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuXHRcdFx0XHRlbHNlIGlmIChJU09fREFURS50ZXN0KHZhbHVlKSlcblx0XHRcdFx0XHRyZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0cmV0dXJuICh2YWx1ZSA9PT0gJycgPyBudWxsIDogdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFwcGx5SGVhZGVyQW5kRHluYW1pY1R5cGluZ0FuZFRyYW5zZm9ybWF0aW9uKClcblx0XHR7XG5cdFx0XHRpZiAoIV9yZXN1bHRzIHx8ICghX2NvbmZpZy5oZWFkZXIgJiYgIV9jb25maWcuZHluYW1pY1R5cGluZyAmJiAhX2NvbmZpZy50cmFuc2Zvcm0pKVxuXHRcdFx0XHRyZXR1cm4gX3Jlc3VsdHM7XG5cblx0XHRcdGZ1bmN0aW9uIHByb2Nlc3NSb3cocm93U291cmNlLCBpKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgcm93ID0gX2NvbmZpZy5oZWFkZXIgPyB7fSA6IFtdO1xuXG5cdFx0XHRcdHZhciBqO1xuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgcm93U291cmNlLmxlbmd0aDsgaisrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFyIGZpZWxkID0gajtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSByb3dTb3VyY2Vbal07XG5cblx0XHRcdFx0XHRpZiAoX2NvbmZpZy5oZWFkZXIpXG5cdFx0XHRcdFx0XHRmaWVsZCA9IGogPj0gX2ZpZWxkcy5sZW5ndGggPyAnX19wYXJzZWRfZXh0cmEnIDogX2ZpZWxkc1tqXTtcblxuXHRcdFx0XHRcdGlmIChfY29uZmlnLnRyYW5zZm9ybSlcblx0XHRcdFx0XHRcdHZhbHVlID0gX2NvbmZpZy50cmFuc2Zvcm0odmFsdWUsZmllbGQpO1xuXG5cdFx0XHRcdFx0dmFsdWUgPSBwYXJzZUR5bmFtaWMoZmllbGQsIHZhbHVlKTtcblxuXHRcdFx0XHRcdGlmIChmaWVsZCA9PT0gJ19fcGFyc2VkX2V4dHJhJylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRyb3dbZmllbGRdID0gcm93W2ZpZWxkXSB8fCBbXTtcblx0XHRcdFx0XHRcdHJvd1tmaWVsZF0ucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHJvd1tmaWVsZF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0aWYgKF9jb25maWcuaGVhZGVyKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGogPiBfZmllbGRzLmxlbmd0aClcblx0XHRcdFx0XHRcdGFkZEVycm9yKCdGaWVsZE1pc21hdGNoJywgJ1Rvb01hbnlGaWVsZHMnLCAnVG9vIG1hbnkgZmllbGRzOiBleHBlY3RlZCAnICsgX2ZpZWxkcy5sZW5ndGggKyAnIGZpZWxkcyBidXQgcGFyc2VkICcgKyBqLCBfcm93Q291bnRlciArIGkpO1xuXHRcdFx0XHRcdGVsc2UgaWYgKGogPCBfZmllbGRzLmxlbmd0aClcblx0XHRcdFx0XHRcdGFkZEVycm9yKCdGaWVsZE1pc21hdGNoJywgJ1Rvb0Zld0ZpZWxkcycsICdUb28gZmV3IGZpZWxkczogZXhwZWN0ZWQgJyArIF9maWVsZHMubGVuZ3RoICsgJyBmaWVsZHMgYnV0IHBhcnNlZCAnICsgaiwgX3Jvd0NvdW50ZXIgKyBpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiByb3c7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBpbmNyZW1lbnRCeSA9IDE7XG5cdFx0XHRpZiAoIV9yZXN1bHRzLmRhdGEubGVuZ3RoIHx8IEFycmF5LmlzQXJyYXkoX3Jlc3VsdHMuZGF0YVswXSkpXG5cdFx0XHR7XG5cdFx0XHRcdF9yZXN1bHRzLmRhdGEgPSBfcmVzdWx0cy5kYXRhLm1hcChwcm9jZXNzUm93KTtcblx0XHRcdFx0aW5jcmVtZW50QnkgPSBfcmVzdWx0cy5kYXRhLmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdFx0X3Jlc3VsdHMuZGF0YSA9IHByb2Nlc3NSb3coX3Jlc3VsdHMuZGF0YSwgMCk7XG5cblxuXHRcdFx0aWYgKF9jb25maWcuaGVhZGVyICYmIF9yZXN1bHRzLm1ldGEpXG5cdFx0XHRcdF9yZXN1bHRzLm1ldGEuZmllbGRzID0gX2ZpZWxkcztcblxuXHRcdFx0X3Jvd0NvdW50ZXIgKz0gaW5jcmVtZW50Qnk7XG5cdFx0XHRyZXR1cm4gX3Jlc3VsdHM7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ3Vlc3NEZWxpbWl0ZXIoaW5wdXQsIG5ld2xpbmUsIHNraXBFbXB0eUxpbmVzLCBjb21tZW50cywgZGVsaW1pdGVyc1RvR3Vlc3MpIHtcblx0XHRcdHZhciBiZXN0RGVsaW0sIGJlc3REZWx0YSwgZmllbGRDb3VudFByZXZSb3csIG1heEZpZWxkQ291bnQ7XG5cblx0XHRcdGRlbGltaXRlcnNUb0d1ZXNzID0gZGVsaW1pdGVyc1RvR3Vlc3MgfHwgWycsJywgJ1xcdCcsICd8JywgJzsnLCBQYXBhLlJFQ09SRF9TRVAsIFBhcGEuVU5JVF9TRVBdO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRlbGltaXRlcnNUb0d1ZXNzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBkZWxpbSA9IGRlbGltaXRlcnNUb0d1ZXNzW2ldO1xuXHRcdFx0XHR2YXIgZGVsdGEgPSAwLCBhdmdGaWVsZENvdW50ID0gMCwgZW1wdHlMaW5lc0NvdW50ID0gMDtcblx0XHRcdFx0ZmllbGRDb3VudFByZXZSb3cgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0dmFyIHByZXZpZXcgPSBuZXcgUGFyc2VyKHtcblx0XHRcdFx0XHRjb21tZW50czogY29tbWVudHMsXG5cdFx0XHRcdFx0ZGVsaW1pdGVyOiBkZWxpbSxcblx0XHRcdFx0XHRuZXdsaW5lOiBuZXdsaW5lLFxuXHRcdFx0XHRcdHByZXZpZXc6IDEwXG5cdFx0XHRcdH0pLnBhcnNlKGlucHV0KTtcblxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHByZXZpZXcuZGF0YS5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGlmIChza2lwRW1wdHlMaW5lcyAmJiB0ZXN0RW1wdHlMaW5lKHByZXZpZXcuZGF0YVtqXSkpIHtcblx0XHRcdFx0XHRcdGVtcHR5TGluZXNDb3VudCsrO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciBmaWVsZENvdW50ID0gcHJldmlldy5kYXRhW2pdLmxlbmd0aDtcblx0XHRcdFx0XHRhdmdGaWVsZENvdW50ICs9IGZpZWxkQ291bnQ7XG5cblx0XHRcdFx0XHRpZiAodHlwZW9mIGZpZWxkQ291bnRQcmV2Um93ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdFx0ZmllbGRDb3VudFByZXZSb3cgPSBmaWVsZENvdW50O1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKGZpZWxkQ291bnQgPiAwKSB7XG5cdFx0XHRcdFx0XHRkZWx0YSArPSBNYXRoLmFicyhmaWVsZENvdW50IC0gZmllbGRDb3VudFByZXZSb3cpO1xuXHRcdFx0XHRcdFx0ZmllbGRDb3VudFByZXZSb3cgPSBmaWVsZENvdW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChwcmV2aWV3LmRhdGEubGVuZ3RoID4gMClcblx0XHRcdFx0XHRhdmdGaWVsZENvdW50IC89IChwcmV2aWV3LmRhdGEubGVuZ3RoIC0gZW1wdHlMaW5lc0NvdW50KTtcblxuXHRcdFx0XHRpZiAoKHR5cGVvZiBiZXN0RGVsdGEgPT09ICd1bmRlZmluZWQnIHx8IGRlbHRhIDw9IGJlc3REZWx0YSlcblx0XHRcdFx0XHQmJiAodHlwZW9mIG1heEZpZWxkQ291bnQgPT09ICd1bmRlZmluZWQnIHx8IGF2Z0ZpZWxkQ291bnQgPiBtYXhGaWVsZENvdW50KSAmJiBhdmdGaWVsZENvdW50ID4gMS45OSkge1xuXHRcdFx0XHRcdGJlc3REZWx0YSA9IGRlbHRhO1xuXHRcdFx0XHRcdGJlc3REZWxpbSA9IGRlbGltO1xuXHRcdFx0XHRcdG1heEZpZWxkQ291bnQgPSBhdmdGaWVsZENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdF9jb25maWcuZGVsaW1pdGVyID0gYmVzdERlbGltO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzdWNjZXNzZnVsOiAhIWJlc3REZWxpbSxcblx0XHRcdFx0YmVzdERlbGltaXRlcjogYmVzdERlbGltXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZEVycm9yKHR5cGUsIGNvZGUsIG1zZywgcm93KVxuXHRcdHtcblx0XHRcdHZhciBlcnJvciA9IHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0Y29kZTogY29kZSxcblx0XHRcdFx0bWVzc2FnZTogbXNnXG5cdFx0XHR9O1xuXHRcdFx0aWYocm93ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZXJyb3Iucm93ID0gcm93O1xuXHRcdFx0fVxuXHRcdFx0X3Jlc3VsdHMuZXJyb3JzLnB1c2goZXJyb3IpO1xuXHRcdH1cblx0fVxuXG5cdC8qKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0d1aWRlL1JlZ3VsYXJfRXhwcmVzc2lvbnMgKi9cblx0ZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZylcblx0e1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTsgLy8gJCYgbWVhbnMgdGhlIHdob2xlIG1hdGNoZWQgc3RyaW5nXG5cdH1cblxuXHQvKiogVGhlIGNvcmUgcGFyc2VyIGltcGxlbWVudHMgc3BlZWR5IGFuZCBjb3JyZWN0IENTViBwYXJzaW5nICovXG5cdGZ1bmN0aW9uIFBhcnNlcihjb25maWcpXG5cdHtcblx0XHQvLyBVbnBhY2sgdGhlIGNvbmZpZyBvYmplY3Rcblx0XHRjb25maWcgPSBjb25maWcgfHwge307XG5cdFx0dmFyIGRlbGltID0gY29uZmlnLmRlbGltaXRlcjtcblx0XHR2YXIgbmV3bGluZSA9IGNvbmZpZy5uZXdsaW5lO1xuXHRcdHZhciBjb21tZW50cyA9IGNvbmZpZy5jb21tZW50cztcblx0XHR2YXIgc3RlcCA9IGNvbmZpZy5zdGVwO1xuXHRcdHZhciBwcmV2aWV3ID0gY29uZmlnLnByZXZpZXc7XG5cdFx0dmFyIGZhc3RNb2RlID0gY29uZmlnLmZhc3RNb2RlO1xuXHRcdHZhciBxdW90ZUNoYXI7XG5cdFx0dmFyIHJlbmFtZWRIZWFkZXJzID0gbnVsbDtcblx0XHR2YXIgaGVhZGVyUGFyc2VkID0gZmFsc2U7XG5cblx0XHRpZiAoY29uZmlnLnF1b3RlQ2hhciA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5xdW90ZUNoYXIgPT09IG51bGwpIHtcblx0XHRcdHF1b3RlQ2hhciA9ICdcIic7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHF1b3RlQ2hhciA9IGNvbmZpZy5xdW90ZUNoYXI7XG5cdFx0fVxuXHRcdHZhciBlc2NhcGVDaGFyID0gcXVvdGVDaGFyO1xuXHRcdGlmIChjb25maWcuZXNjYXBlQ2hhciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRlc2NhcGVDaGFyID0gY29uZmlnLmVzY2FwZUNoYXI7XG5cdFx0fVxuXG5cdFx0Ly8gRGVsaW1pdGVyIG11c3QgYmUgdmFsaWRcblx0XHRpZiAodHlwZW9mIGRlbGltICE9PSAnc3RyaW5nJ1xuXHRcdFx0fHwgUGFwYS5CQURfREVMSU1JVEVSUy5pbmRleE9mKGRlbGltKSA+IC0xKVxuXHRcdFx0ZGVsaW0gPSAnLCc7XG5cblx0XHQvLyBDb21tZW50IGNoYXJhY3RlciBtdXN0IGJlIHZhbGlkXG5cdFx0aWYgKGNvbW1lbnRzID09PSBkZWxpbSlcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ29tbWVudCBjaGFyYWN0ZXIgc2FtZSBhcyBkZWxpbWl0ZXInKTtcblx0XHRlbHNlIGlmIChjb21tZW50cyA9PT0gdHJ1ZSlcblx0XHRcdGNvbW1lbnRzID0gJyMnO1xuXHRcdGVsc2UgaWYgKHR5cGVvZiBjb21tZW50cyAhPT0gJ3N0cmluZydcblx0XHRcdHx8IFBhcGEuQkFEX0RFTElNSVRFUlMuaW5kZXhPZihjb21tZW50cykgPiAtMSlcblx0XHRcdGNvbW1lbnRzID0gZmFsc2U7XG5cblx0XHQvLyBOZXdsaW5lIG11c3QgYmUgdmFsaWQ6IFxcciwgXFxuLCBvciBcXHJcXG5cblx0XHRpZiAobmV3bGluZSAhPT0gJ1xcbicgJiYgbmV3bGluZSAhPT0gJ1xccicgJiYgbmV3bGluZSAhPT0gJ1xcclxcbicpXG5cdFx0XHRuZXdsaW5lID0gJ1xcbic7XG5cblx0XHQvLyBXZSdyZSBnb25uYSBuZWVkIHRoZXNlIGF0IHRoZSBQYXJzZXIgc2NvcGVcblx0XHR2YXIgY3Vyc29yID0gMDtcblx0XHR2YXIgYWJvcnRlZCA9IGZhbHNlO1xuXG5cdFx0dGhpcy5wYXJzZSA9IGZ1bmN0aW9uKGlucHV0LCBiYXNlSW5kZXgsIGlnbm9yZUxhc3RSb3cpXG5cdFx0e1xuXHRcdFx0Ly8gRm9yIHNvbWUgcmVhc29uLCBpbiBDaHJvbWUsIHRoaXMgc3BlZWRzIHRoaW5ncyB1cCAoIT8pXG5cdFx0XHRpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJylcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnB1dCBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cblx0XHRcdC8vIFdlIGRvbid0IG5lZWQgdG8gY29tcHV0ZSBzb21lIG9mIHRoZXNlIGV2ZXJ5IHRpbWUgcGFyc2UoKSBpcyBjYWxsZWQsXG5cdFx0XHQvLyBidXQgaGF2aW5nIHRoZW0gaW4gYSBtb3JlIGxvY2FsIHNjb3BlIHNlZW1zIHRvIHBlcmZvcm0gYmV0dGVyXG5cdFx0XHR2YXIgaW5wdXRMZW4gPSBpbnB1dC5sZW5ndGgsXG5cdFx0XHRcdGRlbGltTGVuID0gZGVsaW0ubGVuZ3RoLFxuXHRcdFx0XHRuZXdsaW5lTGVuID0gbmV3bGluZS5sZW5ndGgsXG5cdFx0XHRcdGNvbW1lbnRzTGVuID0gY29tbWVudHMubGVuZ3RoO1xuXHRcdFx0dmFyIHN0ZXBJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbihzdGVwKTtcblxuXHRcdFx0Ly8gRXN0YWJsaXNoIHN0YXJ0aW5nIHN0YXRlXG5cdFx0XHRjdXJzb3IgPSAwO1xuXHRcdFx0dmFyIGRhdGEgPSBbXSwgZXJyb3JzID0gW10sIHJvdyA9IFtdLCBsYXN0Q3Vyc29yID0gMDtcblxuXHRcdFx0aWYgKCFpbnB1dClcblx0XHRcdFx0cmV0dXJuIHJldHVybmFibGUoKTtcblxuXHRcdFx0aWYgKGZhc3RNb2RlIHx8IChmYXN0TW9kZSAhPT0gZmFsc2UgJiYgaW5wdXQuaW5kZXhPZihxdW90ZUNoYXIpID09PSAtMSkpXG5cdFx0XHR7XG5cdFx0XHRcdHZhciByb3dzID0gaW5wdXQuc3BsaXQobmV3bGluZSk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJvdyA9IHJvd3NbaV07XG5cdFx0XHRcdFx0Y3Vyc29yICs9IHJvdy5sZW5ndGg7XG5cblx0XHRcdFx0XHRpZiAoaSAhPT0gcm93cy5sZW5ndGggLSAxKVxuXHRcdFx0XHRcdFx0Y3Vyc29yICs9IG5ld2xpbmUubGVuZ3RoO1xuXHRcdFx0XHRcdGVsc2UgaWYgKGlnbm9yZUxhc3RSb3cpXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmV0dXJuYWJsZSgpO1xuXHRcdFx0XHRcdGlmIChjb21tZW50cyAmJiByb3cuc3Vic3RyaW5nKDAsIGNvbW1lbnRzTGVuKSA9PT0gY29tbWVudHMpXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRpZiAoc3RlcElzRnVuY3Rpb24pXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZGF0YSA9IFtdO1xuXHRcdFx0XHRcdFx0cHVzaFJvdyhyb3cuc3BsaXQoZGVsaW0pKTtcblx0XHRcdFx0XHRcdGRvU3RlcCgpO1xuXHRcdFx0XHRcdFx0aWYgKGFib3J0ZWQpXG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXR1cm5hYmxlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHB1c2hSb3cocm93LnNwbGl0KGRlbGltKSk7XG5cdFx0XHRcdFx0aWYgKHByZXZpZXcgJiYgaSA+PSBwcmV2aWV3KVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhLnNsaWNlKDAsIHByZXZpZXcpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJldHVybmFibGUodHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXR1cm5hYmxlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBuZXh0RGVsaW0gPSBpbnB1dC5pbmRleE9mKGRlbGltLCBjdXJzb3IpO1xuXHRcdFx0dmFyIG5leHROZXdsaW5lID0gaW5wdXQuaW5kZXhPZihuZXdsaW5lLCBjdXJzb3IpO1xuXHRcdFx0dmFyIHF1b3RlQ2hhclJlZ2V4ID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAoZXNjYXBlQ2hhcikgKyBlc2NhcGVSZWdFeHAocXVvdGVDaGFyKSwgJ2cnKTtcblx0XHRcdHZhciBxdW90ZVNlYXJjaCA9IGlucHV0LmluZGV4T2YocXVvdGVDaGFyLCBjdXJzb3IpO1xuXG5cdFx0XHQvLyBQYXJzZXIgbG9vcFxuXHRcdFx0Zm9yICg7Oylcblx0XHRcdHtcblx0XHRcdFx0Ly8gRmllbGQgaGFzIG9wZW5pbmcgcXVvdGVcblx0XHRcdFx0aWYgKGlucHV0W2N1cnNvcl0gPT09IHF1b3RlQ2hhcilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8vIFN0YXJ0IG91ciBzZWFyY2ggZm9yIHRoZSBjbG9zaW5nIHF1b3RlIHdoZXJlIHRoZSBjdXJzb3IgaXNcblx0XHRcdFx0XHRxdW90ZVNlYXJjaCA9IGN1cnNvcjtcblxuXHRcdFx0XHRcdC8vIFNraXAgdGhlIG9wZW5pbmcgcXVvdGVcblx0XHRcdFx0XHRjdXJzb3IrKztcblxuXHRcdFx0XHRcdGZvciAoOzspXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Ly8gRmluZCBjbG9zaW5nIHF1b3RlXG5cdFx0XHRcdFx0XHRxdW90ZVNlYXJjaCA9IGlucHV0LmluZGV4T2YocXVvdGVDaGFyLCBxdW90ZVNlYXJjaCArIDEpO1xuXG5cdFx0XHRcdFx0XHQvL05vIG90aGVyIHF1b3RlcyBhcmUgZm91bmQgLSBubyBvdGhlciBkZWxpbWl0ZXJzXG5cdFx0XHRcdFx0XHRpZiAocXVvdGVTZWFyY2ggPT09IC0xKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRpZiAoIWlnbm9yZUxhc3RSb3cpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBObyBjbG9zaW5nIHF1b3RlLi4uIHdoYXQgYSBwaXR5XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3JzLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogJ1F1b3RlcycsXG5cdFx0XHRcdFx0XHRcdFx0XHRjb2RlOiAnTWlzc2luZ1F1b3RlcycsXG5cdFx0XHRcdFx0XHRcdFx0XHRtZXNzYWdlOiAnUXVvdGVkIGZpZWxkIHVudGVybWluYXRlZCcsXG5cdFx0XHRcdFx0XHRcdFx0XHRyb3c6IGRhdGEubGVuZ3RoLFx0Ly8gcm93IGhhcyB5ZXQgdG8gYmUgaW5zZXJ0ZWRcblx0XHRcdFx0XHRcdFx0XHRcdGluZGV4OiBjdXJzb3Jcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmluaXNoKCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIENsb3NpbmcgcXVvdGUgYXQgRU9GXG5cdFx0XHRcdFx0XHRpZiAocXVvdGVTZWFyY2ggPT09IGlucHV0TGVuIC0gMSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gaW5wdXQuc3Vic3RyaW5nKGN1cnNvciwgcXVvdGVTZWFyY2gpLnJlcGxhY2UocXVvdGVDaGFyUmVnZXgsIHF1b3RlQ2hhcik7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmaW5pc2godmFsdWUpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGlzIHF1b3RlIGlzIGVzY2FwZWQsIGl0J3MgcGFydCBvZiB0aGUgZGF0YTsgc2tpcCBpdFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHF1b3RlIGNoYXJhY3RlciBpcyB0aGUgZXNjYXBlIGNoYXJhY3RlciwgdGhlbiBjaGVjayBpZiB0aGUgbmV4dCBjaGFyYWN0ZXIgaXMgdGhlIGVzY2FwZSBjaGFyYWN0ZXJcblx0XHRcdFx0XHRcdGlmIChxdW90ZUNoYXIgPT09IGVzY2FwZUNoYXIgJiYgIGlucHV0W3F1b3RlU2VhcmNoICsgMV0gPT09IGVzY2FwZUNoYXIpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHF1b3RlU2VhcmNoKys7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcXVvdGUgY2hhcmFjdGVyIGlzIG5vdCB0aGUgZXNjYXBlIGNoYXJhY3RlciwgdGhlbiBjaGVjayBpZiB0aGUgcHJldmlvdXMgY2hhcmFjdGVyIHdhcyB0aGUgZXNjYXBlIGNoYXJhY3RlclxuXHRcdFx0XHRcdFx0aWYgKHF1b3RlQ2hhciAhPT0gZXNjYXBlQ2hhciAmJiBxdW90ZVNlYXJjaCAhPT0gMCAmJiBpbnB1dFtxdW90ZVNlYXJjaCAtIDFdID09PSBlc2NhcGVDaGFyKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYobmV4dERlbGltICE9PSAtMSAmJiBuZXh0RGVsaW0gPCAocXVvdGVTZWFyY2ggKyAxKSkge1xuXHRcdFx0XHRcdFx0XHRuZXh0RGVsaW0gPSBpbnB1dC5pbmRleE9mKGRlbGltLCAocXVvdGVTZWFyY2ggKyAxKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihuZXh0TmV3bGluZSAhPT0gLTEgJiYgbmV4dE5ld2xpbmUgPCAocXVvdGVTZWFyY2ggKyAxKSkge1xuXHRcdFx0XHRcdFx0XHRuZXh0TmV3bGluZSA9IGlucHV0LmluZGV4T2YobmV3bGluZSwgKHF1b3RlU2VhcmNoICsgMSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgdXAgdG8gbmV4dERlbGltIG9yIG5leHROZXdsaW5lLCB3aGljaGV2ZXIgaXMgY2xvc2VzdFxuXHRcdFx0XHRcdFx0dmFyIGNoZWNrVXBUbyA9IG5leHROZXdsaW5lID09PSAtMSA/IG5leHREZWxpbSA6IE1hdGgubWluKG5leHREZWxpbSwgbmV4dE5ld2xpbmUpO1xuXHRcdFx0XHRcdFx0dmFyIHNwYWNlc0JldHdlZW5RdW90ZUFuZERlbGltaXRlciA9IGV4dHJhU3BhY2VzKGNoZWNrVXBUbyk7XG5cblx0XHRcdFx0XHRcdC8vIENsb3NpbmcgcXVvdGUgZm9sbG93ZWQgYnkgZGVsaW1pdGVyIG9yICd1bm5lY2Vzc2FyeSBzcGFjZXMgKyBkZWxpbWl0ZXInXG5cdFx0XHRcdFx0XHRpZiAoaW5wdXQuc3Vic3RyKHF1b3RlU2VhcmNoICsgMSArIHNwYWNlc0JldHdlZW5RdW90ZUFuZERlbGltaXRlciwgZGVsaW1MZW4pID09PSBkZWxpbSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cm93LnB1c2goaW5wdXQuc3Vic3RyaW5nKGN1cnNvciwgcXVvdGVTZWFyY2gpLnJlcGxhY2UocXVvdGVDaGFyUmVnZXgsIHF1b3RlQ2hhcikpO1xuXHRcdFx0XHRcdFx0XHRjdXJzb3IgPSBxdW90ZVNlYXJjaCArIDEgKyBzcGFjZXNCZXR3ZWVuUXVvdGVBbmREZWxpbWl0ZXIgKyBkZWxpbUxlbjtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBjaGFyIGFmdGVyIGZvbGxvd2luZyBkZWxpbWl0ZXIgaXMgbm90IHF1b3RlQ2hhciwgd2UgZmluZCBuZXh0IHF1b3RlIGNoYXIgcG9zaXRpb25cblx0XHRcdFx0XHRcdFx0aWYgKGlucHV0W3F1b3RlU2VhcmNoICsgMSArIHNwYWNlc0JldHdlZW5RdW90ZUFuZERlbGltaXRlciArIGRlbGltTGVuXSAhPT0gcXVvdGVDaGFyKVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0cXVvdGVTZWFyY2ggPSBpbnB1dC5pbmRleE9mKHF1b3RlQ2hhciwgY3Vyc29yKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRuZXh0RGVsaW0gPSBpbnB1dC5pbmRleE9mKGRlbGltLCBjdXJzb3IpO1xuXHRcdFx0XHRcdFx0XHRuZXh0TmV3bGluZSA9IGlucHV0LmluZGV4T2YobmV3bGluZSwgY3Vyc29yKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciBzcGFjZXNCZXR3ZWVuUXVvdGVBbmROZXdMaW5lID0gZXh0cmFTcGFjZXMobmV4dE5ld2xpbmUpO1xuXG5cdFx0XHRcdFx0XHQvLyBDbG9zaW5nIHF1b3RlIGZvbGxvd2VkIGJ5IG5ld2xpbmUgb3IgJ3VubmVjZXNzYXJ5IHNwYWNlcyArIG5ld0xpbmUnXG5cdFx0XHRcdFx0XHRpZiAoaW5wdXQuc3Vic3RyaW5nKHF1b3RlU2VhcmNoICsgMSArIHNwYWNlc0JldHdlZW5RdW90ZUFuZE5ld0xpbmUsIHF1b3RlU2VhcmNoICsgMSArIHNwYWNlc0JldHdlZW5RdW90ZUFuZE5ld0xpbmUgKyBuZXdsaW5lTGVuKSA9PT0gbmV3bGluZSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cm93LnB1c2goaW5wdXQuc3Vic3RyaW5nKGN1cnNvciwgcXVvdGVTZWFyY2gpLnJlcGxhY2UocXVvdGVDaGFyUmVnZXgsIHF1b3RlQ2hhcikpO1xuXHRcdFx0XHRcdFx0XHRzYXZlUm93KHF1b3RlU2VhcmNoICsgMSArIHNwYWNlc0JldHdlZW5RdW90ZUFuZE5ld0xpbmUgKyBuZXdsaW5lTGVuKTtcblx0XHRcdFx0XHRcdFx0bmV4dERlbGltID0gaW5wdXQuaW5kZXhPZihkZWxpbSwgY3Vyc29yKTtcdC8vIGJlY2F1c2Ugd2UgbWF5IGhhdmUgc2tpcHBlZCB0aGUgbmV4dERlbGltIGluIHRoZSBxdW90ZWQgZmllbGRcblx0XHRcdFx0XHRcdFx0cXVvdGVTZWFyY2ggPSBpbnB1dC5pbmRleE9mKHF1b3RlQ2hhciwgY3Vyc29yKTtcdC8vIHdlIHNlYXJjaCBmb3IgZmlyc3QgcXVvdGUgaW4gbmV4dCBsaW5lXG5cblx0XHRcdFx0XHRcdFx0aWYgKHN0ZXBJc0Z1bmN0aW9uKVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0ZG9TdGVwKCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGFib3J0ZWQpXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmV0dXJuYWJsZSgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKHByZXZpZXcgJiYgZGF0YS5sZW5ndGggPj0gcHJldmlldylcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmV0dXJuYWJsZSh0cnVlKTtcblxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdFx0XHQvLyBDaGVja3MgZm9yIHZhbGlkIGNsb3NpbmcgcXVvdGVzIGFyZSBjb21wbGV0ZSAoZXNjYXBlZCBxdW90ZXMgb3IgcXVvdGUgZm9sbG93ZWQgYnkgRU9GL2RlbGltaXRlci9uZXdsaW5lKSAtLSBhc3N1bWUgdGhlc2UgcXVvdGVzIGFyZSBwYXJ0IG9mIGFuIGludmFsaWQgdGV4dCBzdHJpbmdcblx0XHRcdFx0XHRcdGVycm9ycy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0dHlwZTogJ1F1b3RlcycsXG5cdFx0XHRcdFx0XHRcdGNvZGU6ICdJbnZhbGlkUXVvdGVzJyxcblx0XHRcdFx0XHRcdFx0bWVzc2FnZTogJ1RyYWlsaW5nIHF1b3RlIG9uIHF1b3RlZCBmaWVsZCBpcyBtYWxmb3JtZWQnLFxuXHRcdFx0XHRcdFx0XHRyb3c6IGRhdGEubGVuZ3RoLFx0Ly8gcm93IGhhcyB5ZXQgdG8gYmUgaW5zZXJ0ZWRcblx0XHRcdFx0XHRcdFx0aW5kZXg6IGN1cnNvclxuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdHF1b3RlU2VhcmNoKys7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ29tbWVudCBmb3VuZCBhdCBzdGFydCBvZiBuZXcgbGluZVxuXHRcdFx0XHRpZiAoY29tbWVudHMgJiYgcm93Lmxlbmd0aCA9PT0gMCAmJiBpbnB1dC5zdWJzdHJpbmcoY3Vyc29yLCBjdXJzb3IgKyBjb21tZW50c0xlbikgPT09IGNvbW1lbnRzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKG5leHROZXdsaW5lID09PSAtMSlcdC8vIENvbW1lbnQgZW5kcyBhdCBFT0Zcblx0XHRcdFx0XHRcdHJldHVybiByZXR1cm5hYmxlKCk7XG5cdFx0XHRcdFx0Y3Vyc29yID0gbmV4dE5ld2xpbmUgKyBuZXdsaW5lTGVuO1xuXHRcdFx0XHRcdG5leHROZXdsaW5lID0gaW5wdXQuaW5kZXhPZihuZXdsaW5lLCBjdXJzb3IpO1xuXHRcdFx0XHRcdG5leHREZWxpbSA9IGlucHV0LmluZGV4T2YoZGVsaW0sIGN1cnNvcik7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBOZXh0IGRlbGltaXRlciBjb21lcyBiZWZvcmUgbmV4dCBuZXdsaW5lLCBzbyB3ZSd2ZSByZWFjaGVkIGVuZCBvZiBmaWVsZFxuXHRcdFx0XHRpZiAobmV4dERlbGltICE9PSAtMSAmJiAobmV4dERlbGltIDwgbmV4dE5ld2xpbmUgfHwgbmV4dE5ld2xpbmUgPT09IC0xKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJvdy5wdXNoKGlucHV0LnN1YnN0cmluZyhjdXJzb3IsIG5leHREZWxpbSkpO1xuXHRcdFx0XHRcdGN1cnNvciA9IG5leHREZWxpbSArIGRlbGltTGVuO1xuXHRcdFx0XHRcdC8vIHdlIGxvb2sgZm9yIG5leHQgZGVsaW1pdGVyIGNoYXJcblx0XHRcdFx0XHRuZXh0RGVsaW0gPSBpbnB1dC5pbmRleE9mKGRlbGltLCBjdXJzb3IpO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRW5kIG9mIHJvd1xuXHRcdFx0XHRpZiAobmV4dE5ld2xpbmUgIT09IC0xKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cm93LnB1c2goaW5wdXQuc3Vic3RyaW5nKGN1cnNvciwgbmV4dE5ld2xpbmUpKTtcblx0XHRcdFx0XHRzYXZlUm93KG5leHROZXdsaW5lICsgbmV3bGluZUxlbik7XG5cblx0XHRcdFx0XHRpZiAoc3RlcElzRnVuY3Rpb24pXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZG9TdGVwKCk7XG5cdFx0XHRcdFx0XHRpZiAoYWJvcnRlZClcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJldHVybmFibGUoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAocHJldmlldyAmJiBkYXRhLmxlbmd0aCA+PSBwcmV2aWV3KVxuXHRcdFx0XHRcdFx0cmV0dXJuIHJldHVybmFibGUodHJ1ZSk7XG5cblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmluaXNoKCk7XG5cblxuXHRcdFx0ZnVuY3Rpb24gcHVzaFJvdyhyb3cpXG5cdFx0XHR7XG5cdFx0XHRcdGRhdGEucHVzaChyb3cpO1xuXHRcdFx0XHRsYXN0Q3Vyc29yID0gY3Vyc29yO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcbiAgICAgICAgICAgICAqIGNoZWNrcyBpZiB0aGVyZSBhcmUgZXh0cmEgc3BhY2VzIGFmdGVyIGNsb3NpbmcgcXVvdGUgYW5kIGdpdmVuIGluZGV4IHdpdGhvdXQgYW55IHRleHRcbiAgICAgICAgICAgICAqIGlmIFllcywgcmV0dXJucyB0aGUgbnVtYmVyIG9mIHNwYWNlc1xuICAgICAgICAgICAgICovXG5cdFx0XHRmdW5jdGlvbiBleHRyYVNwYWNlcyhpbmRleCkge1xuXHRcdFx0XHR2YXIgc3BhY2VMZW5ndGggPSAwO1xuXHRcdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdFx0dmFyIHRleHRCZXR3ZWVuQ2xvc2luZ1F1b3RlQW5kSW5kZXggPSBpbnB1dC5zdWJzdHJpbmcocXVvdGVTZWFyY2ggKyAxLCBpbmRleCk7XG5cdFx0XHRcdFx0aWYgKHRleHRCZXR3ZWVuQ2xvc2luZ1F1b3RlQW5kSW5kZXggJiYgdGV4dEJldHdlZW5DbG9zaW5nUXVvdGVBbmRJbmRleC50cmltKCkgPT09ICcnKSB7XG5cdFx0XHRcdFx0XHRzcGFjZUxlbmd0aCA9IHRleHRCZXR3ZWVuQ2xvc2luZ1F1b3RlQW5kSW5kZXgubGVuZ3RoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc3BhY2VMZW5ndGg7XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQXBwZW5kcyB0aGUgcmVtYWluaW5nIGlucHV0IGZyb20gY3Vyc29yIHRvIHRoZSBlbmQgaW50b1xuXHRcdFx0ICogcm93LCBzYXZlcyB0aGUgcm93LCBjYWxscyBzdGVwLCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cy5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gZmluaXNoKHZhbHVlKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoaWdub3JlTGFzdFJvdylcblx0XHRcdFx0XHRyZXR1cm4gcmV0dXJuYWJsZSgpO1xuXHRcdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJylcblx0XHRcdFx0XHR2YWx1ZSA9IGlucHV0LnN1YnN0cmluZyhjdXJzb3IpO1xuXHRcdFx0XHRyb3cucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdGN1cnNvciA9IGlucHV0TGVuO1x0Ly8gaW1wb3J0YW50IGluIGNhc2UgcGFyc2luZyBpcyBwYXVzZWRcblx0XHRcdFx0cHVzaFJvdyhyb3cpO1xuXHRcdFx0XHRpZiAoc3RlcElzRnVuY3Rpb24pXG5cdFx0XHRcdFx0ZG9TdGVwKCk7XG5cdFx0XHRcdHJldHVybiByZXR1cm5hYmxlKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQXBwZW5kcyB0aGUgY3VycmVudCByb3cgdG8gdGhlIHJlc3VsdHMuIEl0IHNldHMgdGhlIGN1cnNvclxuXHRcdFx0ICogdG8gbmV3Q3Vyc29yIGFuZCBmaW5kcyB0aGUgbmV4dE5ld2xpbmUuIFRoZSBjYWxsZXIgc2hvdWxkXG5cdFx0XHQgKiB0YWtlIGNhcmUgdG8gZXhlY3V0ZSB1c2VyJ3Mgc3RlcCBmdW5jdGlvbiBhbmQgY2hlY2sgZm9yXG5cdFx0XHQgKiBwcmV2aWV3IGFuZCBlbmQgcGFyc2luZyBpZiBuZWNlc3NhcnkuXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHNhdmVSb3cobmV3Q3Vyc29yKVxuXHRcdFx0e1xuXHRcdFx0XHRjdXJzb3IgPSBuZXdDdXJzb3I7XG5cdFx0XHRcdHB1c2hSb3cocm93KTtcblx0XHRcdFx0cm93ID0gW107XG5cdFx0XHRcdG5leHROZXdsaW5lID0gaW5wdXQuaW5kZXhPZihuZXdsaW5lLCBjdXJzb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgcmVzdWx0cywgZXJyb3JzLCBhbmQgbWV0YS4gKi9cblx0XHRcdGZ1bmN0aW9uIHJldHVybmFibGUoc3RvcHBlZClcblx0XHRcdHtcblx0XHRcdFx0aWYgKGNvbmZpZy5oZWFkZXIgJiYgIWJhc2VJbmRleCAmJiBkYXRhLmxlbmd0aCAmJiAhaGVhZGVyUGFyc2VkKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgcmVzdWx0ID0gZGF0YVswXTtcblx0XHRcdFx0XHRjb25zdCBoZWFkZXJDb3VudCA9IE9iamVjdC5jcmVhdGUobnVsbCk7IC8vIFRvIHRyYWNrIHRoZSBjb3VudCBvZiBlYWNoIGJhc2UgaGVhZGVyXG5cdFx0XHRcdFx0Y29uc3QgdXNlZEhlYWRlcnMgPSBuZXcgU2V0KHJlc3VsdCk7IC8vIFRvIHRyYWNrIHVzZWQgaGVhZGVycyBhbmQgYXZvaWQgZHVwbGljYXRlc1xuXHRcdFx0XHRcdGxldCBkdXBsaWNhdGVIZWFkZXJzID0gZmFsc2U7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0bGV0IGhlYWRlciA9IHJlc3VsdFtpXTtcblx0XHRcdFx0XHRcdGlmIChpc0Z1bmN0aW9uKGNvbmZpZy50cmFuc2Zvcm1IZWFkZXIpKVxuXHRcdFx0XHRcdFx0XHRoZWFkZXIgPSBjb25maWcudHJhbnNmb3JtSGVhZGVyKGhlYWRlciwgaSk7XG5cblx0XHRcdFx0XHRcdGlmICghaGVhZGVyQ291bnRbaGVhZGVyXSkge1xuXHRcdFx0XHRcdFx0XHRoZWFkZXJDb3VudFtoZWFkZXJdID0gMTtcblx0XHRcdFx0XHRcdFx0cmVzdWx0W2ldID0gaGVhZGVyO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGV0IG5ld0hlYWRlcjtcblx0XHRcdFx0XHRcdFx0bGV0IHN1ZmZpeENvdW50ID0gaGVhZGVyQ291bnRbaGVhZGVyXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBGaW5kIGEgdW5pcXVlIG5ldyBoZWFkZXJcblx0XHRcdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0XHRcdG5ld0hlYWRlciA9IGAke2hlYWRlcn1fJHtzdWZmaXhDb3VudH1gO1xuXHRcdFx0XHRcdFx0XHRcdHN1ZmZpeENvdW50Kys7XG5cdFx0XHRcdFx0XHRcdH0gd2hpbGUgKHVzZWRIZWFkZXJzLmhhcyhuZXdIZWFkZXIpKTtcblxuXHRcdFx0XHRcdFx0XHR1c2VkSGVhZGVycy5hZGQobmV3SGVhZGVyKTsgLy8gTWFyayB0aGlzIG5ldyBIZWFkZXIgYXMgdXNlZFxuXHRcdFx0XHRcdFx0XHRyZXN1bHRbaV0gPSBuZXdIZWFkZXI7XG5cdFx0XHRcdFx0XHRcdGhlYWRlckNvdW50W2hlYWRlcl0rKztcblx0XHRcdFx0XHRcdFx0ZHVwbGljYXRlSGVhZGVycyA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGlmIChyZW5hbWVkSGVhZGVycyA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdHJlbmFtZWRIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmVuYW1lZEhlYWRlcnNbbmV3SGVhZGVyXSA9IGhlYWRlcjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dXNlZEhlYWRlcnMuYWRkKGhlYWRlcik7IC8vIEVuc3VyZSB0aGUgb3JpZ2luYWwgaGVhZGVyIGlzIG1hcmtlZCBhcyB1c2VkXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChkdXBsaWNhdGVIZWFkZXJzKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ0R1cGxpY2F0ZSBoZWFkZXJzIGZvdW5kIGFuZCByZW5hbWVkLicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRoZWFkZXJQYXJzZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0XHRlcnJvcnM6IGVycm9ycyxcblx0XHRcdFx0XHRtZXRhOiB7XG5cdFx0XHRcdFx0XHRkZWxpbWl0ZXI6IGRlbGltLFxuXHRcdFx0XHRcdFx0bGluZWJyZWFrOiBuZXdsaW5lLFxuXHRcdFx0XHRcdFx0YWJvcnRlZDogYWJvcnRlZCxcblx0XHRcdFx0XHRcdHRydW5jYXRlZDogISFzdG9wcGVkLFxuXHRcdFx0XHRcdFx0Y3Vyc29yOiBsYXN0Q3Vyc29yICsgKGJhc2VJbmRleCB8fCAwKSxcblx0XHRcdFx0XHRcdHJlbmFtZWRIZWFkZXJzOiByZW5hbWVkSGVhZGVyc1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0LyoqIEV4ZWN1dGVzIHRoZSB1c2VyJ3Mgc3RlcCBmdW5jdGlvbiBhbmQgcmVzZXRzIGRhdGEgJiBlcnJvcnMuICovXG5cdFx0XHRmdW5jdGlvbiBkb1N0ZXAoKVxuXHRcdFx0e1xuXHRcdFx0XHRzdGVwKHJldHVybmFibGUoKSk7XG5cdFx0XHRcdGRhdGEgPSBbXTtcblx0XHRcdFx0ZXJyb3JzID0gW107XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKiBTZXRzIHRoZSBhYm9ydCBmbGFnICovXG5cdFx0dGhpcy5hYm9ydCA9IGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHRhYm9ydGVkID0gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0LyoqIEdldHMgdGhlIGN1cnNvciBwb3NpdGlvbiAqL1xuXHRcdHRoaXMuZ2V0Q2hhckluZGV4ID0gZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdHJldHVybiBjdXJzb3I7XG5cdFx0fTtcblx0fVxuXG5cblx0ZnVuY3Rpb24gbmV3V29ya2VyKClcblx0e1xuXHRcdGlmICghUGFwYS5XT1JLRVJTX1NVUFBPUlRFRClcblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdHZhciB3b3JrZXJVcmwgPSBnZXRXb3JrZXJCbG9iKCk7XG5cdFx0dmFyIHcgPSBuZXcgZ2xvYmFsLldvcmtlcih3b3JrZXJVcmwpO1xuXHRcdHcub25tZXNzYWdlID0gbWFpblRocmVhZFJlY2VpdmVkTWVzc2FnZTtcblx0XHR3LmlkID0gd29ya2VySWRDb3VudGVyKys7XG5cdFx0d29ya2Vyc1t3LmlkXSA9IHc7XG5cdFx0cmV0dXJuIHc7XG5cdH1cblxuXHQvKiogQ2FsbGJhY2sgd2hlbiBtYWluIHRocmVhZCByZWNlaXZlcyBhIG1lc3NhZ2UgKi9cblx0ZnVuY3Rpb24gbWFpblRocmVhZFJlY2VpdmVkTWVzc2FnZShlKVxuXHR7XG5cdFx0dmFyIG1zZyA9IGUuZGF0YTtcblx0XHR2YXIgd29ya2VyID0gd29ya2Vyc1ttc2cud29ya2VySWRdO1xuXHRcdHZhciBhYm9ydGVkID0gZmFsc2U7XG5cblx0XHRpZiAobXNnLmVycm9yKVxuXHRcdFx0d29ya2VyLnVzZXJFcnJvcihtc2cuZXJyb3IsIG1zZy5maWxlKTtcblx0XHRlbHNlIGlmIChtc2cucmVzdWx0cyAmJiBtc2cucmVzdWx0cy5kYXRhKVxuXHRcdHtcblx0XHRcdHZhciBhYm9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRhYm9ydGVkID0gdHJ1ZTtcblx0XHRcdFx0Y29tcGxldGVXb3JrZXIobXNnLndvcmtlcklkLCB7IGRhdGE6IFtdLCBlcnJvcnM6IFtdLCBtZXRhOiB7IGFib3J0ZWQ6IHRydWUgfSB9KTtcblx0XHRcdH07XG5cblx0XHRcdHZhciBoYW5kbGUgPSB7XG5cdFx0XHRcdGFib3J0OiBhYm9ydCxcblx0XHRcdFx0cGF1c2U6IG5vdEltcGxlbWVudGVkLFxuXHRcdFx0XHRyZXN1bWU6IG5vdEltcGxlbWVudGVkXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoaXNGdW5jdGlvbih3b3JrZXIudXNlclN0ZXApKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5yZXN1bHRzLmRhdGEubGVuZ3RoOyBpKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR3b3JrZXIudXNlclN0ZXAoe1xuXHRcdFx0XHRcdFx0ZGF0YTogbXNnLnJlc3VsdHMuZGF0YVtpXSxcblx0XHRcdFx0XHRcdGVycm9yczogbXNnLnJlc3VsdHMuZXJyb3JzLFxuXHRcdFx0XHRcdFx0bWV0YTogbXNnLnJlc3VsdHMubWV0YVxuXHRcdFx0XHRcdH0sIGhhbmRsZSk7XG5cdFx0XHRcdFx0aWYgKGFib3J0ZWQpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWxldGUgbXNnLnJlc3VsdHM7XHQvLyBmcmVlIG1lbW9yeSBBU0FQXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChpc0Z1bmN0aW9uKHdvcmtlci51c2VyQ2h1bmspKVxuXHRcdFx0e1xuXHRcdFx0XHR3b3JrZXIudXNlckNodW5rKG1zZy5yZXN1bHRzLCBoYW5kbGUsIG1zZy5maWxlKTtcblx0XHRcdFx0ZGVsZXRlIG1zZy5yZXN1bHRzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChtc2cuZmluaXNoZWQgJiYgIWFib3J0ZWQpXG5cdFx0XHRjb21wbGV0ZVdvcmtlcihtc2cud29ya2VySWQsIG1zZy5yZXN1bHRzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXBsZXRlV29ya2VyKHdvcmtlcklkLCByZXN1bHRzKSB7XG5cdFx0dmFyIHdvcmtlciA9IHdvcmtlcnNbd29ya2VySWRdO1xuXHRcdGlmIChpc0Z1bmN0aW9uKHdvcmtlci51c2VyQ29tcGxldGUpKVxuXHRcdFx0d29ya2VyLnVzZXJDb21wbGV0ZShyZXN1bHRzKTtcblx0XHR3b3JrZXIudGVybWluYXRlKCk7XG5cdFx0ZGVsZXRlIHdvcmtlcnNbd29ya2VySWRdO1xuXHR9XG5cblx0ZnVuY3Rpb24gbm90SW1wbGVtZW50ZWQoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQuJyk7XG5cdH1cblxuXHQvKiogQ2FsbGJhY2sgd2hlbiB3b3JrZXIgdGhyZWFkIHJlY2VpdmVzIGEgbWVzc2FnZSAqL1xuXHRmdW5jdGlvbiB3b3JrZXJUaHJlYWRSZWNlaXZlZE1lc3NhZ2UoZSlcblx0e1xuXHRcdHZhciBtc2cgPSBlLmRhdGE7XG5cblx0XHRpZiAodHlwZW9mIFBhcGEuV09SS0VSX0lEID09PSAndW5kZWZpbmVkJyAmJiBtc2cpXG5cdFx0XHRQYXBhLldPUktFUl9JRCA9IG1zZy53b3JrZXJJZDtcblxuXHRcdGlmICh0eXBlb2YgbXNnLmlucHV0ID09PSAnc3RyaW5nJylcblx0XHR7XG5cdFx0XHRnbG9iYWwucG9zdE1lc3NhZ2Uoe1xuXHRcdFx0XHR3b3JrZXJJZDogUGFwYS5XT1JLRVJfSUQsXG5cdFx0XHRcdHJlc3VsdHM6IFBhcGEucGFyc2UobXNnLmlucHV0LCBtc2cuY29uZmlnKSxcblx0XHRcdFx0ZmluaXNoZWQ6IHRydWVcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoZ2xvYmFsLkZpbGUgJiYgbXNnLmlucHV0IGluc3RhbmNlb2YgRmlsZSkgfHwgbXNnLmlucHV0IGluc3RhbmNlb2YgT2JqZWN0KVx0Ly8gdGhhbmsgeW91LCBTYWZhcmkgKHNlZSBpc3N1ZSAjMTA2KVxuXHRcdHtcblx0XHRcdHZhciByZXN1bHRzID0gUGFwYS5wYXJzZShtc2cuaW5wdXQsIG1zZy5jb25maWcpO1xuXHRcdFx0aWYgKHJlc3VsdHMpXG5cdFx0XHRcdGdsb2JhbC5wb3N0TWVzc2FnZSh7XG5cdFx0XHRcdFx0d29ya2VySWQ6IFBhcGEuV09SS0VSX0lELFxuXHRcdFx0XHRcdHJlc3VsdHM6IHJlc3VsdHMsXG5cdFx0XHRcdFx0ZmluaXNoZWQ6IHRydWVcblx0XHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqIE1ha2VzIGEgZGVlcCBjb3B5IG9mIGFuIGFycmF5IG9yIG9iamVjdCAobW9zdGx5KSAqL1xuXHRmdW5jdGlvbiBjb3B5KG9iailcblx0e1xuXHRcdGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpXG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdHZhciBjcHkgPSBBcnJheS5pc0FycmF5KG9iaikgPyBbXSA6IHt9O1xuXHRcdGZvciAodmFyIGtleSBpbiBvYmopXG5cdFx0XHRjcHlba2V5XSA9IGNvcHkob2JqW2tleV0pO1xuXHRcdHJldHVybiBjcHk7XG5cdH1cblxuXHRmdW5jdGlvbiBiaW5kRnVuY3Rpb24oZiwgc2VsZilcblx0e1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHsgZi5hcHBseShzZWxmLCBhcmd1bWVudHMpOyB9O1xuXHR9XG5cdGZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuYylcblx0e1xuXHRcdHJldHVybiB0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJztcblx0fVxuXG5cdHJldHVybiBQYXBhO1xufSkpO1xuIl0sIm5hbWVzIjpbInJvb3QiLCJmYWN0b3J5IiwiZGVmaW5lIiwiYW1kIiwibW9kdWxlIiwiZXhwb3J0cyIsIlBhcGEiLCJtb2R1bGVGYWN0b3J5IiwiZ2xvYmFsIiwic2VsZiIsIndpbmRvdyIsImdldFdvcmtlckJsb2IiLCJVUkwiLCJ3ZWJraXRVUkwiLCJjb2RlIiwidG9TdHJpbmciLCJCTE9CX1VSTCIsImNyZWF0ZU9iamVjdFVSTCIsIkJsb2IiLCJ0eXBlIiwiSVNfV09SS0VSIiwiZG9jdW1lbnQiLCJwb3N0TWVzc2FnZSIsIklTX1BBUEFfV09SS0VSIiwid29ya2VycyIsIndvcmtlcklkQ291bnRlciIsInBhcnNlIiwiQ3N2VG9Kc29uIiwidW5wYXJzZSIsIkpzb25Ub0NzdiIsIlJFQ09SRF9TRVAiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJVTklUX1NFUCIsIkJZVEVfT1JERVJfTUFSSyIsIkJBRF9ERUxJTUlURVJTIiwiV09SS0VSU19TVVBQT1JURUQiLCJXb3JrZXIiLCJOT0RFX1NUUkVBTV9JTlBVVCIsIkxvY2FsQ2h1bmtTaXplIiwiUmVtb3RlQ2h1bmtTaXplIiwiRGVmYXVsdERlbGltaXRlciIsIlBhcnNlciIsIlBhcnNlckhhbmRsZSIsIk5ldHdvcmtTdHJlYW1lciIsIkZpbGVTdHJlYW1lciIsIlN0cmluZ1N0cmVhbWVyIiwiUmVhZGFibGVTdHJlYW1TdHJlYW1lciIsIlBBUEFfQlJPV1NFUl9DT05URVhUIiwiRHVwbGV4U3RyZWFtU3RyZWFtZXIiLCJqUXVlcnkiLCIkIiwiZm4iLCJvcHRpb25zIiwiY29uZmlnIiwicXVldWUiLCJlYWNoIiwiaWR4Iiwic3VwcG9ydGVkIiwicHJvcCIsInRvVXBwZXJDYXNlIiwiYXR0ciIsInRvTG93ZXJDYXNlIiwiRmlsZVJlYWRlciIsImZpbGVzIiwibGVuZ3RoIiwiaSIsInB1c2giLCJmaWxlIiwiaW5wdXRFbGVtIiwiaW5zdGFuY2VDb25maWciLCJleHRlbmQiLCJwYXJzZU5leHRGaWxlIiwiaXNGdW5jdGlvbiIsImNvbXBsZXRlIiwiZiIsImJlZm9yZSIsInJldHVybmVkIiwiYWN0aW9uIiwiZXJyb3IiLCJyZWFzb24iLCJmaWxlQ29tcGxldGUiLCJ1c2VyQ29tcGxldGVGdW5jIiwicmVzdWx0cyIsIm5hbWUiLCJlbGVtIiwic3BsaWNlIiwib25tZXNzYWdlIiwid29ya2VyVGhyZWFkUmVjZWl2ZWRNZXNzYWdlIiwiX2lucHV0IiwiX2NvbmZpZyIsImR5bmFtaWNUeXBpbmciLCJkeW5hbWljVHlwaW5nRnVuY3Rpb24iLCJ0cmFuc2Zvcm0iLCJ3b3JrZXIiLCJ3IiwibmV3V29ya2VyIiwidXNlclN0ZXAiLCJzdGVwIiwidXNlckNodW5rIiwiY2h1bmsiLCJ1c2VyQ29tcGxldGUiLCJ1c2VyRXJyb3IiLCJpbnB1dCIsIndvcmtlcklkIiwiaWQiLCJzdHJlYW1lciIsImdldFN0cmVhbSIsInN0cmlwQm9tIiwiZG93bmxvYWQiLCJyZWFkYWJsZSIsInJlYWQiLCJvbiIsIkZpbGUiLCJPYmplY3QiLCJzdHJlYW0iLCJzdHJpbmciLCJjaGFyQ29kZUF0Iiwic2xpY2UiLCJfcXVvdGVzIiwiX3dyaXRlSGVhZGVyIiwiX2RlbGltaXRlciIsIl9uZXdsaW5lIiwiX3F1b3RlQ2hhciIsIl9lc2NhcGVkUXVvdGUiLCJfc2tpcEVtcHR5TGluZXMiLCJfY29sdW1ucyIsIl9lc2NhcGVGb3JtdWxhZSIsInVucGFja0NvbmZpZyIsInF1b3RlQ2hhclJlZ2V4IiwiUmVnRXhwIiwiZXNjYXBlUmVnRXhwIiwiSlNPTiIsIkFycmF5IiwiaXNBcnJheSIsInNlcmlhbGl6ZSIsImtleXMiLCJkYXRhIiwiZmllbGRzIiwibWV0YSIsIkVycm9yIiwiZGVsaW1pdGVyIiwiZmlsdGVyIiwidmFsdWUiLCJpbmRleE9mIiwicXVvdGVzIiwic2tpcEVtcHR5TGluZXMiLCJuZXdsaW5lIiwicXVvdGVDaGFyIiwiaGVhZGVyIiwiY29sdW1ucyIsImVzY2FwZUNoYXIiLCJ1bmRlZmluZWQiLCJlc2NhcGVGb3JtdWxhZSIsImNzdiIsImhhc0hlYWRlciIsImRhdGFLZXllZEJ5RmllbGQiLCJzYWZlIiwicm93IiwibWF4Q29sIiwiZW1wdHlMaW5lIiwibnVsbExpbmUiLCJqb2luIiwidHJpbSIsImxpbmUiLCJjIiwiY3giLCJjb2wiLCJjb2xJZHgiLCJzdHIiLCJjb25zdHJ1Y3RvciIsIkRhdGUiLCJzdHJpbmdpZnkiLCJuZWVkc1F1b3RlcyIsInRlc3QiLCJlc2NhcGVkUXVvdGVTdHIiLCJyZXBsYWNlIiwiaGFzQW55IiwiY2hhckF0Iiwic3Vic3RyaW5ncyIsIkNodW5rU3RyZWFtZXIiLCJfaGFuZGxlIiwiX2ZpbmlzaGVkIiwiX2NvbXBsZXRlZCIsIl9oYWx0ZWQiLCJfYmFzZUluZGV4IiwiX3BhcnRpYWxMaW5lIiwiX3Jvd0NvdW50IiwiX3N0YXJ0IiwiX25leHRDaHVuayIsImlzRmlyc3RDaHVuayIsIl9jb21wbGV0ZVJlc3VsdHMiLCJlcnJvcnMiLCJyZXBsYWNlQ29uZmlnIiwiY2FsbCIsInBhcnNlQ2h1bmsiLCJpc0Zha2VDaHVuayIsInNraXBGaXJzdE5MaW5lcyIsInBhcnNlSW50IiwiZ3Vlc3NMaW5lRW5kaW5ncyIsInNwbGl0Q2h1bmsiLCJzcGxpdCIsImJlZm9yZUZpcnN0Q2h1bmsiLCJtb2RpZmllZENodW5rIiwiYWdncmVnYXRlIiwicGF1c2VkIiwiYWJvcnRlZCIsImxhc3RJbmRleCIsImN1cnNvciIsInN1YnN0cmluZyIsImZpbmlzaGVkSW5jbHVkaW5nUHJldmlldyIsInByZXZpZXciLCJXT1JLRVJfSUQiLCJmaW5pc2hlZCIsImNvbmNhdCIsIl9zZW5kRXJyb3IiLCJjb25maWdDb3B5IiwiY29weSIsImNodW5rU2l6ZSIsInhociIsIl9yZWFkQ2h1bmsiLCJfY2h1bmtMb2FkZWQiLCJ1cmwiLCJYTUxIdHRwUmVxdWVzdCIsIndpdGhDcmVkZW50aWFscyIsIm9ubG9hZCIsImJpbmRGdW5jdGlvbiIsIm9uZXJyb3IiLCJfY2h1bmtFcnJvciIsIm9wZW4iLCJkb3dubG9hZFJlcXVlc3RCb2R5IiwiZG93bmxvYWRSZXF1ZXN0SGVhZGVycyIsImhlYWRlcnMiLCJoZWFkZXJOYW1lIiwic2V0UmVxdWVzdEhlYWRlciIsImVuZCIsInNlbmQiLCJlcnIiLCJtZXNzYWdlIiwic3RhdHVzIiwicmVhZHlTdGF0ZSIsInJlc3BvbnNlVGV4dCIsImdldEZpbGVTaXplIiwiZXJyb3JNZXNzYWdlIiwiZXJyb3JUZXh0Iiwic3RhdHVzVGV4dCIsImNvbnRlbnRSYW5nZSIsImdldFJlc3BvbnNlSGVhZGVyIiwibGFzdEluZGV4T2YiLCJwcm90b3R5cGUiLCJjcmVhdGUiLCJyZWFkZXIiLCJ1c2luZ0FzeW5jUmVhZGVyIiwid2Via2l0U2xpY2UiLCJtb3pTbGljZSIsIkZpbGVSZWFkZXJTeW5jIiwiTWF0aCIsIm1pbiIsInNpemUiLCJ0eHQiLCJyZWFkQXNUZXh0IiwiZW5jb2RpbmciLCJ0YXJnZXQiLCJyZXN1bHQiLCJldmVudCIsInJlbWFpbmluZyIsInMiLCJwYXJzZU9uRGF0YSIsInN0cmVhbUhhc0VuZGVkIiwicGF1c2UiLCJhcHBseSIsImFyZ3VtZW50cyIsInJlc3VtZSIsIl9zdHJlYW1EYXRhIiwiX3N0cmVhbUVuZCIsIl9zdHJlYW1FcnJvciIsIl9jaGVja0lzRmluaXNoZWQiLCJzaGlmdCIsIl9zdHJlYW1DbGVhblVwIiwicmVtb3ZlTGlzdGVuZXIiLCJEdXBsZXgiLCJyZXF1aXJlIiwicGFyc2VPbldyaXRlIiwid3JpdGVTdHJlYW1IYXNGaW5pc2hlZCIsInBhcnNlQ2FsbGJhY2tRdWV1ZSIsIl9vbkNzdkRhdGEiLCJfb25Dc3ZDb21wbGV0ZSIsIl9hZGRUb1BhcnNlUXVldWUiLCJjYWxsYmFjayIsIl9vblJlYWQiLCJfb25Xcml0ZSIsIl9vbldyaXRlQ29tcGxldGUiLCJyZWFkYWJsZU9iamVjdE1vZGUiLCJkZWNvZGVTdHJpbmdzIiwid3JpdGUiLCJvbmNlIiwiTUFYX0ZMT0FUIiwicG93IiwiTUlOX0ZMT0FUIiwiRkxPQVQiLCJJU09fREFURSIsIl9zdGVwQ291bnRlciIsIl9yb3dDb3VudGVyIiwiX3BhcnNlciIsIl9wYXVzZWQiLCJfYWJvcnRlZCIsIl9kZWxpbWl0ZXJFcnJvciIsIl9maWVsZHMiLCJfcmVzdWx0cyIsIm5lZWRzSGVhZGVyUm93IiwicHJvY2Vzc1Jlc3VsdHMiLCJhYm9ydCIsImJhc2VJbmRleCIsImlnbm9yZUxhc3RSb3ciLCJkZWxpbUd1ZXNzIiwiZ3Vlc3NEZWxpbWl0ZXIiLCJjb21tZW50cyIsImRlbGltaXRlcnNUb0d1ZXNzIiwic3VjY2Vzc2Z1bCIsImJlc3REZWxpbWl0ZXIiLCJwYXJzZXJDb25maWciLCJnZXRDaGFySW5kZXgiLCJzZXRUaW1lb3V0IiwicmUiLCJyIiwibiIsIm5BcHBlYXJzRmlyc3QiLCJudW1XaXRoTiIsInRlc3RFbXB0eUxpbmUiLCJ0ZXN0RmxvYXQiLCJmbG9hdFZhbHVlIiwicGFyc2VGbG9hdCIsImFkZEVycm9yIiwiZCIsImZpbGxIZWFkZXJGaWVsZHMiLCJhcHBseUhlYWRlckFuZER5bmFtaWNUeXBpbmdBbmRUcmFuc2Zvcm1hdGlvbiIsImFkZEhlYWRlciIsInRyYW5zZm9ybUhlYWRlciIsImZvckVhY2giLCJzaG91bGRBcHBseUR5bmFtaWNUeXBpbmciLCJmaWVsZCIsInBhcnNlRHluYW1pYyIsInByb2Nlc3NSb3ciLCJyb3dTb3VyY2UiLCJqIiwiaW5jcmVtZW50QnkiLCJtYXAiLCJiZXN0RGVsaW0iLCJiZXN0RGVsdGEiLCJmaWVsZENvdW50UHJldlJvdyIsIm1heEZpZWxkQ291bnQiLCJkZWxpbSIsImRlbHRhIiwiYXZnRmllbGRDb3VudCIsImVtcHR5TGluZXNDb3VudCIsImZpZWxkQ291bnQiLCJhYnMiLCJtc2ciLCJmYXN0TW9kZSIsInJlbmFtZWRIZWFkZXJzIiwiaGVhZGVyUGFyc2VkIiwiaW5wdXRMZW4iLCJkZWxpbUxlbiIsIm5ld2xpbmVMZW4iLCJjb21tZW50c0xlbiIsInN0ZXBJc0Z1bmN0aW9uIiwibGFzdEN1cnNvciIsInJldHVybmFibGUiLCJyb3dzIiwicHVzaFJvdyIsImRvU3RlcCIsIm5leHREZWxpbSIsIm5leHROZXdsaW5lIiwicXVvdGVTZWFyY2giLCJpbmRleCIsImZpbmlzaCIsImNoZWNrVXBUbyIsInNwYWNlc0JldHdlZW5RdW90ZUFuZERlbGltaXRlciIsImV4dHJhU3BhY2VzIiwic3Vic3RyIiwic3BhY2VzQmV0d2VlblF1b3RlQW5kTmV3TGluZSIsInNhdmVSb3ciLCJzcGFjZUxlbmd0aCIsInRleHRCZXR3ZWVuQ2xvc2luZ1F1b3RlQW5kSW5kZXgiLCJuZXdDdXJzb3IiLCJzdG9wcGVkIiwiaGVhZGVyQ291bnQiLCJ1c2VkSGVhZGVycyIsIlNldCIsImR1cGxpY2F0ZUhlYWRlcnMiLCJuZXdIZWFkZXIiLCJzdWZmaXhDb3VudCIsImhhcyIsImFkZCIsImNvbnNvbGUiLCJ3YXJuIiwibGluZWJyZWFrIiwidHJ1bmNhdGVkIiwid29ya2VyVXJsIiwibWFpblRocmVhZFJlY2VpdmVkTWVzc2FnZSIsImUiLCJjb21wbGV0ZVdvcmtlciIsImhhbmRsZSIsIm5vdEltcGxlbWVudGVkIiwidGVybWluYXRlIiwib2JqIiwiY3B5Iiwia2V5IiwiZnVuYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/papaparse/papaparse.js\n");

/***/ })

};
;