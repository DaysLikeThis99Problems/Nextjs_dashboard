"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-slider";
exports.ids = ["vendor-chunks/react-slider"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-slider/dist/es/dev/components/ReactSlider/ReactSlider.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/react-slider/dist/es/dev/components/ReactSlider/ReactSlider.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ReactSlider$1)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/extends.js\");\n/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/inheritsLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/inheritsLoose.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n\n\n\n\nvar _jsxFileName = \"/Users/krise/github/react-slider/src/components/ReactSlider/ReactSlider.jsx\";\n/**\n * To prevent text selection while dragging.\n * http://stackoverflow.com/questions/5429827/how-can-i-prevent-text-element-selection-with-cursor-drag\n */ function pauseEvent(e) {\n    if (e && e.stopPropagation) {\n        e.stopPropagation();\n    }\n    if (e && e.preventDefault) {\n        e.preventDefault();\n    }\n    return false;\n}\nfunction stopPropagation(e) {\n    if (e.stopPropagation) {\n        e.stopPropagation();\n    }\n}\nfunction sanitizeInValue(x) {\n    if (x == null) {\n        return [];\n    }\n    return Array.isArray(x) ? x.slice() : [\n        x\n    ];\n}\nfunction prepareOutValue(x) {\n    return x !== null && x.length === 1 ? x[0] : x.slice();\n}\nfunction trimSucceeding(length, nextValue, minDistance, max) {\n    for(let i = 0; i < length; i += 1){\n        const padding = max - i * minDistance;\n        if (nextValue[length - 1 - i] > padding) {\n            // eslint-disable-next-line no-param-reassign\n            nextValue[length - 1 - i] = padding;\n        }\n    }\n}\nfunction trimPreceding(length, nextValue, minDistance, min) {\n    for(let i = 0; i < length; i += 1){\n        const padding = min + i * minDistance;\n        if (nextValue[i] < padding) {\n            // eslint-disable-next-line no-param-reassign\n            nextValue[i] = padding;\n        }\n    }\n}\nfunction addHandlers(eventMap) {\n    Object.keys(eventMap).forEach((key)=>{\n        if (typeof document !== \"undefined\") {\n            document.addEventListener(key, eventMap[key], false);\n        }\n    });\n}\nfunction removeHandlers(eventMap) {\n    Object.keys(eventMap).forEach((key)=>{\n        if (typeof document !== \"undefined\") {\n            document.removeEventListener(key, eventMap[key], false);\n        }\n    });\n}\nfunction trimAlignValue(val, props) {\n    return alignValue(trimValue(val, props), props);\n}\nfunction alignValue(val, props) {\n    const valModStep = (val - props.min) % props.step;\n    let alignedValue = val - valModStep;\n    if (Math.abs(valModStep) * 2 >= props.step) {\n        alignedValue += valModStep > 0 ? props.step : -props.step;\n    }\n    return parseFloat(alignedValue.toFixed(5));\n}\nfunction trimValue(val, props) {\n    let trimmed = val;\n    if (trimmed <= props.min) {\n        trimmed = props.min;\n    }\n    if (trimmed >= props.max) {\n        trimmed = props.max;\n    }\n    return trimmed;\n}\nlet ReactSlider = /*#__PURE__*/ function(_React$Component) {\n    _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__(ReactSlider, _React$Component);\n    function ReactSlider(_props) {\n        var _this;\n        _this = _React$Component.call(this, _props) || this;\n        _this.onKeyUp = ()=>{\n            _this.onEnd();\n        };\n        _this.onMouseUp = ()=>{\n            _this.onEnd(_this.getMouseEventMap());\n        };\n        _this.onTouchEnd = (e)=>{\n            e.preventDefault();\n            _this.onEnd(_this.getTouchEventMap());\n        };\n        _this.onBlur = ()=>{\n            _this.setState({\n                index: -1\n            }, _this.onEnd(_this.getKeyDownEventMap()));\n        };\n        _this.onMouseMove = (e)=>{\n            // Prevent controlled updates from happening while mouse is moving\n            _this.setState({\n                pending: true\n            });\n            const position = _this.getMousePosition(e);\n            const diffPosition = _this.getDiffPosition(position[0]);\n            const newValue = _this.getValueFromPosition(diffPosition);\n            _this.move(newValue);\n        };\n        _this.onTouchMove = (e)=>{\n            if (e.touches.length > 1) {\n                return;\n            } // Prevent controlled updates from happending while touch is moving\n            _this.setState({\n                pending: true\n            });\n            const position = _this.getTouchPosition(e);\n            if (typeof _this.isScrolling === \"undefined\") {\n                const diffMainDir = position[0] - _this.startPosition[0];\n                const diffScrollDir = position[1] - _this.startPosition[1];\n                _this.isScrolling = Math.abs(diffScrollDir) > Math.abs(diffMainDir);\n            }\n            if (_this.isScrolling) {\n                _this.setState({\n                    index: -1\n                });\n                return;\n            }\n            const diffPosition = _this.getDiffPosition(position[0]);\n            const newValue = _this.getValueFromPosition(diffPosition);\n            _this.move(newValue);\n        };\n        _this.onKeyDown = (e)=>{\n            if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) {\n                return;\n            } // Prevent controlled updates from happening while a key is pressed\n            _this.setState({\n                pending: true\n            });\n            switch(e.key){\n                case \"ArrowLeft\":\n                case \"ArrowDown\":\n                case \"Left\":\n                case \"Down\":\n                    e.preventDefault();\n                    _this.moveDownByStep();\n                    break;\n                case \"ArrowRight\":\n                case \"ArrowUp\":\n                case \"Right\":\n                case \"Up\":\n                    e.preventDefault();\n                    _this.moveUpByStep();\n                    break;\n                case \"Home\":\n                    e.preventDefault();\n                    _this.move(_this.props.min);\n                    break;\n                case \"End\":\n                    e.preventDefault();\n                    _this.move(_this.props.max);\n                    break;\n                case \"PageDown\":\n                    e.preventDefault();\n                    _this.moveDownByStep(_this.props.pageFn(_this.props.step));\n                    break;\n                case \"PageUp\":\n                    e.preventDefault();\n                    _this.moveUpByStep(_this.props.pageFn(_this.props.step));\n                    break;\n            }\n        };\n        _this.onSliderMouseDown = (e)=>{\n            // do nothing if disabled or right click\n            if (_this.props.disabled || e.button === 2) {\n                return;\n            } // Prevent controlled updates from happening while mouse is moving\n            _this.setState({\n                pending: true\n            });\n            if (!_this.props.snapDragDisabled) {\n                const position = _this.getMousePosition(e);\n                _this.forceValueFromPosition(position[0], (i)=>{\n                    _this.start(i, position[0]);\n                    addHandlers(_this.getMouseEventMap());\n                });\n            }\n            pauseEvent(e);\n        };\n        _this.onSliderClick = (e)=>{\n            if (_this.props.disabled) {\n                return;\n            }\n            if (_this.props.onSliderClick && !_this.hasMoved) {\n                const position = _this.getMousePosition(e);\n                const valueAtPos = trimAlignValue(_this.calcValue(_this.calcOffsetFromPosition(position[0])), _this.props);\n                _this.props.onSliderClick(valueAtPos);\n            }\n        };\n        _this.createOnKeyDown = (i)=>(e)=>{\n                if (_this.props.disabled) {\n                    return;\n                }\n                _this.start(i);\n                addHandlers(_this.getKeyDownEventMap());\n                pauseEvent(e);\n            };\n        _this.createOnMouseDown = (i)=>(e)=>{\n                // do nothing if disabled or right click\n                if (_this.props.disabled || e.button === 2) {\n                    return;\n                } // Prevent controlled updates from happending while mouse is moving\n                _this.setState({\n                    pending: true\n                });\n                const position = _this.getMousePosition(e);\n                _this.start(i, position[0]);\n                addHandlers(_this.getMouseEventMap());\n                pauseEvent(e);\n            };\n        _this.createOnTouchStart = (i)=>(e)=>{\n                if (_this.props.disabled || e.touches.length > 1) {\n                    return;\n                } // Prevent controlled updates from happending while touch is moving\n                _this.setState({\n                    pending: true\n                });\n                const position = _this.getTouchPosition(e);\n                _this.startPosition = position; // don't know yet if the user is trying to scroll\n                _this.isScrolling = undefined;\n                _this.start(i, position[0]);\n                addHandlers(_this.getTouchEventMap());\n                stopPropagation(e);\n            };\n        _this.handleResize = ()=>{\n            // setTimeout of 0 gives element enough time to have assumed its new size if\n            // it is being resized\n            const resizeTimeout = window.setTimeout(()=>{\n                // drop this timeout from pendingResizeTimeouts to reduce memory usage\n                _this.pendingResizeTimeouts.shift();\n                _this.resize();\n            }, 0);\n            _this.pendingResizeTimeouts.push(resizeTimeout);\n        };\n        _this.renderThumb = (style, i)=>{\n            const className = _this.props.thumbClassName + \" \" + _this.props.thumbClassName + \"-\" + i + \" \" + (_this.state.index === i ? _this.props.thumbActiveClassName : \"\");\n            const props = {\n                \"ref\": (r)=>{\n                    _this[\"thumb\" + i] = r;\n                },\n                \"key\": _this.props.thumbClassName + \"-\" + i,\n                className,\n                style,\n                \"onMouseDown\": _this.createOnMouseDown(i),\n                \"onTouchStart\": _this.createOnTouchStart(i),\n                \"onFocus\": _this.createOnKeyDown(i),\n                \"tabIndex\": 0,\n                \"role\": \"slider\",\n                \"aria-orientation\": _this.props.orientation,\n                \"aria-valuenow\": _this.state.value[i],\n                \"aria-valuemin\": _this.props.min,\n                \"aria-valuemax\": _this.props.max,\n                \"aria-label\": Array.isArray(_this.props.ariaLabel) ? _this.props.ariaLabel[i] : _this.props.ariaLabel,\n                \"aria-labelledby\": Array.isArray(_this.props.ariaLabelledby) ? _this.props.ariaLabelledby[i] : _this.props.ariaLabelledby,\n                \"aria-disabled\": _this.props.disabled\n            };\n            const state = {\n                index: i,\n                value: prepareOutValue(_this.state.value),\n                valueNow: _this.state.value[i]\n            };\n            if (_this.props.ariaValuetext) {\n                props[\"aria-valuetext\"] = typeof _this.props.ariaValuetext === \"string\" ? _this.props.ariaValuetext : _this.props.ariaValuetext(state);\n            }\n            return _this.props.renderThumb(props, state);\n        };\n        _this.renderTrack = (i, offsetFrom, offsetTo)=>{\n            const props = {\n                key: _this.props.trackClassName + \"-\" + i,\n                className: _this.props.trackClassName + \" \" + _this.props.trackClassName + \"-\" + i,\n                style: _this.buildTrackStyle(offsetFrom, _this.state.upperBound - offsetTo)\n            };\n            const state = {\n                index: i,\n                value: prepareOutValue(_this.state.value)\n            };\n            return _this.props.renderTrack(props, state);\n        };\n        let value = sanitizeInValue(_props.value);\n        if (!value.length) {\n            value = sanitizeInValue(_props.defaultValue);\n        } // array for storing resize timeouts ids\n        _this.pendingResizeTimeouts = [];\n        const zIndices = [];\n        for(let i = 0; i < value.length; i += 1){\n            value[i] = trimAlignValue(value[i], _props);\n            zIndices.push(i);\n        }\n        _this.resizeObserver = null;\n        _this.resizeElementRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createRef();\n        _this.state = {\n            index: -1,\n            upperBound: 0,\n            sliderLength: 0,\n            value,\n            zIndices\n        };\n        return _this;\n    }\n    var _proto = ReactSlider.prototype;\n    _proto.componentDidMount = function componentDidMount() {\n        if (false) {}\n    } // Keep the internal `value` consistent with an outside `value` if present.\n    ;\n    ReactSlider.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n        const value = sanitizeInValue(props.value);\n        if (!value.length) {\n            return null;\n        } // Do not allow controlled upates to happen while we have pending updates\n        if (state.pending) {\n            return null;\n        }\n        return {\n            value: value.map((item)=>trimAlignValue(item, props))\n        };\n    };\n    _proto.componentDidUpdate = function componentDidUpdate() {\n        // If an upperBound has not yet been determined (due to the component being hidden\n        // during the mount event, or during the last resize), then calculate it now\n        if (this.state.upperBound === 0) {\n            this.resize();\n        }\n    };\n    _proto.componentWillUnmount = function componentWillUnmount() {\n        this.clearPendingResizeTimeouts();\n        if (this.resizeObserver) {\n            this.resizeObserver.disconnect();\n        }\n    };\n    _proto.onEnd = function onEnd(eventMap) {\n        if (eventMap) {\n            removeHandlers(eventMap);\n        }\n        if (this.hasMoved) {\n            this.fireChangeEvent(\"onAfterChange\");\n        } // Allow controlled updates to continue\n        this.setState({\n            pending: false\n        });\n        this.hasMoved = false;\n    };\n    _proto.getValue = function getValue() {\n        return prepareOutValue(this.state.value);\n    };\n    _proto.getClosestIndex = function getClosestIndex(pixelOffset) {\n        let minDist = Number.MAX_VALUE;\n        let closestIndex = -1;\n        const { value } = this.state;\n        const l = value.length;\n        for(let i = 0; i < l; i += 1){\n            const offset = this.calcOffset(value[i]);\n            const dist = Math.abs(pixelOffset - offset);\n            if (dist < minDist) {\n                minDist = dist;\n                closestIndex = i;\n            }\n        }\n        return closestIndex;\n    };\n    _proto.getMousePosition = function getMousePosition(e) {\n        return [\n            e[\"page\" + this.axisKey()],\n            e[\"page\" + this.orthogonalAxisKey()]\n        ];\n    };\n    _proto.getTouchPosition = function getTouchPosition(e) {\n        const touch = e.touches[0];\n        return [\n            touch[\"page\" + this.axisKey()],\n            touch[\"page\" + this.orthogonalAxisKey()]\n        ];\n    };\n    _proto.getKeyDownEventMap = function getKeyDownEventMap() {\n        return {\n            keydown: this.onKeyDown,\n            keyup: this.onKeyUp,\n            focusout: this.onBlur\n        };\n    };\n    _proto.getMouseEventMap = function getMouseEventMap() {\n        return {\n            mousemove: this.onMouseMove,\n            mouseup: this.onMouseUp\n        };\n    };\n    _proto.getTouchEventMap = function getTouchEventMap() {\n        return {\n            touchmove: this.onTouchMove,\n            touchend: this.onTouchEnd\n        };\n    };\n    _proto.getValueFromPosition = function getValueFromPosition(position) {\n        const diffValue = position / (this.state.sliderLength - this.state.thumbSize) * (this.props.max - this.props.min);\n        return trimAlignValue(this.state.startValue + diffValue, this.props);\n    };\n    _proto.getDiffPosition = function getDiffPosition(position) {\n        let diffPosition = position - this.state.startPosition;\n        if (this.props.invert) {\n            diffPosition *= -1;\n        }\n        return diffPosition;\n    } // create the `keydown` handler for the i-th thumb\n    ;\n    _proto.resize = function resize() {\n        const { slider, thumb0: thumb } = this;\n        if (!slider || !thumb) {\n            return;\n        }\n        const sizeKey = this.sizeKey(); // For the slider size, we want to use the client width/height, excluding any borders\n        const sliderRect = slider.getBoundingClientRect();\n        const sliderSize = slider[sizeKey];\n        const sliderMax = sliderRect[this.posMaxKey()];\n        const sliderMin = sliderRect[this.posMinKey()]; // For the thumb size, we want to use the outer width/height, including any borders\n        const thumbRect = thumb.getBoundingClientRect();\n        const thumbSize = thumbRect[sizeKey.replace(\"client\", \"\").toLowerCase()];\n        const upperBound = sliderSize - thumbSize;\n        const sliderLength = Math.abs(sliderMax - sliderMin);\n        if (this.state.upperBound !== upperBound || this.state.sliderLength !== sliderLength || this.state.thumbSize !== thumbSize) {\n            this.setState({\n                upperBound,\n                sliderLength,\n                thumbSize\n            });\n        }\n    } // calculates the offset of a thumb in pixels based on its value.\n    ;\n    _proto.calcOffset = function calcOffset(value) {\n        const range = this.props.max - this.props.min;\n        if (range === 0) {\n            return 0;\n        }\n        const ratio = (value - this.props.min) / range;\n        return ratio * this.state.upperBound;\n    } // calculates the value corresponding to a given pixel offset, i.e. the inverse of `calcOffset`.\n    ;\n    _proto.calcValue = function calcValue(offset) {\n        const ratio = offset / this.state.upperBound;\n        return ratio * (this.props.max - this.props.min) + this.props.min;\n    };\n    _proto.calcOffsetFromPosition = function calcOffsetFromPosition(position) {\n        const { slider } = this;\n        const sliderRect = slider.getBoundingClientRect();\n        const sliderMax = sliderRect[this.posMaxKey()];\n        const sliderMin = sliderRect[this.posMinKey()]; // The `position` value passed in is the mouse position based on the window height.\n        // The slider bounding rect is based on the viewport, so we must add the window scroll\n        // offset to normalize the values.\n        const windowOffset = window[\"page\" + this.axisKey() + \"Offset\"];\n        const sliderStart = windowOffset + (this.props.invert ? sliderMax : sliderMin);\n        let pixelOffset = position - sliderStart;\n        if (this.props.invert) {\n            pixelOffset = this.state.sliderLength - pixelOffset;\n        }\n        pixelOffset -= this.state.thumbSize / 2;\n        return pixelOffset;\n    } // Snaps the nearest thumb to the value corresponding to `position`\n    ;\n    _proto.forceValueFromPosition = function forceValueFromPosition(position, callback) {\n        const pixelOffset = this.calcOffsetFromPosition(position);\n        const closestIndex = this.getClosestIndex(pixelOffset);\n        const nextValue = trimAlignValue(this.calcValue(pixelOffset), this.props); // Clone this.state.value since we'll modify it temporarily\n        // eslint-disable-next-line zillow/react/no-access-state-in-setstate\n        const value = this.state.value.slice();\n        value[closestIndex] = nextValue; // Prevents the slider from shrinking below `props.minDistance`\n        for(let i = 0; i < value.length - 1; i += 1){\n            if (value[i + 1] - value[i] < this.props.minDistance) {\n                return;\n            }\n        }\n        this.fireChangeEvent(\"onBeforeChange\");\n        this.hasMoved = true;\n        this.setState({\n            value\n        }, ()=>{\n            callback(closestIndex);\n            this.fireChangeEvent(\"onChange\");\n        });\n    } // clear all pending timeouts to avoid error messages after unmounting\n    ;\n    _proto.clearPendingResizeTimeouts = function clearPendingResizeTimeouts() {\n        do {\n            const nextTimeout = this.pendingResizeTimeouts.shift();\n            clearTimeout(nextTimeout);\n        }while (this.pendingResizeTimeouts.length);\n    };\n    _proto.start = function start(i, position) {\n        const thumbRef = this[\"thumb\" + i];\n        if (thumbRef) {\n            thumbRef.focus();\n        }\n        const { zIndices } = this.state; // remove wherever the element is\n        zIndices.splice(zIndices.indexOf(i), 1); // add to end\n        zIndices.push(i);\n        this.setState((prevState)=>({\n                startValue: prevState.value[i],\n                startPosition: position !== undefined ? position : prevState.startPosition,\n                index: i,\n                zIndices\n            }));\n    };\n    _proto.moveUpByStep = function moveUpByStep(step) {\n        if (step === void 0) {\n            step = this.props.step;\n        }\n        const oldValue = this.state.value[this.state.index]; // if the slider is inverted and horizontal we want to honor the inverted value\n        const newValue = this.props.invert && this.props.orientation === \"horizontal\" ? oldValue - step : oldValue + step;\n        const trimAlign = trimAlignValue(newValue, this.props);\n        this.move(Math.min(trimAlign, this.props.max));\n    };\n    _proto.moveDownByStep = function moveDownByStep(step) {\n        if (step === void 0) {\n            step = this.props.step;\n        }\n        const oldValue = this.state.value[this.state.index]; // if the slider is inverted and horizontal we want to honor the inverted value\n        const newValue = this.props.invert && this.props.orientation === \"horizontal\" ? oldValue + step : oldValue - step;\n        const trimAlign = trimAlignValue(newValue, this.props);\n        this.move(Math.max(trimAlign, this.props.min));\n    };\n    _proto.move = function move(newValue) {\n        // Clone this.state.value since we'll modify it temporarily\n        // eslint-disable-next-line zillow/react/no-access-state-in-setstate\n        const value = this.state.value.slice();\n        const { index } = this.state;\n        const { length } = value; // Short circuit if the value is not changing\n        const oldValue = value[index];\n        if (newValue === oldValue) {\n            return;\n        } // Trigger only before the first movement\n        if (!this.hasMoved) {\n            this.fireChangeEvent(\"onBeforeChange\");\n        }\n        this.hasMoved = true; // if \"pearling\" (= thumbs pushing each other) is disabled,\n        // prevent the thumb from getting closer than `minDistance` to the previous or next thumb.\n        const { pearling, max, min, minDistance } = this.props;\n        if (!pearling) {\n            if (index > 0) {\n                const valueBefore = value[index - 1];\n                if (newValue < valueBefore + minDistance) {\n                    // eslint-disable-next-line no-param-reassign\n                    newValue = valueBefore + minDistance;\n                }\n            }\n            if (index < length - 1) {\n                const valueAfter = value[index + 1];\n                if (newValue > valueAfter - minDistance) {\n                    // eslint-disable-next-line no-param-reassign\n                    newValue = valueAfter - minDistance;\n                }\n            }\n        }\n        value[index] = newValue; // if \"pearling\" is enabled, let the current thumb push the pre- and succeeding thumbs.\n        if (pearling && length > 1) {\n            if (newValue > oldValue) {\n                this.pushSucceeding(value, minDistance, index);\n                trimSucceeding(length, value, minDistance, max);\n            } else if (newValue < oldValue) {\n                this.pushPreceding(value, minDistance, index);\n                trimPreceding(length, value, minDistance, min);\n            }\n        } // Normally you would use `shouldComponentUpdate`,\n        // but since the slider is a low-level component,\n        // the extra complexity might be worth the extra performance.\n        this.setState({\n            value\n        }, this.fireChangeEvent.bind(this, \"onChange\"));\n    };\n    _proto.pushSucceeding = function pushSucceeding(value, minDistance, index) {\n        let i;\n        let padding;\n        for(i = index, padding = value[i] + minDistance; value[i + 1] !== null && padding > value[i + 1]; i += 1, padding = value[i] + minDistance){\n            // eslint-disable-next-line no-param-reassign\n            value[i + 1] = alignValue(padding, this.props);\n        }\n    };\n    _proto.pushPreceding = function pushPreceding(value, minDistance, index) {\n        for(let i = index, padding = value[i] - minDistance; value[i - 1] !== null && padding < value[i - 1]; i -= 1, padding = value[i] - minDistance){\n            // eslint-disable-next-line no-param-reassign\n            value[i - 1] = alignValue(padding, this.props);\n        }\n    };\n    _proto.axisKey = function axisKey() {\n        if (this.props.orientation === \"vertical\") {\n            return \"Y\";\n        } // Defaults to 'horizontal';\n        return \"X\";\n    };\n    _proto.orthogonalAxisKey = function orthogonalAxisKey() {\n        if (this.props.orientation === \"vertical\") {\n            return \"X\";\n        } // Defaults to 'horizontal'\n        return \"Y\";\n    };\n    _proto.posMinKey = function posMinKey() {\n        if (this.props.orientation === \"vertical\") {\n            return this.props.invert ? \"bottom\" : \"top\";\n        } // Defaults to 'horizontal'\n        return this.props.invert ? \"right\" : \"left\";\n    };\n    _proto.posMaxKey = function posMaxKey() {\n        if (this.props.orientation === \"vertical\") {\n            return this.props.invert ? \"top\" : \"bottom\";\n        } // Defaults to 'horizontal'\n        return this.props.invert ? \"left\" : \"right\";\n    };\n    _proto.sizeKey = function sizeKey() {\n        if (this.props.orientation === \"vertical\") {\n            return \"clientHeight\";\n        } // Defaults to 'horizontal'\n        return \"clientWidth\";\n    };\n    _proto.fireChangeEvent = function fireChangeEvent(event) {\n        if (this.props[event]) {\n            this.props[event](prepareOutValue(this.state.value), this.state.index);\n        }\n    };\n    _proto.buildThumbStyle = function buildThumbStyle(offset, i) {\n        const style = {\n            position: \"absolute\",\n            touchAction: \"none\",\n            willChange: this.state.index >= 0 ? this.posMinKey() : undefined,\n            zIndex: this.state.zIndices.indexOf(i) + 1\n        };\n        style[this.posMinKey()] = offset + \"px\";\n        return style;\n    };\n    _proto.buildTrackStyle = function buildTrackStyle(min, max) {\n        const obj = {\n            position: \"absolute\",\n            willChange: this.state.index >= 0 ? this.posMinKey() + \",\" + this.posMaxKey() : undefined\n        };\n        obj[this.posMinKey()] = min;\n        obj[this.posMaxKey()] = max;\n        return obj;\n    };\n    _proto.buildMarkStyle = function buildMarkStyle(offset) {\n        var _ref;\n        return _ref = {\n            position: \"absolute\"\n        }, _ref[this.posMinKey()] = offset, _ref;\n    };\n    _proto.renderThumbs = function renderThumbs(offset) {\n        const { length } = offset;\n        const styles = [];\n        for(let i = 0; i < length; i += 1){\n            styles[i] = this.buildThumbStyle(offset[i], i);\n        }\n        const res = [];\n        for(let i = 0; i < length; i += 1){\n            res[i] = this.renderThumb(styles[i], i);\n        }\n        return res;\n    };\n    _proto.renderTracks = function renderTracks(offset) {\n        const tracks = [];\n        const lastIndex = offset.length - 1;\n        tracks.push(this.renderTrack(0, 0, offset[0]));\n        for(let i = 0; i < lastIndex; i += 1){\n            tracks.push(this.renderTrack(i + 1, offset[i], offset[i + 1]));\n        }\n        tracks.push(this.renderTrack(lastIndex + 1, offset[lastIndex], this.state.upperBound));\n        return tracks;\n    };\n    _proto.renderMarks = function renderMarks() {\n        let { marks } = this.props;\n        const range = this.props.max - this.props.min + 1;\n        if (typeof marks === \"boolean\") {\n            marks = Array.from({\n                length: range\n            }).map((_, key)=>key);\n        } else if (typeof marks === \"number\") {\n            marks = Array.from({\n                length: range\n            }).map((_, key)=>key).filter((key)=>key % marks === 0);\n        }\n        return marks.map(parseFloat).sort((a, b)=>a - b).map((mark)=>{\n            const offset = this.calcOffset(mark);\n            const props = {\n                key: mark,\n                className: this.props.markClassName,\n                style: this.buildMarkStyle(offset)\n            };\n            return this.props.renderMark(props);\n        });\n    };\n    _proto.render = function render() {\n        const offset = [];\n        const { value } = this.state;\n        const l = value.length;\n        for(let i = 0; i < l; i += 1){\n            offset[i] = this.calcOffset(value[i], i);\n        }\n        const tracks = this.props.withTracks ? this.renderTracks(offset) : null;\n        const thumbs = this.renderThumbs(offset);\n        const marks = this.props.marks ? this.renderMarks() : null;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", {\n            ref: (r)=>{\n                this.slider = r;\n                this.resizeElementRef.current = r;\n            },\n            style: {\n                position: \"relative\"\n            },\n            className: this.props.className + (this.props.disabled ? \" disabled\" : \"\"),\n            onMouseDown: this.onSliderMouseDown,\n            onClick: this.onSliderClick\n        }, tracks, thumbs, marks);\n    };\n    return ReactSlider;\n}(react__WEBPACK_IMPORTED_MODULE_2__.Component);\nReactSlider.displayName = \"ReactSlider\";\nReactSlider.defaultProps = {\n    min: 0,\n    max: 100,\n    step: 1,\n    pageFn: (step)=>step * 10,\n    minDistance: 0,\n    defaultValue: 0,\n    orientation: \"horizontal\",\n    className: \"slider\",\n    thumbClassName: \"thumb\",\n    thumbActiveClassName: \"active\",\n    trackClassName: \"track\",\n    markClassName: \"mark\",\n    withTracks: true,\n    pearling: false,\n    disabled: false,\n    snapDragDisabled: false,\n    invert: false,\n    marks: [],\n    renderThumb: (props)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__({}, props, {\n            __self: ReactSlider,\n            __source: {\n                fileName: _jsxFileName,\n                lineNumber: 353,\n                columnNumber: 31\n            }\n        })),\n    renderTrack: (props)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__({}, props, {\n            __self: ReactSlider,\n            __source: {\n                fileName: _jsxFileName,\n                lineNumber: 354,\n                columnNumber: 31\n            }\n        })),\n    renderMark: (props)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"span\", _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__({}, props, {\n            __self: ReactSlider,\n            __source: {\n                fileName: _jsxFileName,\n                lineNumber: 355,\n                columnNumber: 30\n            }\n        }))\n};\nReactSlider.propTypes =  true ? {\n    /**\n   * The minimum value of the slider.\n   */ min: prop_types__WEBPACK_IMPORTED_MODULE_3__.number,\n    /**\n   * The maximum value of the slider.\n   */ max: prop_types__WEBPACK_IMPORTED_MODULE_3__.number,\n    /**\n   * Value to be added or subtracted on each step the slider makes.\n   * Must be greater than zero.\n   * `max - min` should be evenly divisible by the step value.\n   */ step: prop_types__WEBPACK_IMPORTED_MODULE_3__.number,\n    /**\n   * The result of the function is the value to be added or subtracted\n   * when the `Page Up` or `Page Down` keys are pressed.\n   *\n   * The current `step` value will be passed as the only argument.\n   * By default, paging will modify `step` by a factor of 10.\n   */ pageFn: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n    /**\n   * The minimal distance between any pair of thumbs.\n   * Must be positive, but zero means they can sit on top of each other.\n   */ minDistance: prop_types__WEBPACK_IMPORTED_MODULE_3__.number,\n    /**\n   * Determines the initial positions of the thumbs and the number of thumbs.\n   *\n   * If a number is passed a slider with one thumb will be rendered.\n   * If an array is passed each value will determine the position of one thumb.\n   * The values in the array must be sorted.\n   */ defaultValue: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([\n        prop_types__WEBPACK_IMPORTED_MODULE_3__.number,\n        prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.number)\n    ]),\n    /**\n   * Like `defaultValue` but for\n   * [controlled components](http://facebook.github.io/react/docs/forms.html#controlled-components).\n   */ // eslint-disable-next-line zillow/react/require-default-props\n    value: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([\n        prop_types__WEBPACK_IMPORTED_MODULE_3__.number,\n        prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.number)\n    ]),\n    /**\n   * Determines whether the slider moves horizontally (from left to right)\n   * or vertically (from top to bottom).\n   */ orientation: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOf([\n        \"horizontal\",\n        \"vertical\"\n    ]),\n    /**\n   * The css class set on the slider node.\n   */ className: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,\n    /**\n   * The css class set on each thumb node.\n   *\n   * In addition each thumb will receive a numbered css class of the form\n   * `${thumbClassName}-${i}`, e.g. `thumb-0`, `thumb-1`, ...\n   */ thumbClassName: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,\n    /**\n   * The css class set on the thumb that is currently being moved.\n   */ thumbActiveClassName: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,\n    /**\n   * If `true` tracks between the thumbs will be rendered.\n   */ withTracks: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,\n    /**\n   * The css class set on the tracks between the thumbs.\n   * In addition track fragment will receive a numbered css class of the form\n   * `${trackClassName}-${i}`, e.g. `track-0`, `track-1`, ...\n   */ trackClassName: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,\n    /**\n   * If `true` the active thumb will push other thumbs\n   * within the constraints of `min`, `max`, `step` and `minDistance`.\n   */ pearling: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,\n    /**\n   * If `true` the thumbs can't be moved.\n   */ disabled: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,\n    /**\n   * Disables thumb move when clicking the slider track\n   */ snapDragDisabled: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,\n    /**\n   * Inverts the slider.\n   */ invert: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,\n    /**\n   * Shows passed marks on the track, if true it shows all the marks,\n   * if an array of numbers it shows just the passed marks, if a number is passed\n   * it shows just the marks in that steps: like passing 3 shows the marks 3, 6, 9\n   */ marks: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([\n        prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.number),\n        prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,\n        prop_types__WEBPACK_IMPORTED_MODULE_3__.number\n    ]),\n    /**\n   * The css class set on the marks.\n   */ markClassName: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,\n    /**\n   * Callback called before starting to move a thumb. The callback will only be called if the\n   * action will result in a change. The function will be called with two arguments, the first\n   * being the initial value(s) the second being thumb index.\n   */ // eslint-disable-next-line max-len\n    // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n    onBeforeChange: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n    /**\n   * Callback called on every value change.\n   * The function will be called with two arguments, the first being the new value(s)\n   * the second being thumb index.\n   */ // eslint-disable-next-line max-len\n    // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n    onChange: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n    /**\n   * Callback called only after moving a thumb has ended. The callback will only be called if\n   * the action resulted in a change. The function will be called with two arguments, the\n   * first being the result value(s) the second being thumb index.\n   */ // eslint-disable-next-line max-len\n    // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n    onAfterChange: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n    /**\n   * Callback called when the the slider is clicked (thumb or tracks).\n   * Receives the value at the clicked position as argument.\n   */ // eslint-disable-next-line zillow/react/require-default-props\n    onSliderClick: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n    /**\n   * aria-label for screen-readers to apply to the thumbs.\n   * Use an array for more than one thumb.\n   * The length of the array must match the number of thumbs in the value array.\n   */ // eslint-disable-next-line zillow/react/require-default-props\n    ariaLabel: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([\n        prop_types__WEBPACK_IMPORTED_MODULE_3__.string,\n        prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.string)\n    ]),\n    /**\n   * aria-labelledby for screen-readers to apply to the thumbs.\n   * Used when slider rendered with separate label.\n   * Use an array for more than one thumb.\n   * The length of the array must match the number of thumbs in the value array.\n   */ // eslint-disable-next-line zillow/react/require-default-props\n    ariaLabelledby: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([\n        prop_types__WEBPACK_IMPORTED_MODULE_3__.string,\n        prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.string)\n    ]),\n    /**\n   * aria-valuetext for screen-readers.\n   * Can be a static string, or a function that returns a string.\n   * The function will be passed a single argument,\n   * an object with the following properties:\n   *\n   *     state => `Value: ${state.value}`\n   *\n   * - `state.index` {`number`} the index of the thumb\n   * - `state.value` {`number` | `array`} the current value state\n   * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\n   */ // eslint-disable-next-line zillow/react/require-default-props\n    ariaValuetext: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([\n        prop_types__WEBPACK_IMPORTED_MODULE_3__.string,\n        prop_types__WEBPACK_IMPORTED_MODULE_3__.func\n    ]),\n    /**\n   * Provide a custom render function for the track node.\n   * The render function will be passed two arguments,\n   * an object with props that should be added to your handle node,\n   * and an object with track and slider state:\n   *\n   *     (props, state) => <div {...props} />\n   *\n   * - `props` {`object`} props to be spread into your track node\n   * - `state.index` {`number`} the index of the track\n   * - `state.value` {`number` | `array`} the current value state\n   */ renderTrack: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n    /**\n   * Provide a custom render function for dynamic thumb content.\n   * The render function will be passed two arguments,\n   * an object with props that should be added to your thumb node,\n   * and an object with thumb and slider state:\n   *\n   *     (props, state) => <div {...props} />\n   *\n   * - `props` {`object`} props to be spread into your thumb node\n   * - `state.index` {`number`} the index of the thumb\n   * - `state.value` {`number` | `array`} the current value state\n   * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\n   */ // eslint-disable-next-line zillow/react/require-default-props\n    renderThumb: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n    /**\n   * Provide a custom render function for the mark node.\n   * The render function will be passed one argument,\n   * an object with props that should be added to your handle node\n   *\n   *     (props) => <span {...props} />\n   *\n   * - `props` {`object`} props to be spread into your track node\n   */ renderMark: prop_types__WEBPACK_IMPORTED_MODULE_3__.func\n} : 0;\nvar ReactSlider$1 = ReactSlider;\n //# sourceMappingURL=ReactSlider.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpZGVyL2Rpc3QvZXMvZGV2L2NvbXBvbmVudHMvUmVhY3RTbGlkZXIvUmVhY3RTbGlkZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNEO0FBQ1k7QUFDeEM7QUFDUztBQUVuQyxJQUFJSSxlQUFlO0FBQ25COzs7Q0FHQyxHQUVELFNBQVNDLFdBQVdDLENBQUM7SUFDbkIsSUFBSUEsS0FBS0EsRUFBRUMsZUFBZSxFQUFFO1FBQzFCRCxFQUFFQyxlQUFlO0lBQ25CO0lBRUEsSUFBSUQsS0FBS0EsRUFBRUUsY0FBYyxFQUFFO1FBQ3pCRixFQUFFRSxjQUFjO0lBQ2xCO0lBRUEsT0FBTztBQUNUO0FBRUEsU0FBU0QsZ0JBQWdCRCxDQUFDO0lBQ3hCLElBQUlBLEVBQUVDLGVBQWUsRUFBRTtRQUNyQkQsRUFBRUMsZUFBZTtJQUNuQjtBQUNGO0FBRUEsU0FBU0UsZ0JBQWdCQyxDQUFDO0lBQ3hCLElBQUlBLEtBQUssTUFBTTtRQUNiLE9BQU8sRUFBRTtJQUNYO0lBRUEsT0FBT0MsTUFBTUMsT0FBTyxDQUFDRixLQUFLQSxFQUFFRyxLQUFLLEtBQUs7UUFBQ0g7S0FBRTtBQUMzQztBQUVBLFNBQVNJLGdCQUFnQkosQ0FBQztJQUN4QixPQUFPQSxNQUFNLFFBQVFBLEVBQUVLLE1BQU0sS0FBSyxJQUFJTCxDQUFDLENBQUMsRUFBRSxHQUFHQSxFQUFFRyxLQUFLO0FBQ3REO0FBRUEsU0FBU0csZUFBZUQsTUFBTSxFQUFFRSxTQUFTLEVBQUVDLFdBQVcsRUFBRUMsR0FBRztJQUN6RCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUwsUUFBUUssS0FBSyxFQUFHO1FBQ2xDLE1BQU1DLFVBQVVGLE1BQU1DLElBQUlGO1FBRTFCLElBQUlELFNBQVMsQ0FBQ0YsU0FBUyxJQUFJSyxFQUFFLEdBQUdDLFNBQVM7WUFDdkMsNkNBQTZDO1lBQzdDSixTQUFTLENBQUNGLFNBQVMsSUFBSUssRUFBRSxHQUFHQztRQUM5QjtJQUNG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O0FBQ04sSUFBSWdRLGdCQUFnQnBOO0FBRWdCLENBQ3BDLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2RpZ2l0YWx5ei1kYXRhLWFsY2hlbWlzdC8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGlkZXIvZGlzdC9lcy9kZXYvY29tcG9uZW50cy9SZWFjdFNsaWRlci9SZWFjdFNsaWRlci5tanM/MWEzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzJztcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzTG9vc2UnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbnZhciBfanN4RmlsZU5hbWUgPSBcIi9Vc2Vycy9rcmlzZS9naXRodWIvcmVhY3Qtc2xpZGVyL3NyYy9jb21wb25lbnRzL1JlYWN0U2xpZGVyL1JlYWN0U2xpZGVyLmpzeFwiO1xuLyoqXG4gKiBUbyBwcmV2ZW50IHRleHQgc2VsZWN0aW9uIHdoaWxlIGRyYWdnaW5nLlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NDI5ODI3L2hvdy1jYW4taS1wcmV2ZW50LXRleHQtZWxlbWVudC1zZWxlY3Rpb24td2l0aC1jdXJzb3ItZHJhZ1xuICovXG5cbmZ1bmN0aW9uIHBhdXNlRXZlbnQoZSkge1xuICBpZiAoZSAmJiBlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBpZiAoZSAmJiBlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZSkge1xuICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNhbml0aXplSW5WYWx1ZSh4KSB7XG4gIGlmICh4ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gQXJyYXkuaXNBcnJheSh4KSA/IHguc2xpY2UoKSA6IFt4XTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZU91dFZhbHVlKHgpIHtcbiAgcmV0dXJuIHggIT09IG51bGwgJiYgeC5sZW5ndGggPT09IDEgPyB4WzBdIDogeC5zbGljZSgpO1xufVxuXG5mdW5jdGlvbiB0cmltU3VjY2VlZGluZyhsZW5ndGgsIG5leHRWYWx1ZSwgbWluRGlzdGFuY2UsIG1heCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IG1heCAtIGkgKiBtaW5EaXN0YW5jZTtcblxuICAgIGlmIChuZXh0VmFsdWVbbGVuZ3RoIC0gMSAtIGldID4gcGFkZGluZykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBuZXh0VmFsdWVbbGVuZ3RoIC0gMSAtIGldID0gcGFkZGluZztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJpbVByZWNlZGluZyhsZW5ndGgsIG5leHRWYWx1ZSwgbWluRGlzdGFuY2UsIG1pbikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IG1pbiArIGkgKiBtaW5EaXN0YW5jZTtcblxuICAgIGlmIChuZXh0VmFsdWVbaV0gPCBwYWRkaW5nKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG5leHRWYWx1ZVtpXSA9IHBhZGRpbmc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXJzKGV2ZW50TWFwKSB7XG4gIE9iamVjdC5rZXlzKGV2ZW50TWFwKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoa2V5LCBldmVudE1hcFtrZXldLCBmYWxzZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSGFuZGxlcnMoZXZlbnRNYXApIHtcbiAgT2JqZWN0LmtleXMoZXZlbnRNYXApLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihrZXksIGV2ZW50TWFwW2tleV0sIGZhbHNlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmltQWxpZ25WYWx1ZSh2YWwsIHByb3BzKSB7XG4gIHJldHVybiBhbGlnblZhbHVlKHRyaW1WYWx1ZSh2YWwsIHByb3BzKSwgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiBhbGlnblZhbHVlKHZhbCwgcHJvcHMpIHtcbiAgY29uc3QgdmFsTW9kU3RlcCA9ICh2YWwgLSBwcm9wcy5taW4pICUgcHJvcHMuc3RlcDtcbiAgbGV0IGFsaWduZWRWYWx1ZSA9IHZhbCAtIHZhbE1vZFN0ZXA7XG5cbiAgaWYgKE1hdGguYWJzKHZhbE1vZFN0ZXApICogMiA+PSBwcm9wcy5zdGVwKSB7XG4gICAgYWxpZ25lZFZhbHVlICs9IHZhbE1vZFN0ZXAgPiAwID8gcHJvcHMuc3RlcCA6IC1wcm9wcy5zdGVwO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlRmxvYXQoYWxpZ25lZFZhbHVlLnRvRml4ZWQoNSkpO1xufVxuXG5mdW5jdGlvbiB0cmltVmFsdWUodmFsLCBwcm9wcykge1xuICBsZXQgdHJpbW1lZCA9IHZhbDtcblxuICBpZiAodHJpbW1lZCA8PSBwcm9wcy5taW4pIHtcbiAgICB0cmltbWVkID0gcHJvcHMubWluO1xuICB9XG5cbiAgaWYgKHRyaW1tZWQgPj0gcHJvcHMubWF4KSB7XG4gICAgdHJpbW1lZCA9IHByb3BzLm1heDtcbiAgfVxuXG4gIHJldHVybiB0cmltbWVkO1xufVxuXG5sZXQgUmVhY3RTbGlkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoUmVhY3RTbGlkZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJlYWN0U2xpZGVyKF9wcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIF9wcm9wcykgfHwgdGhpcztcblxuICAgIF90aGlzLm9uS2V5VXAgPSAoKSA9PiB7XG4gICAgICBfdGhpcy5vbkVuZCgpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbk1vdXNlVXAgPSAoKSA9PiB7XG4gICAgICBfdGhpcy5vbkVuZChfdGhpcy5nZXRNb3VzZUV2ZW50TWFwKCkpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vblRvdWNoRW5kID0gZSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIF90aGlzLm9uRW5kKF90aGlzLmdldFRvdWNoRXZlbnRNYXAoKSk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uQmx1ciA9ICgpID0+IHtcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaW5kZXg6IC0xXG4gICAgICB9LCBfdGhpcy5vbkVuZChfdGhpcy5nZXRLZXlEb3duRXZlbnRNYXAoKSkpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbk1vdXNlTW92ZSA9IGUgPT4ge1xuICAgICAgLy8gUHJldmVudCBjb250cm9sbGVkIHVwZGF0ZXMgZnJvbSBoYXBwZW5pbmcgd2hpbGUgbW91c2UgaXMgbW92aW5nXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHBlbmRpbmc6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBwb3NpdGlvbiA9IF90aGlzLmdldE1vdXNlUG9zaXRpb24oZSk7XG5cbiAgICAgIGNvbnN0IGRpZmZQb3NpdGlvbiA9IF90aGlzLmdldERpZmZQb3NpdGlvbihwb3NpdGlvblswXSk7XG5cbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gX3RoaXMuZ2V0VmFsdWVGcm9tUG9zaXRpb24oZGlmZlBvc2l0aW9uKTtcblxuICAgICAgX3RoaXMubW92ZShuZXdWYWx1ZSk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uVG91Y2hNb3ZlID0gZSA9PiB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBQcmV2ZW50IGNvbnRyb2xsZWQgdXBkYXRlcyBmcm9tIGhhcHBlbmRpbmcgd2hpbGUgdG91Y2ggaXMgbW92aW5nXG5cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBwZW5kaW5nOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcG9zaXRpb24gPSBfdGhpcy5nZXRUb3VjaFBvc2l0aW9uKGUpO1xuXG4gICAgICBpZiAodHlwZW9mIF90aGlzLmlzU2Nyb2xsaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBkaWZmTWFpbkRpciA9IHBvc2l0aW9uWzBdIC0gX3RoaXMuc3RhcnRQb3NpdGlvblswXTtcbiAgICAgICAgY29uc3QgZGlmZlNjcm9sbERpciA9IHBvc2l0aW9uWzFdIC0gX3RoaXMuc3RhcnRQb3NpdGlvblsxXTtcbiAgICAgICAgX3RoaXMuaXNTY3JvbGxpbmcgPSBNYXRoLmFicyhkaWZmU2Nyb2xsRGlyKSA+IE1hdGguYWJzKGRpZmZNYWluRGlyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLmlzU2Nyb2xsaW5nKSB7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBpbmRleDogLTFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkaWZmUG9zaXRpb24gPSBfdGhpcy5nZXREaWZmUG9zaXRpb24ocG9zaXRpb25bMF0pO1xuXG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IF90aGlzLmdldFZhbHVlRnJvbVBvc2l0aW9uKGRpZmZQb3NpdGlvbik7XG5cbiAgICAgIF90aGlzLm1vdmUobmV3VmFsdWUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbktleURvd24gPSBlID0+IHtcbiAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5zaGlmdEtleSB8fCBlLmFsdEtleSB8fCBlLm1ldGFLZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBQcmV2ZW50IGNvbnRyb2xsZWQgdXBkYXRlcyBmcm9tIGhhcHBlbmluZyB3aGlsZSBhIGtleSBpcyBwcmVzc2VkXG5cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBwZW5kaW5nOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICBjYXNlICdMZWZ0JzpcbiAgICAgICAgY2FzZSAnRG93bic6XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgX3RoaXMubW92ZURvd25CeVN0ZXAoKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgY2FzZSAnUmlnaHQnOlxuICAgICAgICBjYXNlICdVcCc6XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgX3RoaXMubW92ZVVwQnlTdGVwKCk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdIb21lJzpcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBfdGhpcy5tb3ZlKF90aGlzLnByb3BzLm1pbik7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdFbmQnOlxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIF90aGlzLm1vdmUoX3RoaXMucHJvcHMubWF4KTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1BhZ2VEb3duJzpcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBfdGhpcy5tb3ZlRG93bkJ5U3RlcChfdGhpcy5wcm9wcy5wYWdlRm4oX3RoaXMucHJvcHMuc3RlcCkpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnUGFnZVVwJzpcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBfdGhpcy5tb3ZlVXBCeVN0ZXAoX3RoaXMucHJvcHMucGFnZUZuKF90aGlzLnByb3BzLnN0ZXApKTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vblNsaWRlck1vdXNlRG93biA9IGUgPT4ge1xuICAgICAgLy8gZG8gbm90aGluZyBpZiBkaXNhYmxlZCBvciByaWdodCBjbGlja1xuICAgICAgaWYgKF90aGlzLnByb3BzLmRpc2FibGVkIHx8IGUuYnV0dG9uID09PSAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gUHJldmVudCBjb250cm9sbGVkIHVwZGF0ZXMgZnJvbSBoYXBwZW5pbmcgd2hpbGUgbW91c2UgaXMgbW92aW5nXG5cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBwZW5kaW5nOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFfdGhpcy5wcm9wcy5zbmFwRHJhZ0Rpc2FibGVkKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gX3RoaXMuZ2V0TW91c2VQb3NpdGlvbihlKTtcblxuICAgICAgICBfdGhpcy5mb3JjZVZhbHVlRnJvbVBvc2l0aW9uKHBvc2l0aW9uWzBdLCBpID0+IHtcbiAgICAgICAgICBfdGhpcy5zdGFydChpLCBwb3NpdGlvblswXSk7XG5cbiAgICAgICAgICBhZGRIYW5kbGVycyhfdGhpcy5nZXRNb3VzZUV2ZW50TWFwKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcGF1c2VFdmVudChlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25TbGlkZXJDbGljayA9IGUgPT4ge1xuICAgICAgaWYgKF90aGlzLnByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uU2xpZGVyQ2xpY2sgJiYgIV90aGlzLmhhc01vdmVkKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gX3RoaXMuZ2V0TW91c2VQb3NpdGlvbihlKTtcblxuICAgICAgICBjb25zdCB2YWx1ZUF0UG9zID0gdHJpbUFsaWduVmFsdWUoX3RoaXMuY2FsY1ZhbHVlKF90aGlzLmNhbGNPZmZzZXRGcm9tUG9zaXRpb24ocG9zaXRpb25bMF0pKSwgX3RoaXMucHJvcHMpO1xuXG4gICAgICAgIF90aGlzLnByb3BzLm9uU2xpZGVyQ2xpY2sodmFsdWVBdFBvcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmNyZWF0ZU9uS2V5RG93biA9IGkgPT4gZSA9PiB7XG4gICAgICBpZiAoX3RoaXMucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zdGFydChpKTtcblxuICAgICAgYWRkSGFuZGxlcnMoX3RoaXMuZ2V0S2V5RG93bkV2ZW50TWFwKCkpO1xuICAgICAgcGF1c2VFdmVudChlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuY3JlYXRlT25Nb3VzZURvd24gPSBpID0+IGUgPT4ge1xuICAgICAgLy8gZG8gbm90aGluZyBpZiBkaXNhYmxlZCBvciByaWdodCBjbGlja1xuICAgICAgaWYgKF90aGlzLnByb3BzLmRpc2FibGVkIHx8IGUuYnV0dG9uID09PSAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gUHJldmVudCBjb250cm9sbGVkIHVwZGF0ZXMgZnJvbSBoYXBwZW5kaW5nIHdoaWxlIG1vdXNlIGlzIG1vdmluZ1xuXG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcGVuZGluZzogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gX3RoaXMuZ2V0TW91c2VQb3NpdGlvbihlKTtcblxuICAgICAgX3RoaXMuc3RhcnQoaSwgcG9zaXRpb25bMF0pO1xuXG4gICAgICBhZGRIYW5kbGVycyhfdGhpcy5nZXRNb3VzZUV2ZW50TWFwKCkpO1xuICAgICAgcGF1c2VFdmVudChlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuY3JlYXRlT25Ub3VjaFN0YXJ0ID0gaSA9PiBlID0+IHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5kaXNhYmxlZCB8fCBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFByZXZlbnQgY29udHJvbGxlZCB1cGRhdGVzIGZyb20gaGFwcGVuZGluZyB3aGlsZSB0b3VjaCBpcyBtb3ZpbmdcblxuXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHBlbmRpbmc6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBwb3NpdGlvbiA9IF90aGlzLmdldFRvdWNoUG9zaXRpb24oZSk7XG5cbiAgICAgIF90aGlzLnN0YXJ0UG9zaXRpb24gPSBwb3NpdGlvbjsgLy8gZG9uJ3Qga25vdyB5ZXQgaWYgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHNjcm9sbFxuXG4gICAgICBfdGhpcy5pc1Njcm9sbGluZyA9IHVuZGVmaW5lZDtcblxuICAgICAgX3RoaXMuc3RhcnQoaSwgcG9zaXRpb25bMF0pO1xuXG4gICAgICBhZGRIYW5kbGVycyhfdGhpcy5nZXRUb3VjaEV2ZW50TWFwKCkpO1xuICAgICAgc3RvcFByb3BhZ2F0aW9uKGUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICAvLyBzZXRUaW1lb3V0IG9mIDAgZ2l2ZXMgZWxlbWVudCBlbm91Z2ggdGltZSB0byBoYXZlIGFzc3VtZWQgaXRzIG5ldyBzaXplIGlmXG4gICAgICAvLyBpdCBpcyBiZWluZyByZXNpemVkXG4gICAgICBjb25zdCByZXNpemVUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyBkcm9wIHRoaXMgdGltZW91dCBmcm9tIHBlbmRpbmdSZXNpemVUaW1lb3V0cyB0byByZWR1Y2UgbWVtb3J5IHVzYWdlXG4gICAgICAgIF90aGlzLnBlbmRpbmdSZXNpemVUaW1lb3V0cy5zaGlmdCgpO1xuXG4gICAgICAgIF90aGlzLnJlc2l6ZSgpO1xuICAgICAgfSwgMCk7XG5cbiAgICAgIF90aGlzLnBlbmRpbmdSZXNpemVUaW1lb3V0cy5wdXNoKHJlc2l6ZVRpbWVvdXQpO1xuICAgIH07XG5cbiAgICBfdGhpcy5yZW5kZXJUaHVtYiA9IChzdHlsZSwgaSkgPT4ge1xuICAgICAgY29uc3QgY2xhc3NOYW1lID0gX3RoaXMucHJvcHMudGh1bWJDbGFzc05hbWUgKyBcIiBcIiArIF90aGlzLnByb3BzLnRodW1iQ2xhc3NOYW1lICsgXCItXCIgKyBpICsgXCIgXCIgKyAoX3RoaXMuc3RhdGUuaW5kZXggPT09IGkgPyBfdGhpcy5wcm9wcy50aHVtYkFjdGl2ZUNsYXNzTmFtZSA6ICcnKTtcbiAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICAncmVmJzogciA9PiB7XG4gICAgICAgICAgX3RoaXNbXCJ0aHVtYlwiICsgaV0gPSByO1xuICAgICAgICB9LFxuICAgICAgICAna2V5JzogX3RoaXMucHJvcHMudGh1bWJDbGFzc05hbWUgKyBcIi1cIiArIGksXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgc3R5bGUsXG4gICAgICAgICdvbk1vdXNlRG93bic6IF90aGlzLmNyZWF0ZU9uTW91c2VEb3duKGkpLFxuICAgICAgICAnb25Ub3VjaFN0YXJ0JzogX3RoaXMuY3JlYXRlT25Ub3VjaFN0YXJ0KGkpLFxuICAgICAgICAnb25Gb2N1cyc6IF90aGlzLmNyZWF0ZU9uS2V5RG93bihpKSxcbiAgICAgICAgJ3RhYkluZGV4JzogMCxcbiAgICAgICAgJ3JvbGUnOiAnc2xpZGVyJyxcbiAgICAgICAgJ2FyaWEtb3JpZW50YXRpb24nOiBfdGhpcy5wcm9wcy5vcmllbnRhdGlvbixcbiAgICAgICAgJ2FyaWEtdmFsdWVub3cnOiBfdGhpcy5zdGF0ZS52YWx1ZVtpXSxcbiAgICAgICAgJ2FyaWEtdmFsdWVtaW4nOiBfdGhpcy5wcm9wcy5taW4sXG4gICAgICAgICdhcmlhLXZhbHVlbWF4JzogX3RoaXMucHJvcHMubWF4LFxuICAgICAgICAnYXJpYS1sYWJlbCc6IEFycmF5LmlzQXJyYXkoX3RoaXMucHJvcHMuYXJpYUxhYmVsKSA/IF90aGlzLnByb3BzLmFyaWFMYWJlbFtpXSA6IF90aGlzLnByb3BzLmFyaWFMYWJlbCxcbiAgICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IEFycmF5LmlzQXJyYXkoX3RoaXMucHJvcHMuYXJpYUxhYmVsbGVkYnkpID8gX3RoaXMucHJvcHMuYXJpYUxhYmVsbGVkYnlbaV0gOiBfdGhpcy5wcm9wcy5hcmlhTGFiZWxsZWRieSxcbiAgICAgICAgJ2FyaWEtZGlzYWJsZWQnOiBfdGhpcy5wcm9wcy5kaXNhYmxlZFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgdmFsdWU6IHByZXBhcmVPdXRWYWx1ZShfdGhpcy5zdGF0ZS52YWx1ZSksXG4gICAgICAgIHZhbHVlTm93OiBfdGhpcy5zdGF0ZS52YWx1ZVtpXVxuICAgICAgfTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLmFyaWFWYWx1ZXRleHQpIHtcbiAgICAgICAgcHJvcHNbJ2FyaWEtdmFsdWV0ZXh0J10gPSB0eXBlb2YgX3RoaXMucHJvcHMuYXJpYVZhbHVldGV4dCA9PT0gJ3N0cmluZycgPyBfdGhpcy5wcm9wcy5hcmlhVmFsdWV0ZXh0IDogX3RoaXMucHJvcHMuYXJpYVZhbHVldGV4dChzdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5yZW5kZXJUaHVtYihwcm9wcywgc3RhdGUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5yZW5kZXJUcmFjayA9IChpLCBvZmZzZXRGcm9tLCBvZmZzZXRUbykgPT4ge1xuICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgIGtleTogX3RoaXMucHJvcHMudHJhY2tDbGFzc05hbWUgKyBcIi1cIiArIGksXG4gICAgICAgIGNsYXNzTmFtZTogX3RoaXMucHJvcHMudHJhY2tDbGFzc05hbWUgKyBcIiBcIiArIF90aGlzLnByb3BzLnRyYWNrQ2xhc3NOYW1lICsgXCItXCIgKyBpLFxuICAgICAgICBzdHlsZTogX3RoaXMuYnVpbGRUcmFja1N0eWxlKG9mZnNldEZyb20sIF90aGlzLnN0YXRlLnVwcGVyQm91bmQgLSBvZmZzZXRUbylcbiAgICAgIH07XG4gICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHZhbHVlOiBwcmVwYXJlT3V0VmFsdWUoX3RoaXMuc3RhdGUudmFsdWUpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIF90aGlzLnByb3BzLnJlbmRlclRyYWNrKHByb3BzLCBzdGF0ZSk7XG4gICAgfTtcblxuICAgIGxldCB2YWx1ZSA9IHNhbml0aXplSW5WYWx1ZShfcHJvcHMudmFsdWUpO1xuXG4gICAgaWYgKCF2YWx1ZS5sZW5ndGgpIHtcbiAgICAgIHZhbHVlID0gc2FuaXRpemVJblZhbHVlKF9wcm9wcy5kZWZhdWx0VmFsdWUpO1xuICAgIH0gLy8gYXJyYXkgZm9yIHN0b3JpbmcgcmVzaXplIHRpbWVvdXRzIGlkc1xuXG5cbiAgICBfdGhpcy5wZW5kaW5nUmVzaXplVGltZW91dHMgPSBbXTtcbiAgICBjb25zdCB6SW5kaWNlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFsdWVbaV0gPSB0cmltQWxpZ25WYWx1ZSh2YWx1ZVtpXSwgX3Byb3BzKTtcbiAgICAgIHpJbmRpY2VzLnB1c2goaSk7XG4gICAgfVxuXG4gICAgX3RoaXMucmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgIF90aGlzLnJlc2l6ZUVsZW1lbnRSZWYgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBpbmRleDogLTEsXG4gICAgICB1cHBlckJvdW5kOiAwLFxuICAgICAgc2xpZGVyTGVuZ3RoOiAwLFxuICAgICAgdmFsdWUsXG4gICAgICB6SW5kaWNlc1xuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJlYWN0U2xpZGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIodGhpcy5oYW5kbGVSZXNpemUpO1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMucmVzaXplRWxlbWVudFJlZi5jdXJyZW50KTtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfVxuICB9IC8vIEtlZXAgdGhlIGludGVybmFsIGB2YWx1ZWAgY29uc2lzdGVudCB3aXRoIGFuIG91dHNpZGUgYHZhbHVlYCBpZiBwcmVzZW50LlxuICAvLyBUaGlzIGJhc2ljYWxseSBhbGxvd3MgdGhlIHNsaWRlciB0byBiZSBhIGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICA7XG5cbiAgUmVhY3RTbGlkZXIuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gc2FuaXRpemVJblZhbHVlKHByb3BzLnZhbHVlKTtcblxuICAgIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIERvIG5vdCBhbGxvdyBjb250cm9sbGVkIHVwYXRlcyB0byBoYXBwZW4gd2hpbGUgd2UgaGF2ZSBwZW5kaW5nIHVwZGF0ZXNcblxuXG4gICAgaWYgKHN0YXRlLnBlbmRpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdmFsdWUubWFwKGl0ZW0gPT4gdHJpbUFsaWduVmFsdWUoaXRlbSwgcHJvcHMpKVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAvLyBJZiBhbiB1cHBlckJvdW5kIGhhcyBub3QgeWV0IGJlZW4gZGV0ZXJtaW5lZCAoZHVlIHRvIHRoZSBjb21wb25lbnQgYmVpbmcgaGlkZGVuXG4gICAgLy8gZHVyaW5nIHRoZSBtb3VudCBldmVudCwgb3IgZHVyaW5nIHRoZSBsYXN0IHJlc2l6ZSksIHRoZW4gY2FsY3VsYXRlIGl0IG5vd1xuICAgIGlmICh0aGlzLnN0YXRlLnVwcGVyQm91bmQgPT09IDApIHtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuY2xlYXJQZW5kaW5nUmVzaXplVGltZW91dHMoKTtcblxuICAgIGlmICh0aGlzLnJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRW5kID0gZnVuY3Rpb24gb25FbmQoZXZlbnRNYXApIHtcbiAgICBpZiAoZXZlbnRNYXApIHtcbiAgICAgIHJlbW92ZUhhbmRsZXJzKGV2ZW50TWFwKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNNb3ZlZCkge1xuICAgICAgdGhpcy5maXJlQ2hhbmdlRXZlbnQoJ29uQWZ0ZXJDaGFuZ2UnKTtcbiAgICB9IC8vIEFsbG93IGNvbnRyb2xsZWQgdXBkYXRlcyB0byBjb250aW51ZVxuXG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHBlbmRpbmc6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5oYXNNb3ZlZCA9IGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgIHJldHVybiBwcmVwYXJlT3V0VmFsdWUodGhpcy5zdGF0ZS52YWx1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldENsb3Nlc3RJbmRleCA9IGZ1bmN0aW9uIGdldENsb3Nlc3RJbmRleChwaXhlbE9mZnNldCkge1xuICAgIGxldCBtaW5EaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBsZXQgY2xvc2VzdEluZGV4ID0gLTE7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBsID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuY2FsY09mZnNldCh2YWx1ZVtpXSk7XG4gICAgICBjb25zdCBkaXN0ID0gTWF0aC5hYnMocGl4ZWxPZmZzZXQgLSBvZmZzZXQpO1xuXG4gICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgIGNsb3Nlc3RJbmRleCA9IGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb3Nlc3RJbmRleDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TW91c2VQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZSkge1xuICAgIHJldHVybiBbZVtcInBhZ2VcIiArIHRoaXMuYXhpc0tleSgpXSwgZVtcInBhZ2VcIiArIHRoaXMub3J0aG9nb25hbEF4aXNLZXkoKV1dO1xuICB9O1xuXG4gIF9wcm90by5nZXRUb3VjaFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hQb3NpdGlvbihlKSB7XG4gICAgY29uc3QgdG91Y2ggPSBlLnRvdWNoZXNbMF07XG4gICAgcmV0dXJuIFt0b3VjaFtcInBhZ2VcIiArIHRoaXMuYXhpc0tleSgpXSwgdG91Y2hbXCJwYWdlXCIgKyB0aGlzLm9ydGhvZ29uYWxBeGlzS2V5KCldXTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0S2V5RG93bkV2ZW50TWFwID0gZnVuY3Rpb24gZ2V0S2V5RG93bkV2ZW50TWFwKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlkb3duOiB0aGlzLm9uS2V5RG93bixcbiAgICAgIGtleXVwOiB0aGlzLm9uS2V5VXAsXG4gICAgICBmb2N1c291dDogdGhpcy5vbkJsdXJcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5nZXRNb3VzZUV2ZW50TWFwID0gZnVuY3Rpb24gZ2V0TW91c2VFdmVudE1hcCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbW91c2Vtb3ZlOiB0aGlzLm9uTW91c2VNb3ZlLFxuICAgICAgbW91c2V1cDogdGhpcy5vbk1vdXNlVXBcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5nZXRUb3VjaEV2ZW50TWFwID0gZnVuY3Rpb24gZ2V0VG91Y2hFdmVudE1hcCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG91Y2htb3ZlOiB0aGlzLm9uVG91Y2hNb3ZlLFxuICAgICAgdG91Y2hlbmQ6IHRoaXMub25Ub3VjaEVuZFxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmdldFZhbHVlRnJvbVBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0VmFsdWVGcm9tUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICBjb25zdCBkaWZmVmFsdWUgPSBwb3NpdGlvbiAvICh0aGlzLnN0YXRlLnNsaWRlckxlbmd0aCAtIHRoaXMuc3RhdGUudGh1bWJTaXplKSAqICh0aGlzLnByb3BzLm1heCAtIHRoaXMucHJvcHMubWluKTtcbiAgICByZXR1cm4gdHJpbUFsaWduVmFsdWUodGhpcy5zdGF0ZS5zdGFydFZhbHVlICsgZGlmZlZhbHVlLCB0aGlzLnByb3BzKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0RGlmZlBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0RGlmZlBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgbGV0IGRpZmZQb3NpdGlvbiA9IHBvc2l0aW9uIC0gdGhpcy5zdGF0ZS5zdGFydFBvc2l0aW9uO1xuXG4gICAgaWYgKHRoaXMucHJvcHMuaW52ZXJ0KSB7XG4gICAgICBkaWZmUG9zaXRpb24gKj0gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpZmZQb3NpdGlvbjtcbiAgfSAvLyBjcmVhdGUgdGhlIGBrZXlkb3duYCBoYW5kbGVyIGZvciB0aGUgaS10aCB0aHVtYlxuICA7XG5cbiAgX3Byb3RvLnJlc2l6ZSA9IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBzbGlkZXIsXG4gICAgICB0aHVtYjA6IHRodW1iXG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAoIXNsaWRlciB8fCAhdGh1bWIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzaXplS2V5ID0gdGhpcy5zaXplS2V5KCk7IC8vIEZvciB0aGUgc2xpZGVyIHNpemUsIHdlIHdhbnQgdG8gdXNlIHRoZSBjbGllbnQgd2lkdGgvaGVpZ2h0LCBleGNsdWRpbmcgYW55IGJvcmRlcnNcblxuICAgIGNvbnN0IHNsaWRlclJlY3QgPSBzbGlkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgc2xpZGVyU2l6ZSA9IHNsaWRlcltzaXplS2V5XTtcbiAgICBjb25zdCBzbGlkZXJNYXggPSBzbGlkZXJSZWN0W3RoaXMucG9zTWF4S2V5KCldO1xuICAgIGNvbnN0IHNsaWRlck1pbiA9IHNsaWRlclJlY3RbdGhpcy5wb3NNaW5LZXkoKV07IC8vIEZvciB0aGUgdGh1bWIgc2l6ZSwgd2Ugd2FudCB0byB1c2UgdGhlIG91dGVyIHdpZHRoL2hlaWdodCwgaW5jbHVkaW5nIGFueSBib3JkZXJzXG5cbiAgICBjb25zdCB0aHVtYlJlY3QgPSB0aHVtYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB0aHVtYlNpemUgPSB0aHVtYlJlY3Rbc2l6ZUtleS5yZXBsYWNlKCdjbGllbnQnLCAnJykudG9Mb3dlckNhc2UoKV07XG4gICAgY29uc3QgdXBwZXJCb3VuZCA9IHNsaWRlclNpemUgLSB0aHVtYlNpemU7XG4gICAgY29uc3Qgc2xpZGVyTGVuZ3RoID0gTWF0aC5hYnMoc2xpZGVyTWF4IC0gc2xpZGVyTWluKTtcblxuICAgIGlmICh0aGlzLnN0YXRlLnVwcGVyQm91bmQgIT09IHVwcGVyQm91bmQgfHwgdGhpcy5zdGF0ZS5zbGlkZXJMZW5ndGggIT09IHNsaWRlckxlbmd0aCB8fCB0aGlzLnN0YXRlLnRodW1iU2l6ZSAhPT0gdGh1bWJTaXplKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdXBwZXJCb3VuZCxcbiAgICAgICAgc2xpZGVyTGVuZ3RoLFxuICAgICAgICB0aHVtYlNpemVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBjYWxjdWxhdGVzIHRoZSBvZmZzZXQgb2YgYSB0aHVtYiBpbiBwaXhlbHMgYmFzZWQgb24gaXRzIHZhbHVlLlxuICA7XG5cbiAgX3Byb3RvLmNhbGNPZmZzZXQgPSBmdW5jdGlvbiBjYWxjT2Zmc2V0KHZhbHVlKSB7XG4gICAgY29uc3QgcmFuZ2UgPSB0aGlzLnByb3BzLm1heCAtIHRoaXMucHJvcHMubWluO1xuXG4gICAgaWYgKHJhbmdlID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBjb25zdCByYXRpbyA9ICh2YWx1ZSAtIHRoaXMucHJvcHMubWluKSAvIHJhbmdlO1xuICAgIHJldHVybiByYXRpbyAqIHRoaXMuc3RhdGUudXBwZXJCb3VuZDtcbiAgfSAvLyBjYWxjdWxhdGVzIHRoZSB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIGEgZ2l2ZW4gcGl4ZWwgb2Zmc2V0LCBpLmUuIHRoZSBpbnZlcnNlIG9mIGBjYWxjT2Zmc2V0YC5cbiAgO1xuXG4gIF9wcm90by5jYWxjVmFsdWUgPSBmdW5jdGlvbiBjYWxjVmFsdWUob2Zmc2V0KSB7XG4gICAgY29uc3QgcmF0aW8gPSBvZmZzZXQgLyB0aGlzLnN0YXRlLnVwcGVyQm91bmQ7XG4gICAgcmV0dXJuIHJhdGlvICogKHRoaXMucHJvcHMubWF4IC0gdGhpcy5wcm9wcy5taW4pICsgdGhpcy5wcm9wcy5taW47XG4gIH07XG5cbiAgX3Byb3RvLmNhbGNPZmZzZXRGcm9tUG9zaXRpb24gPSBmdW5jdGlvbiBjYWxjT2Zmc2V0RnJvbVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2xpZGVyXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2xpZGVyUmVjdCA9IHNsaWRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBzbGlkZXJNYXggPSBzbGlkZXJSZWN0W3RoaXMucG9zTWF4S2V5KCldO1xuICAgIGNvbnN0IHNsaWRlck1pbiA9IHNsaWRlclJlY3RbdGhpcy5wb3NNaW5LZXkoKV07IC8vIFRoZSBgcG9zaXRpb25gIHZhbHVlIHBhc3NlZCBpbiBpcyB0aGUgbW91c2UgcG9zaXRpb24gYmFzZWQgb24gdGhlIHdpbmRvdyBoZWlnaHQuXG4gICAgLy8gVGhlIHNsaWRlciBib3VuZGluZyByZWN0IGlzIGJhc2VkIG9uIHRoZSB2aWV3cG9ydCwgc28gd2UgbXVzdCBhZGQgdGhlIHdpbmRvdyBzY3JvbGxcbiAgICAvLyBvZmZzZXQgdG8gbm9ybWFsaXplIHRoZSB2YWx1ZXMuXG5cbiAgICBjb25zdCB3aW5kb3dPZmZzZXQgPSB3aW5kb3dbXCJwYWdlXCIgKyB0aGlzLmF4aXNLZXkoKSArIFwiT2Zmc2V0XCJdO1xuICAgIGNvbnN0IHNsaWRlclN0YXJ0ID0gd2luZG93T2Zmc2V0ICsgKHRoaXMucHJvcHMuaW52ZXJ0ID8gc2xpZGVyTWF4IDogc2xpZGVyTWluKTtcbiAgICBsZXQgcGl4ZWxPZmZzZXQgPSBwb3NpdGlvbiAtIHNsaWRlclN0YXJ0O1xuXG4gICAgaWYgKHRoaXMucHJvcHMuaW52ZXJ0KSB7XG4gICAgICBwaXhlbE9mZnNldCA9IHRoaXMuc3RhdGUuc2xpZGVyTGVuZ3RoIC0gcGl4ZWxPZmZzZXQ7XG4gICAgfVxuXG4gICAgcGl4ZWxPZmZzZXQgLT0gdGhpcy5zdGF0ZS50aHVtYlNpemUgLyAyO1xuICAgIHJldHVybiBwaXhlbE9mZnNldDtcbiAgfSAvLyBTbmFwcyB0aGUgbmVhcmVzdCB0aHVtYiB0byB0aGUgdmFsdWUgY29ycmVzcG9uZGluZyB0byBgcG9zaXRpb25gXG4gIC8vIGFuZCBjYWxscyBgY2FsbGJhY2tgIHdpdGggdGhhdCB0aHVtYidzIGluZGV4LlxuICA7XG5cbiAgX3Byb3RvLmZvcmNlVmFsdWVGcm9tUG9zaXRpb24gPSBmdW5jdGlvbiBmb3JjZVZhbHVlRnJvbVBvc2l0aW9uKHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHBpeGVsT2Zmc2V0ID0gdGhpcy5jYWxjT2Zmc2V0RnJvbVBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICBjb25zdCBjbG9zZXN0SW5kZXggPSB0aGlzLmdldENsb3Nlc3RJbmRleChwaXhlbE9mZnNldCk7XG4gICAgY29uc3QgbmV4dFZhbHVlID0gdHJpbUFsaWduVmFsdWUodGhpcy5jYWxjVmFsdWUocGl4ZWxPZmZzZXQpLCB0aGlzLnByb3BzKTsgLy8gQ2xvbmUgdGhpcy5zdGF0ZS52YWx1ZSBzaW5jZSB3ZSdsbCBtb2RpZnkgaXQgdGVtcG9yYXJpbHlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgemlsbG93L3JlYWN0L25vLWFjY2Vzcy1zdGF0ZS1pbi1zZXRzdGF0ZVxuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlLnNsaWNlKCk7XG4gICAgdmFsdWVbY2xvc2VzdEluZGV4XSA9IG5leHRWYWx1ZTsgLy8gUHJldmVudHMgdGhlIHNsaWRlciBmcm9tIHNocmlua2luZyBiZWxvdyBgcHJvcHMubWluRGlzdGFuY2VgXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgaWYgKHZhbHVlW2kgKyAxXSAtIHZhbHVlW2ldIDwgdGhpcy5wcm9wcy5taW5EaXN0YW5jZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5maXJlQ2hhbmdlRXZlbnQoJ29uQmVmb3JlQ2hhbmdlJyk7XG4gICAgdGhpcy5oYXNNb3ZlZCA9IHRydWU7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB2YWx1ZVxuICAgIH0sICgpID0+IHtcbiAgICAgIGNhbGxiYWNrKGNsb3Nlc3RJbmRleCk7XG4gICAgICB0aGlzLmZpcmVDaGFuZ2VFdmVudCgnb25DaGFuZ2UnKTtcbiAgICB9KTtcbiAgfSAvLyBjbGVhciBhbGwgcGVuZGluZyB0aW1lb3V0cyB0byBhdm9pZCBlcnJvciBtZXNzYWdlcyBhZnRlciB1bm1vdW50aW5nXG4gIDtcblxuICBfcHJvdG8uY2xlYXJQZW5kaW5nUmVzaXplVGltZW91dHMgPSBmdW5jdGlvbiBjbGVhclBlbmRpbmdSZXNpemVUaW1lb3V0cygpIHtcbiAgICBkbyB7XG4gICAgICBjb25zdCBuZXh0VGltZW91dCA9IHRoaXMucGVuZGluZ1Jlc2l6ZVRpbWVvdXRzLnNoaWZ0KCk7XG4gICAgICBjbGVhclRpbWVvdXQobmV4dFRpbWVvdXQpO1xuICAgIH0gd2hpbGUgKHRoaXMucGVuZGluZ1Jlc2l6ZVRpbWVvdXRzLmxlbmd0aCk7XG4gIH07XG5cbiAgX3Byb3RvLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoaSwgcG9zaXRpb24pIHtcbiAgICBjb25zdCB0aHVtYlJlZiA9IHRoaXNbXCJ0aHVtYlwiICsgaV07XG5cbiAgICBpZiAodGh1bWJSZWYpIHtcbiAgICAgIHRodW1iUmVmLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgekluZGljZXNcbiAgICB9ID0gdGhpcy5zdGF0ZTsgLy8gcmVtb3ZlIHdoZXJldmVyIHRoZSBlbGVtZW50IGlzXG5cbiAgICB6SW5kaWNlcy5zcGxpY2UoekluZGljZXMuaW5kZXhPZihpKSwgMSk7IC8vIGFkZCB0byBlbmRcblxuICAgIHpJbmRpY2VzLnB1c2goaSk7XG4gICAgdGhpcy5zZXRTdGF0ZShwcmV2U3RhdGUgPT4gKHtcbiAgICAgIHN0YXJ0VmFsdWU6IHByZXZTdGF0ZS52YWx1ZVtpXSxcbiAgICAgIHN0YXJ0UG9zaXRpb246IHBvc2l0aW9uICE9PSB1bmRlZmluZWQgPyBwb3NpdGlvbiA6IHByZXZTdGF0ZS5zdGFydFBvc2l0aW9uLFxuICAgICAgaW5kZXg6IGksXG4gICAgICB6SW5kaWNlc1xuICAgIH0pKTtcbiAgfTtcblxuICBfcHJvdG8ubW92ZVVwQnlTdGVwID0gZnVuY3Rpb24gbW92ZVVwQnlTdGVwKHN0ZXApIHtcbiAgICBpZiAoc3RlcCA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGVwID0gdGhpcy5wcm9wcy5zdGVwO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZVt0aGlzLnN0YXRlLmluZGV4XTsgLy8gaWYgdGhlIHNsaWRlciBpcyBpbnZlcnRlZCBhbmQgaG9yaXpvbnRhbCB3ZSB3YW50IHRvIGhvbm9yIHRoZSBpbnZlcnRlZCB2YWx1ZVxuXG4gICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLnByb3BzLmludmVydCAmJiB0aGlzLnByb3BzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgPyBvbGRWYWx1ZSAtIHN0ZXAgOiBvbGRWYWx1ZSArIHN0ZXA7XG4gICAgY29uc3QgdHJpbUFsaWduID0gdHJpbUFsaWduVmFsdWUobmV3VmFsdWUsIHRoaXMucHJvcHMpO1xuICAgIHRoaXMubW92ZShNYXRoLm1pbih0cmltQWxpZ24sIHRoaXMucHJvcHMubWF4KSk7XG4gIH07XG5cbiAgX3Byb3RvLm1vdmVEb3duQnlTdGVwID0gZnVuY3Rpb24gbW92ZURvd25CeVN0ZXAoc3RlcCkge1xuICAgIGlmIChzdGVwID09PSB2b2lkIDApIHtcbiAgICAgIHN0ZXAgPSB0aGlzLnByb3BzLnN0ZXA7XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlW3RoaXMuc3RhdGUuaW5kZXhdOyAvLyBpZiB0aGUgc2xpZGVyIGlzIGludmVydGVkIGFuZCBob3Jpem9udGFsIHdlIHdhbnQgdG8gaG9ub3IgdGhlIGludmVydGVkIHZhbHVlXG5cbiAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMucHJvcHMuaW52ZXJ0ICYmIHRoaXMucHJvcHMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/IG9sZFZhbHVlICsgc3RlcCA6IG9sZFZhbHVlIC0gc3RlcDtcbiAgICBjb25zdCB0cmltQWxpZ24gPSB0cmltQWxpZ25WYWx1ZShuZXdWYWx1ZSwgdGhpcy5wcm9wcyk7XG4gICAgdGhpcy5tb3ZlKE1hdGgubWF4KHRyaW1BbGlnbiwgdGhpcy5wcm9wcy5taW4pKTtcbiAgfTtcblxuICBfcHJvdG8ubW92ZSA9IGZ1bmN0aW9uIG1vdmUobmV3VmFsdWUpIHtcbiAgICAvLyBDbG9uZSB0aGlzLnN0YXRlLnZhbHVlIHNpbmNlIHdlJ2xsIG1vZGlmeSBpdCB0ZW1wb3JhcmlseVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB6aWxsb3cvcmVhY3Qvbm8tYWNjZXNzLXN0YXRlLWluLXNldHN0YXRlXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlLnNsaWNlKCk7XG4gICAgY29uc3Qge1xuICAgICAgaW5kZXhcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7XG4gICAgICBsZW5ndGhcbiAgICB9ID0gdmFsdWU7IC8vIFNob3J0IGNpcmN1aXQgaWYgdGhlIHZhbHVlIGlzIG5vdCBjaGFuZ2luZ1xuXG4gICAgY29uc3Qgb2xkVmFsdWUgPSB2YWx1ZVtpbmRleF07XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IG9sZFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBUcmlnZ2VyIG9ubHkgYmVmb3JlIHRoZSBmaXJzdCBtb3ZlbWVudFxuXG5cbiAgICBpZiAoIXRoaXMuaGFzTW92ZWQpIHtcbiAgICAgIHRoaXMuZmlyZUNoYW5nZUV2ZW50KCdvbkJlZm9yZUNoYW5nZScpO1xuICAgIH1cblxuICAgIHRoaXMuaGFzTW92ZWQgPSB0cnVlOyAvLyBpZiBcInBlYXJsaW5nXCIgKD0gdGh1bWJzIHB1c2hpbmcgZWFjaCBvdGhlcikgaXMgZGlzYWJsZWQsXG4gICAgLy8gcHJldmVudCB0aGUgdGh1bWIgZnJvbSBnZXR0aW5nIGNsb3NlciB0aGFuIGBtaW5EaXN0YW5jZWAgdG8gdGhlIHByZXZpb3VzIG9yIG5leHQgdGh1bWIuXG5cbiAgICBjb25zdCB7XG4gICAgICBwZWFybGluZyxcbiAgICAgIG1heCxcbiAgICAgIG1pbixcbiAgICAgIG1pbkRpc3RhbmNlXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoIXBlYXJsaW5nKSB7XG4gICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlQmVmb3JlID0gdmFsdWVbaW5kZXggLSAxXTtcblxuICAgICAgICBpZiAobmV3VmFsdWUgPCB2YWx1ZUJlZm9yZSArIG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZUJlZm9yZSArIG1pbkRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgY29uc3QgdmFsdWVBZnRlciA9IHZhbHVlW2luZGV4ICsgMV07XG5cbiAgICAgICAgaWYgKG5ld1ZhbHVlID4gdmFsdWVBZnRlciAtIG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZUFmdGVyIC0gbWluRGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWx1ZVtpbmRleF0gPSBuZXdWYWx1ZTsgLy8gaWYgXCJwZWFybGluZ1wiIGlzIGVuYWJsZWQsIGxldCB0aGUgY3VycmVudCB0aHVtYiBwdXNoIHRoZSBwcmUtIGFuZCBzdWNjZWVkaW5nIHRodW1icy5cblxuICAgIGlmIChwZWFybGluZyAmJiBsZW5ndGggPiAxKSB7XG4gICAgICBpZiAobmV3VmFsdWUgPiBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnB1c2hTdWNjZWVkaW5nKHZhbHVlLCBtaW5EaXN0YW5jZSwgaW5kZXgpO1xuICAgICAgICB0cmltU3VjY2VlZGluZyhsZW5ndGgsIHZhbHVlLCBtaW5EaXN0YW5jZSwgbWF4KTtcbiAgICAgIH0gZWxzZSBpZiAobmV3VmFsdWUgPCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnB1c2hQcmVjZWRpbmcodmFsdWUsIG1pbkRpc3RhbmNlLCBpbmRleCk7XG4gICAgICAgIHRyaW1QcmVjZWRpbmcobGVuZ3RoLCB2YWx1ZSwgbWluRGlzdGFuY2UsIG1pbik7XG4gICAgICB9XG4gICAgfSAvLyBOb3JtYWxseSB5b3Ugd291bGQgdXNlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLFxuICAgIC8vIGJ1dCBzaW5jZSB0aGUgc2xpZGVyIGlzIGEgbG93LWxldmVsIGNvbXBvbmVudCxcbiAgICAvLyB0aGUgZXh0cmEgY29tcGxleGl0eSBtaWdodCBiZSB3b3J0aCB0aGUgZXh0cmEgcGVyZm9ybWFuY2UuXG5cblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdmFsdWVcbiAgICB9LCB0aGlzLmZpcmVDaGFuZ2VFdmVudC5iaW5kKHRoaXMsICdvbkNoYW5nZScpKTtcbiAgfTtcblxuICBfcHJvdG8ucHVzaFN1Y2NlZWRpbmcgPSBmdW5jdGlvbiBwdXNoU3VjY2VlZGluZyh2YWx1ZSwgbWluRGlzdGFuY2UsIGluZGV4KSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IHBhZGRpbmc7XG5cbiAgICBmb3IgKGkgPSBpbmRleCwgcGFkZGluZyA9IHZhbHVlW2ldICsgbWluRGlzdGFuY2U7IHZhbHVlW2kgKyAxXSAhPT0gbnVsbCAmJiBwYWRkaW5nID4gdmFsdWVbaSArIDFdOyBpICs9IDEsIHBhZGRpbmcgPSB2YWx1ZVtpXSArIG1pbkRpc3RhbmNlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIHZhbHVlW2kgKyAxXSA9IGFsaWduVmFsdWUocGFkZGluZywgdGhpcy5wcm9wcyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wdXNoUHJlY2VkaW5nID0gZnVuY3Rpb24gcHVzaFByZWNlZGluZyh2YWx1ZSwgbWluRGlzdGFuY2UsIGluZGV4KSB7XG4gICAgZm9yIChsZXQgaSA9IGluZGV4LCBwYWRkaW5nID0gdmFsdWVbaV0gLSBtaW5EaXN0YW5jZTsgdmFsdWVbaSAtIDFdICE9PSBudWxsICYmIHBhZGRpbmcgPCB2YWx1ZVtpIC0gMV07IGkgLT0gMSwgcGFkZGluZyA9IHZhbHVlW2ldIC0gbWluRGlzdGFuY2UpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgdmFsdWVbaSAtIDFdID0gYWxpZ25WYWx1ZShwYWRkaW5nLCB0aGlzLnByb3BzKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmF4aXNLZXkgPSBmdW5jdGlvbiBheGlzS2V5KCkge1xuICAgIGlmICh0aGlzLnByb3BzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICByZXR1cm4gJ1knO1xuICAgIH0gLy8gRGVmYXVsdHMgdG8gJ2hvcml6b250YWwnO1xuXG5cbiAgICByZXR1cm4gJ1gnO1xuICB9O1xuXG4gIF9wcm90by5vcnRob2dvbmFsQXhpc0tleSA9IGZ1bmN0aW9uIG9ydGhvZ29uYWxBeGlzS2V5KCkge1xuICAgIGlmICh0aGlzLnByb3BzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICByZXR1cm4gJ1gnO1xuICAgIH0gLy8gRGVmYXVsdHMgdG8gJ2hvcml6b250YWwnXG5cblxuICAgIHJldHVybiAnWSc7XG4gIH07XG5cbiAgX3Byb3RvLnBvc01pbktleSA9IGZ1bmN0aW9uIHBvc01pbktleSgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuaW52ZXJ0ID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICB9IC8vIERlZmF1bHRzIHRvICdob3Jpem9udGFsJ1xuXG5cbiAgICByZXR1cm4gdGhpcy5wcm9wcy5pbnZlcnQgPyAncmlnaHQnIDogJ2xlZnQnO1xuICB9O1xuXG4gIF9wcm90by5wb3NNYXhLZXkgPSBmdW5jdGlvbiBwb3NNYXhLZXkoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmludmVydCA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgfSAvLyBEZWZhdWx0cyB0byAnaG9yaXpvbnRhbCdcblxuXG4gICAgcmV0dXJuIHRoaXMucHJvcHMuaW52ZXJ0ID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgfTtcblxuICBfcHJvdG8uc2l6ZUtleSA9IGZ1bmN0aW9uIHNpemVLZXkoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIHJldHVybiAnY2xpZW50SGVpZ2h0JztcbiAgICB9IC8vIERlZmF1bHRzIHRvICdob3Jpem9udGFsJ1xuXG5cbiAgICByZXR1cm4gJ2NsaWVudFdpZHRoJztcbiAgfTtcblxuICBfcHJvdG8uZmlyZUNoYW5nZUV2ZW50ID0gZnVuY3Rpb24gZmlyZUNoYW5nZUV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucHJvcHNbZXZlbnRdKSB7XG4gICAgICB0aGlzLnByb3BzW2V2ZW50XShwcmVwYXJlT3V0VmFsdWUodGhpcy5zdGF0ZS52YWx1ZSksIHRoaXMuc3RhdGUuaW5kZXgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uYnVpbGRUaHVtYlN0eWxlID0gZnVuY3Rpb24gYnVpbGRUaHVtYlN0eWxlKG9mZnNldCwgaSkge1xuICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB0b3VjaEFjdGlvbjogJ25vbmUnLFxuICAgICAgd2lsbENoYW5nZTogdGhpcy5zdGF0ZS5pbmRleCA+PSAwID8gdGhpcy5wb3NNaW5LZXkoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHpJbmRleDogdGhpcy5zdGF0ZS56SW5kaWNlcy5pbmRleE9mKGkpICsgMVxuICAgIH07XG4gICAgc3R5bGVbdGhpcy5wb3NNaW5LZXkoKV0gPSBvZmZzZXQgKyBcInB4XCI7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG4gIF9wcm90by5idWlsZFRyYWNrU3R5bGUgPSBmdW5jdGlvbiBidWlsZFRyYWNrU3R5bGUobWluLCBtYXgpIHtcbiAgICBjb25zdCBvYmogPSB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHdpbGxDaGFuZ2U6IHRoaXMuc3RhdGUuaW5kZXggPj0gMCA/IHRoaXMucG9zTWluS2V5KCkgKyBcIixcIiArIHRoaXMucG9zTWF4S2V5KCkgOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIG9ialt0aGlzLnBvc01pbktleSgpXSA9IG1pbjtcbiAgICBvYmpbdGhpcy5wb3NNYXhLZXkoKV0gPSBtYXg7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICBfcHJvdG8uYnVpbGRNYXJrU3R5bGUgPSBmdW5jdGlvbiBidWlsZE1hcmtTdHlsZShvZmZzZXQpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHJldHVybiBfcmVmID0ge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LCBfcmVmW3RoaXMucG9zTWluS2V5KCldID0gb2Zmc2V0LCBfcmVmO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXJUaHVtYnMgPSBmdW5jdGlvbiByZW5kZXJUaHVtYnMob2Zmc2V0KSB7XG4gICAgY29uc3Qge1xuICAgICAgbGVuZ3RoXG4gICAgfSA9IG9mZnNldDtcbiAgICBjb25zdCBzdHlsZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHN0eWxlc1tpXSA9IHRoaXMuYnVpbGRUaHVtYlN0eWxlKG9mZnNldFtpXSwgaSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICByZXNbaV0gPSB0aGlzLnJlbmRlclRodW1iKHN0eWxlc1tpXSwgaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyVHJhY2tzID0gZnVuY3Rpb24gcmVuZGVyVHJhY2tzKG9mZnNldCkge1xuICAgIGNvbnN0IHRyYWNrcyA9IFtdO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IG9mZnNldC5sZW5ndGggLSAxO1xuICAgIHRyYWNrcy5wdXNoKHRoaXMucmVuZGVyVHJhY2soMCwgMCwgb2Zmc2V0WzBdKSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RJbmRleDsgaSArPSAxKSB7XG4gICAgICB0cmFja3MucHVzaCh0aGlzLnJlbmRlclRyYWNrKGkgKyAxLCBvZmZzZXRbaV0sIG9mZnNldFtpICsgMV0pKTtcbiAgICB9XG5cbiAgICB0cmFja3MucHVzaCh0aGlzLnJlbmRlclRyYWNrKGxhc3RJbmRleCArIDEsIG9mZnNldFtsYXN0SW5kZXhdLCB0aGlzLnN0YXRlLnVwcGVyQm91bmQpKTtcbiAgICByZXR1cm4gdHJhY2tzO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXJNYXJrcyA9IGZ1bmN0aW9uIHJlbmRlck1hcmtzKCkge1xuICAgIGxldCB7XG4gICAgICBtYXJrc1xuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHJhbmdlID0gdGhpcy5wcm9wcy5tYXggLSB0aGlzLnByb3BzLm1pbiArIDE7XG5cbiAgICBpZiAodHlwZW9mIG1hcmtzID09PSAnYm9vbGVhbicpIHtcbiAgICAgIG1hcmtzID0gQXJyYXkuZnJvbSh7XG4gICAgICAgIGxlbmd0aDogcmFuZ2VcbiAgICAgIH0pLm1hcCgoXywga2V5KSA9PiBrZXkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hcmtzID09PSAnbnVtYmVyJykge1xuICAgICAgbWFya3MgPSBBcnJheS5mcm9tKHtcbiAgICAgICAgbGVuZ3RoOiByYW5nZVxuICAgICAgfSkubWFwKChfLCBrZXkpID0+IGtleSkuZmlsdGVyKGtleSA9PiBrZXkgJSBtYXJrcyA9PT0gMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmtzLm1hcChwYXJzZUZsb2F0KS5zb3J0KChhLCBiKSA9PiBhIC0gYikubWFwKG1hcmsgPT4ge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5jYWxjT2Zmc2V0KG1hcmspO1xuICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgIGtleTogbWFyayxcbiAgICAgICAgY2xhc3NOYW1lOiB0aGlzLnByb3BzLm1hcmtDbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiB0aGlzLmJ1aWxkTWFya1N0eWxlKG9mZnNldClcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5yZW5kZXJNYXJrKHByb3BzKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIGNvbnN0IG9mZnNldCA9IFtdO1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgbCA9IHZhbHVlLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICBvZmZzZXRbaV0gPSB0aGlzLmNhbGNPZmZzZXQodmFsdWVbaV0sIGkpO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYWNrcyA9IHRoaXMucHJvcHMud2l0aFRyYWNrcyA/IHRoaXMucmVuZGVyVHJhY2tzKG9mZnNldCkgOiBudWxsO1xuICAgIGNvbnN0IHRodW1icyA9IHRoaXMucmVuZGVyVGh1bWJzKG9mZnNldCk7XG4gICAgY29uc3QgbWFya3MgPSB0aGlzLnByb3BzLm1hcmtzID8gdGhpcy5yZW5kZXJNYXJrcygpIDogbnVsbDtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgIHJlZjogciA9PiB7XG4gICAgICAgIHRoaXMuc2xpZGVyID0gcjtcbiAgICAgICAgdGhpcy5yZXNpemVFbGVtZW50UmVmLmN1cnJlbnQgPSByO1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgICB9LFxuICAgICAgY2xhc3NOYW1lOiB0aGlzLnByb3BzLmNsYXNzTmFtZSArICh0aGlzLnByb3BzLmRpc2FibGVkID8gJyBkaXNhYmxlZCcgOiAnJyksXG4gICAgICBvbk1vdXNlRG93bjogdGhpcy5vblNsaWRlck1vdXNlRG93bixcbiAgICAgIG9uQ2xpY2s6IHRoaXMub25TbGlkZXJDbGlja1xuICAgIH0sIHRyYWNrcywgdGh1bWJzLCBtYXJrcyk7XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0U2xpZGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5SZWFjdFNsaWRlci5kaXNwbGF5TmFtZSA9ICdSZWFjdFNsaWRlcic7XG5SZWFjdFNsaWRlci5kZWZhdWx0UHJvcHMgPSB7XG4gIG1pbjogMCxcbiAgbWF4OiAxMDAsXG4gIHN0ZXA6IDEsXG4gIHBhZ2VGbjogc3RlcCA9PiBzdGVwICogMTAsXG4gIG1pbkRpc3RhbmNlOiAwLFxuICBkZWZhdWx0VmFsdWU6IDAsXG4gIG9yaWVudGF0aW9uOiAnaG9yaXpvbnRhbCcsXG4gIGNsYXNzTmFtZTogJ3NsaWRlcicsXG4gIHRodW1iQ2xhc3NOYW1lOiAndGh1bWInLFxuICB0aHVtYkFjdGl2ZUNsYXNzTmFtZTogJ2FjdGl2ZScsXG4gIHRyYWNrQ2xhc3NOYW1lOiAndHJhY2snLFxuICBtYXJrQ2xhc3NOYW1lOiAnbWFyaycsXG4gIHdpdGhUcmFja3M6IHRydWUsXG4gIHBlYXJsaW5nOiBmYWxzZSxcbiAgZGlzYWJsZWQ6IGZhbHNlLFxuICBzbmFwRHJhZ0Rpc2FibGVkOiBmYWxzZSxcbiAgaW52ZXJ0OiBmYWxzZSxcbiAgbWFya3M6IFtdLFxuICByZW5kZXJUaHVtYjogcHJvcHMgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgX19zZWxmOiBSZWFjdFNsaWRlcixcbiAgICBfX3NvdXJjZToge1xuICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IDM1MyxcbiAgICAgIGNvbHVtbk51bWJlcjogMzFcbiAgICB9XG4gIH0pKSxcbiAgcmVuZGVyVHJhY2s6IHByb3BzID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIF9fc2VsZjogUmVhY3RTbGlkZXIsXG4gICAgX19zb3VyY2U6IHtcbiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiAzNTQsXG4gICAgICBjb2x1bW5OdW1iZXI6IDMxXG4gICAgfVxuICB9KSksXG4gIHJlbmRlck1hcms6IHByb3BzID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBfX3NlbGY6IFJlYWN0U2xpZGVyLFxuICAgIF9fc291cmNlOiB7XG4gICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogMzU1LFxuICAgICAgY29sdW1uTnVtYmVyOiAzMFxuICAgIH1cbiAgfSkpXG59O1xuUmVhY3RTbGlkZXIucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICAvKipcbiAgICogVGhlIG1pbmltdW0gdmFsdWUgb2YgdGhlIHNsaWRlci5cbiAgICovXG4gIG1pbjogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gdmFsdWUgb2YgdGhlIHNsaWRlci5cbiAgICovXG4gIG1heDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogVmFsdWUgdG8gYmUgYWRkZWQgb3Igc3VidHJhY3RlZCBvbiBlYWNoIHN0ZXAgdGhlIHNsaWRlciBtYWtlcy5cbiAgICogTXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby5cbiAgICogYG1heCAtIG1pbmAgc2hvdWxkIGJlIGV2ZW5seSBkaXZpc2libGUgYnkgdGhlIHN0ZXAgdmFsdWUuXG4gICAqL1xuICBzdGVwOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBUaGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBpcyB0aGUgdmFsdWUgdG8gYmUgYWRkZWQgb3Igc3VidHJhY3RlZFxuICAgKiB3aGVuIHRoZSBgUGFnZSBVcGAgb3IgYFBhZ2UgRG93bmAga2V5cyBhcmUgcHJlc3NlZC5cbiAgICpcbiAgICogVGhlIGN1cnJlbnQgYHN0ZXBgIHZhbHVlIHdpbGwgYmUgcGFzc2VkIGFzIHRoZSBvbmx5IGFyZ3VtZW50LlxuICAgKiBCeSBkZWZhdWx0LCBwYWdpbmcgd2lsbCBtb2RpZnkgYHN0ZXBgIGJ5IGEgZmFjdG9yIG9mIDEwLlxuICAgKi9cbiAgcGFnZUZuOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogVGhlIG1pbmltYWwgZGlzdGFuY2UgYmV0d2VlbiBhbnkgcGFpciBvZiB0aHVtYnMuXG4gICAqIE11c3QgYmUgcG9zaXRpdmUsIGJ1dCB6ZXJvIG1lYW5zIHRoZXkgY2FuIHNpdCBvbiB0b3Agb2YgZWFjaCBvdGhlci5cbiAgICovXG4gIG1pbkRpc3RhbmNlOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBpbml0aWFsIHBvc2l0aW9ucyBvZiB0aGUgdGh1bWJzIGFuZCB0aGUgbnVtYmVyIG9mIHRodW1icy5cbiAgICpcbiAgICogSWYgYSBudW1iZXIgaXMgcGFzc2VkIGEgc2xpZGVyIHdpdGggb25lIHRodW1iIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAqIElmIGFuIGFycmF5IGlzIHBhc3NlZCBlYWNoIHZhbHVlIHdpbGwgZGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBvbmUgdGh1bWIuXG4gICAqIFRoZSB2YWx1ZXMgaW4gdGhlIGFycmF5IG11c3QgYmUgc29ydGVkLlxuICAgKi9cbiAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKV0pLFxuXG4gIC8qKlxuICAgKiBMaWtlIGBkZWZhdWx0VmFsdWVgIGJ1dCBmb3JcbiAgICogW2NvbnRyb2xsZWQgY29tcG9uZW50c10oaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2Zvcm1zLmh0bWwjY29udHJvbGxlZC1jb21wb25lbnRzKS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB6aWxsb3cvcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzXG4gIHZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKV0pLFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNsaWRlciBtb3ZlcyBob3Jpem9udGFsbHkgKGZyb20gbGVmdCB0byByaWdodClcbiAgICogb3IgdmVydGljYWxseSAoZnJvbSB0b3AgdG8gYm90dG9tKS5cbiAgICovXG4gIG9yaWVudGF0aW9uOiBQcm9wVHlwZXMub25lT2YoWydob3Jpem9udGFsJywgJ3ZlcnRpY2FsJ10pLFxuXG4gIC8qKlxuICAgKiBUaGUgY3NzIGNsYXNzIHNldCBvbiB0aGUgc2xpZGVyIG5vZGUuXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBjc3MgY2xhc3Mgc2V0IG9uIGVhY2ggdGh1bWIgbm9kZS5cbiAgICpcbiAgICogSW4gYWRkaXRpb24gZWFjaCB0aHVtYiB3aWxsIHJlY2VpdmUgYSBudW1iZXJlZCBjc3MgY2xhc3Mgb2YgdGhlIGZvcm1cbiAgICogYCR7dGh1bWJDbGFzc05hbWV9LSR7aX1gLCBlLmcuIGB0aHVtYi0wYCwgYHRodW1iLTFgLCAuLi5cbiAgICovXG4gIHRodW1iQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY3NzIGNsYXNzIHNldCBvbiB0aGUgdGh1bWIgdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgbW92ZWQuXG4gICAqL1xuICB0aHVtYkFjdGl2ZUNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSWYgYHRydWVgIHRyYWNrcyBiZXR3ZWVuIHRoZSB0aHVtYnMgd2lsbCBiZSByZW5kZXJlZC5cbiAgICovXG4gIHdpdGhUcmFja3M6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgY3NzIGNsYXNzIHNldCBvbiB0aGUgdHJhY2tzIGJldHdlZW4gdGhlIHRodW1icy5cbiAgICogSW4gYWRkaXRpb24gdHJhY2sgZnJhZ21lbnQgd2lsbCByZWNlaXZlIGEgbnVtYmVyZWQgY3NzIGNsYXNzIG9mIHRoZSBmb3JtXG4gICAqIGAke3RyYWNrQ2xhc3NOYW1lfS0ke2l9YCwgZS5nLiBgdHJhY2stMGAsIGB0cmFjay0xYCwgLi4uXG4gICAqL1xuICB0cmFja0NsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSWYgYHRydWVgIHRoZSBhY3RpdmUgdGh1bWIgd2lsbCBwdXNoIG90aGVyIHRodW1ic1xuICAgKiB3aXRoaW4gdGhlIGNvbnN0cmFpbnRzIG9mIGBtaW5gLCBgbWF4YCwgYHN0ZXBgIGFuZCBgbWluRGlzdGFuY2VgLlxuICAgKi9cbiAgcGVhcmxpbmc6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAgdGhlIHRodW1icyBjYW4ndCBiZSBtb3ZlZC5cbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogRGlzYWJsZXMgdGh1bWIgbW92ZSB3aGVuIGNsaWNraW5nIHRoZSBzbGlkZXIgdHJhY2tcbiAgICovXG4gIHNuYXBEcmFnRGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJbnZlcnRzIHRoZSBzbGlkZXIuXG4gICAqL1xuICBpbnZlcnQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBTaG93cyBwYXNzZWQgbWFya3Mgb24gdGhlIHRyYWNrLCBpZiB0cnVlIGl0IHNob3dzIGFsbCB0aGUgbWFya3MsXG4gICAqIGlmIGFuIGFycmF5IG9mIG51bWJlcnMgaXQgc2hvd3MganVzdCB0aGUgcGFzc2VkIG1hcmtzLCBpZiBhIG51bWJlciBpcyBwYXNzZWRcbiAgICogaXQgc2hvd3MganVzdCB0aGUgbWFya3MgaW4gdGhhdCBzdGVwczogbGlrZSBwYXNzaW5nIDMgc2hvd3MgdGhlIG1hcmtzIDMsIDYsIDlcbiAgICovXG4gIG1hcmtzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKSwgUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5udW1iZXJdKSxcblxuICAvKipcbiAgICogVGhlIGNzcyBjbGFzcyBzZXQgb24gdGhlIG1hcmtzLlxuICAgKi9cbiAgbWFya0NsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIGJlZm9yZSBzdGFydGluZyB0byBtb3ZlIGEgdGh1bWIuIFRoZSBjYWxsYmFjayB3aWxsIG9ubHkgYmUgY2FsbGVkIGlmIHRoZVxuICAgKiBhY3Rpb24gd2lsbCByZXN1bHQgaW4gYSBjaGFuZ2UuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHMsIHRoZSBmaXJzdFxuICAgKiBiZWluZyB0aGUgaW5pdGlhbCB2YWx1ZShzKSB0aGUgc2Vjb25kIGJlaW5nIHRodW1iIGluZGV4LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHppbGxvdy9yZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHMsIHppbGxvdy9yZWFjdC9uby11bnVzZWQtcHJvcC10eXBlc1xuICBvbkJlZm9yZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCBvbiBldmVyeSB2YWx1ZSBjaGFuZ2UuXG4gICAqIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHMsIHRoZSBmaXJzdCBiZWluZyB0aGUgbmV3IHZhbHVlKHMpXG4gICAqIHRoZSBzZWNvbmQgYmVpbmcgdGh1bWIgaW5kZXguXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgemlsbG93L3JlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wcywgemlsbG93L3JlYWN0L25vLXVudXNlZC1wcm9wLXR5cGVzXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIG9ubHkgYWZ0ZXIgbW92aW5nIGEgdGh1bWIgaGFzIGVuZGVkLiBUaGUgY2FsbGJhY2sgd2lsbCBvbmx5IGJlIGNhbGxlZCBpZlxuICAgKiB0aGUgYWN0aW9uIHJlc3VsdGVkIGluIGEgY2hhbmdlLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzLCB0aGVcbiAgICogZmlyc3QgYmVpbmcgdGhlIHJlc3VsdCB2YWx1ZShzKSB0aGUgc2Vjb25kIGJlaW5nIHRodW1iIGluZGV4LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHppbGxvdy9yZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHMsIHppbGxvdy9yZWFjdC9uby11bnVzZWQtcHJvcC10eXBlc1xuICBvbkFmdGVyQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHRoZSBzbGlkZXIgaXMgY2xpY2tlZCAodGh1bWIgb3IgdHJhY2tzKS5cbiAgICogUmVjZWl2ZXMgdGhlIHZhbHVlIGF0IHRoZSBjbGlja2VkIHBvc2l0aW9uIGFzIGFyZ3VtZW50LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHppbGxvdy9yZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHNcbiAgb25TbGlkZXJDbGljazogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIGFyaWEtbGFiZWwgZm9yIHNjcmVlbi1yZWFkZXJzIHRvIGFwcGx5IHRvIHRoZSB0aHVtYnMuXG4gICAqIFVzZSBhbiBhcnJheSBmb3IgbW9yZSB0aGFuIG9uZSB0aHVtYi5cbiAgICogVGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgbXVzdCBtYXRjaCB0aGUgbnVtYmVyIG9mIHRodW1icyBpbiB0aGUgdmFsdWUgYXJyYXkuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgemlsbG93L3JlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wc1xuICBhcmlhTGFiZWw6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpXSksXG5cbiAgLyoqXG4gICAqIGFyaWEtbGFiZWxsZWRieSBmb3Igc2NyZWVuLXJlYWRlcnMgdG8gYXBwbHkgdG8gdGhlIHRodW1icy5cbiAgICogVXNlZCB3aGVuIHNsaWRlciByZW5kZXJlZCB3aXRoIHNlcGFyYXRlIGxhYmVsLlxuICAgKiBVc2UgYW4gYXJyYXkgZm9yIG1vcmUgdGhhbiBvbmUgdGh1bWIuXG4gICAqIFRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG11c3QgbWF0Y2ggdGhlIG51bWJlciBvZiB0aHVtYnMgaW4gdGhlIHZhbHVlIGFycmF5LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHppbGxvdy9yZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHNcbiAgYXJpYUxhYmVsbGVkYnk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpXSksXG5cbiAgLyoqXG4gICAqIGFyaWEtdmFsdWV0ZXh0IGZvciBzY3JlZW4tcmVhZGVycy5cbiAgICogQ2FuIGJlIGEgc3RhdGljIHN0cmluZywgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdHJpbmcuXG4gICAqIFRoZSBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCBhIHNpbmdsZSBhcmd1bWVudCxcbiAgICogYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgICAgc3RhdGUgPT4gYFZhbHVlOiAke3N0YXRlLnZhbHVlfWBcbiAgICpcbiAgICogLSBgc3RhdGUuaW5kZXhgIHtgbnVtYmVyYH0gdGhlIGluZGV4IG9mIHRoZSB0aHVtYlxuICAgKiAtIGBzdGF0ZS52YWx1ZWAge2BudW1iZXJgIHwgYGFycmF5YH0gdGhlIGN1cnJlbnQgdmFsdWUgc3RhdGVcbiAgICogLSBgc3RhdGUudmFsdWVOb3dgIHtgbnVtYmVyYH0gdGhlIHZhbHVlIG9mIHRoZSB0aHVtYiAoaS5lLiBhcmlhLXZhbHVlbm93KVxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHppbGxvdy9yZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHNcbiAgYXJpYVZhbHVldGV4dDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKSxcblxuICAvKipcbiAgICogUHJvdmlkZSBhIGN1c3RvbSByZW5kZXIgZnVuY3Rpb24gZm9yIHRoZSB0cmFjayBub2RlLlxuICAgKiBUaGUgcmVuZGVyIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIHR3byBhcmd1bWVudHMsXG4gICAqIGFuIG9iamVjdCB3aXRoIHByb3BzIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHlvdXIgaGFuZGxlIG5vZGUsXG4gICAqIGFuZCBhbiBvYmplY3Qgd2l0aCB0cmFjayBhbmQgc2xpZGVyIHN0YXRlOlxuICAgKlxuICAgKiAgICAgKHByb3BzLCBzdGF0ZSkgPT4gPGRpdiB7Li4ucHJvcHN9IC8+XG4gICAqXG4gICAqIC0gYHByb3BzYCB7YG9iamVjdGB9IHByb3BzIHRvIGJlIHNwcmVhZCBpbnRvIHlvdXIgdHJhY2sgbm9kZVxuICAgKiAtIGBzdGF0ZS5pbmRleGAge2BudW1iZXJgfSB0aGUgaW5kZXggb2YgdGhlIHRyYWNrXG4gICAqIC0gYHN0YXRlLnZhbHVlYCB7YG51bWJlcmAgfCBgYXJyYXlgfSB0aGUgY3VycmVudCB2YWx1ZSBzdGF0ZVxuICAgKi9cbiAgcmVuZGVyVHJhY2s6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgY3VzdG9tIHJlbmRlciBmdW5jdGlvbiBmb3IgZHluYW1pYyB0aHVtYiBjb250ZW50LlxuICAgKiBUaGUgcmVuZGVyIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIHR3byBhcmd1bWVudHMsXG4gICAqIGFuIG9iamVjdCB3aXRoIHByb3BzIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHlvdXIgdGh1bWIgbm9kZSxcbiAgICogYW5kIGFuIG9iamVjdCB3aXRoIHRodW1iIGFuZCBzbGlkZXIgc3RhdGU6XG4gICAqXG4gICAqICAgICAocHJvcHMsIHN0YXRlKSA9PiA8ZGl2IHsuLi5wcm9wc30gLz5cbiAgICpcbiAgICogLSBgcHJvcHNgIHtgb2JqZWN0YH0gcHJvcHMgdG8gYmUgc3ByZWFkIGludG8geW91ciB0aHVtYiBub2RlXG4gICAqIC0gYHN0YXRlLmluZGV4YCB7YG51bWJlcmB9IHRoZSBpbmRleCBvZiB0aGUgdGh1bWJcbiAgICogLSBgc3RhdGUudmFsdWVgIHtgbnVtYmVyYCB8IGBhcnJheWB9IHRoZSBjdXJyZW50IHZhbHVlIHN0YXRlXG4gICAqIC0gYHN0YXRlLnZhbHVlTm93YCB7YG51bWJlcmB9IHRoZSB2YWx1ZSBvZiB0aGUgdGh1bWIgKGkuZS4gYXJpYS12YWx1ZW5vdylcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB6aWxsb3cvcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzXG4gIHJlbmRlclRodW1iOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogUHJvdmlkZSBhIGN1c3RvbSByZW5kZXIgZnVuY3Rpb24gZm9yIHRoZSBtYXJrIG5vZGUuXG4gICAqIFRoZSByZW5kZXIgZnVuY3Rpb24gd2lsbCBiZSBwYXNzZWQgb25lIGFyZ3VtZW50LFxuICAgKiBhbiBvYmplY3Qgd2l0aCBwcm9wcyB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB5b3VyIGhhbmRsZSBub2RlXG4gICAqXG4gICAqICAgICAocHJvcHMpID0+IDxzcGFuIHsuLi5wcm9wc30gLz5cbiAgICpcbiAgICogLSBgcHJvcHNgIHtgb2JqZWN0YH0gcHJvcHMgdG8gYmUgc3ByZWFkIGludG8geW91ciB0cmFjayBub2RlXG4gICAqL1xuICByZW5kZXJNYXJrOiBQcm9wVHlwZXMuZnVuY1xufSA6IHt9O1xudmFyIFJlYWN0U2xpZGVyJDEgPSBSZWFjdFNsaWRlcjtcblxuZXhwb3J0IHsgUmVhY3RTbGlkZXIkMSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFjdFNsaWRlci5tanMubWFwXG4iXSwibmFtZXMiOlsiX2V4dGVuZHMiLCJfaW5oZXJpdHNMb29zZSIsIlJlYWN0IiwiUHJvcFR5cGVzIiwiX2pzeEZpbGVOYW1lIiwicGF1c2VFdmVudCIsImUiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsInNhbml0aXplSW5WYWx1ZSIsIngiLCJBcnJheSIsImlzQXJyYXkiLCJzbGljZSIsInByZXBhcmVPdXRWYWx1ZSIsImxlbmd0aCIsInRyaW1TdWNjZWVkaW5nIiwibmV4dFZhbHVlIiwibWluRGlzdGFuY2UiLCJtYXgiLCJpIiwicGFkZGluZyIsInRyaW1QcmVjZWRpbmciLCJtaW4iLCJhZGRIYW5kbGVycyIsImV2ZW50TWFwIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVIYW5kbGVycyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0cmltQWxpZ25WYWx1ZSIsInZhbCIsInByb3BzIiwiYWxpZ25WYWx1ZSIsInRyaW1WYWx1ZSIsInZhbE1vZFN0ZXAiLCJzdGVwIiwiYWxpZ25lZFZhbHVlIiwiTWF0aCIsImFicyIsInBhcnNlRmxvYXQiLCJ0b0ZpeGVkIiwidHJpbW1lZCIsIlJlYWN0U2xpZGVyIiwiX1JlYWN0JENvbXBvbmVudCIsIl9wcm9wcyIsIl90aGlzIiwiY2FsbCIsIm9uS2V5VXAiLCJvbkVuZCIsIm9uTW91c2VVcCIsImdldE1vdXNlRXZlbnRNYXAiLCJvblRvdWNoRW5kIiwiZ2V0VG91Y2hFdmVudE1hcCIsIm9uQmx1ciIsInNldFN0YXRlIiwiaW5kZXgiLCJnZXRLZXlEb3duRXZlbnRNYXAiLCJvbk1vdXNlTW92ZSIsInBlbmRpbmciLCJwb3NpdGlvbiIsImdldE1vdXNlUG9zaXRpb24iLCJkaWZmUG9zaXRpb24iLCJnZXREaWZmUG9zaXRpb24iLCJuZXdWYWx1ZSIsImdldFZhbHVlRnJvbVBvc2l0aW9uIiwibW92ZSIsIm9uVG91Y2hNb3ZlIiwidG91Y2hlcyIsImdldFRvdWNoUG9zaXRpb24iLCJpc1Njcm9sbGluZyIsImRpZmZNYWluRGlyIiwic3RhcnRQb3NpdGlvbiIsImRpZmZTY3JvbGxEaXIiLCJvbktleURvd24iLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJtZXRhS2V5IiwibW92ZURvd25CeVN0ZXAiLCJtb3ZlVXBCeVN0ZXAiLCJwYWdlRm4iLCJvblNsaWRlck1vdXNlRG93biIsImRpc2FibGVkIiwiYnV0dG9uIiwic25hcERyYWdEaXNhYmxlZCIsImZvcmNlVmFsdWVGcm9tUG9zaXRpb24iLCJzdGFydCIsIm9uU2xpZGVyQ2xpY2siLCJoYXNNb3ZlZCIsInZhbHVlQXRQb3MiLCJjYWxjVmFsdWUiLCJjYWxjT2Zmc2V0RnJvbVBvc2l0aW9uIiwiY3JlYXRlT25LZXlEb3duIiwiY3JlYXRlT25Nb3VzZURvd24iLCJjcmVhdGVPblRvdWNoU3RhcnQiLCJ1bmRlZmluZWQiLCJoYW5kbGVSZXNpemUiLCJyZXNpemVUaW1lb3V0Iiwid2luZG93Iiwic2V0VGltZW91dCIsInBlbmRpbmdSZXNpemVUaW1lb3V0cyIsInNoaWZ0IiwicmVzaXplIiwicHVzaCIsInJlbmRlclRodW1iIiwic3R5bGUiLCJjbGFzc05hbWUiLCJ0aHVtYkNsYXNzTmFtZSIsInN0YXRlIiwidGh1bWJBY3RpdmVDbGFzc05hbWUiLCJyIiwib3JpZW50YXRpb24iLCJ2YWx1ZSIsImFyaWFMYWJlbCIsImFyaWFMYWJlbGxlZGJ5IiwidmFsdWVOb3ciLCJhcmlhVmFsdWV0ZXh0IiwicmVuZGVyVHJhY2siLCJvZmZzZXRGcm9tIiwib2Zmc2V0VG8iLCJ0cmFja0NsYXNzTmFtZSIsImJ1aWxkVHJhY2tTdHlsZSIsInVwcGVyQm91bmQiLCJkZWZhdWx0VmFsdWUiLCJ6SW5kaWNlcyIsInJlc2l6ZU9ic2VydmVyIiwicmVzaXplRWxlbWVudFJlZiIsImNyZWF0ZVJlZiIsInNsaWRlckxlbmd0aCIsIl9wcm90byIsInByb3RvdHlwZSIsImNvbXBvbmVudERpZE1vdW50IiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY3VycmVudCIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsIm1hcCIsIml0ZW0iLCJjb21wb25lbnREaWRVcGRhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImNsZWFyUGVuZGluZ1Jlc2l6ZVRpbWVvdXRzIiwiZGlzY29ubmVjdCIsImZpcmVDaGFuZ2VFdmVudCIsImdldFZhbHVlIiwiZ2V0Q2xvc2VzdEluZGV4IiwicGl4ZWxPZmZzZXQiLCJtaW5EaXN0IiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiY2xvc2VzdEluZGV4IiwibCIsIm9mZnNldCIsImNhbGNPZmZzZXQiLCJkaXN0IiwiYXhpc0tleSIsIm9ydGhvZ29uYWxBeGlzS2V5IiwidG91Y2giLCJrZXlkb3duIiwia2V5dXAiLCJmb2N1c291dCIsIm1vdXNlbW92ZSIsIm1vdXNldXAiLCJ0b3VjaG1vdmUiLCJ0b3VjaGVuZCIsImRpZmZWYWx1ZSIsInRodW1iU2l6ZSIsInN0YXJ0VmFsdWUiLCJpbnZlcnQiLCJzbGlkZXIiLCJ0aHVtYjAiLCJ0aHVtYiIsInNpemVLZXkiLCJzbGlkZXJSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2xpZGVyU2l6ZSIsInNsaWRlck1heCIsInBvc01heEtleSIsInNsaWRlck1pbiIsInBvc01pbktleSIsInRodW1iUmVjdCIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsInJhbmdlIiwicmF0aW8iLCJ3aW5kb3dPZmZzZXQiLCJzbGlkZXJTdGFydCIsImNhbGxiYWNrIiwibmV4dFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJ0aHVtYlJlZiIsImZvY3VzIiwic3BsaWNlIiwiaW5kZXhPZiIsInByZXZTdGF0ZSIsIm9sZFZhbHVlIiwidHJpbUFsaWduIiwicGVhcmxpbmciLCJ2YWx1ZUJlZm9yZSIsInZhbHVlQWZ0ZXIiLCJwdXNoU3VjY2VlZGluZyIsInB1c2hQcmVjZWRpbmciLCJiaW5kIiwiZXZlbnQiLCJidWlsZFRodW1iU3R5bGUiLCJ0b3VjaEFjdGlvbiIsIndpbGxDaGFuZ2UiLCJ6SW5kZXgiLCJvYmoiLCJidWlsZE1hcmtTdHlsZSIsIl9yZWYiLCJyZW5kZXJUaHVtYnMiLCJzdHlsZXMiLCJyZXMiLCJyZW5kZXJUcmFja3MiLCJ0cmFja3MiLCJsYXN0SW5kZXgiLCJyZW5kZXJNYXJrcyIsIm1hcmtzIiwiZnJvbSIsIl8iLCJmaWx0ZXIiLCJzb3J0IiwiYSIsImIiLCJtYXJrIiwibWFya0NsYXNzTmFtZSIsInJlbmRlck1hcmsiLCJyZW5kZXIiLCJ3aXRoVHJhY2tzIiwidGh1bWJzIiwiY3JlYXRlRWxlbWVudCIsInJlZiIsIm9uTW91c2VEb3duIiwib25DbGljayIsIkNvbXBvbmVudCIsImRpc3BsYXlOYW1lIiwiZGVmYXVsdFByb3BzIiwiX19zZWxmIiwiX19zb3VyY2UiLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJjb2x1bW5OdW1iZXIiLCJwcm9wVHlwZXMiLCJwcm9jZXNzIiwibnVtYmVyIiwiZnVuYyIsIm9uZU9mVHlwZSIsImFycmF5T2YiLCJvbmVPZiIsInN0cmluZyIsImJvb2wiLCJvbkJlZm9yZUNoYW5nZSIsIm9uQ2hhbmdlIiwib25BZnRlckNoYW5nZSIsIlJlYWN0U2xpZGVyJDEiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-slider/dist/es/dev/components/ReactSlider/ReactSlider.mjs\n");

/***/ })

};
;